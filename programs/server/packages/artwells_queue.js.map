{"version":3,"file":"/packages/artwells:queue.js","sources":["artwells:queue/queue.js","artwells:queue/lib/model.js","artwells:queue/lib/server/server.js"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;AAAA,W;AACA,4C;AACA,mF;AACA,C;AACA,2C;AACA,iD;AACA,C;AACA,mD;AACA,8C;AACA,C;AACA,iD;AACA,kK;AACA,C;AACA,+C;AACA,oE;AACA,C;AACA,4C;AACA,sD;AACA,C;AACA,iD;AACA,8D;AACA,C;;;;;;;;;;;;;;;;;;;;ACrBA,I;AACA,e;AACA,E;AACA,G;AACA,uB;AACA,wB;AACA,mC;AACA,yB;AACA,gC;AACA,2E;AACA,mB;AACA,O;AACA,mD;AACA,+B;AACA,4B;AACA,4B;AACA,G;AACA,E;AACA,G;;;AAGA,G;AACA,mB;AACA,E;AACA,qB;AACA,qC;AACA,2B;AACA,wB;AACA,wB;AACA,a;AACA,c;AACA,K;AACA,K;AACA,G;;;AAGA,+C;AACA,8C;;;AAGA,sB;AACA,+E;AACA,4C;AACA,2D;AACA,+D;AACA,4B;AACA,8E;AACA,qE;AACA,qB;AACA,uB;AACA,O;AACA,M;AACA,G;AACA,8B;AACA,C;;;;;;;;;;;;;;;;;;ACtDA,kC;AACA,0B;AACA,mD;AACA,iD;AACA,E;;AAEA,yC;AACA,yD;AACA,wB;AACA,4D;AACA,G;AACA,gF;AACA,E;;AAEA,+C;AACA,yD;AACA,wB;AACA,2D;AACA,G;AACA,0E;AACA,E;;AAEA,8B;AACA,kB;AACA,iF;AACA,sB;AACA,oD;AACA,iB;AACA,G;AACA,0C;AACA,iB;AACA,G;AACA,qC;;AAEA,mF;AACA,qC;AACA,G;AACA,iD;AACA,+C;AACA,0C;;;AAGA,+E;;AAEA,2C;AACA,yC;AACA,G;;AAEA,uC;AACA,iC;AACA,G;;AAEA,4C;AACA,2C;AACA,G;;AAEA,gD;AACA,mD;AACA,G;;AAEA,+C;AACA,+C;AACA,G;;AAEA,4C;AACA,2C;AACA,G;AACA,qC;AACA,qC;;AAEA,O;AACA,2C;AACA,e;AACA,uE;AACA,iE;AACA,6B;AACA,yI;AACA,oC;AACA,6C;AACA,qI;AACA,K;AACA,G;AACA,a;AACA,E;;AAEA,kE;AACA,mC;AACA,8C;AACA,E;;AAEA,qC;AACA,oB;AACA,E;AACA,6B;AACA,iD;AACA,2D;AACA,iC;AACA,2H;AACA,iF;AACA,uC;AACA,G;;AAEA,wC;AACA,4B;AACA,G;;AAEA,sH;AACA,8B;AACA,M;;AAEA,E;;AAEA,kE;AACA,4C;AACA,2E;AACA,uB;AACA,gB;AACA,G;AACA,e;AACA,E;;AAEA,mC;AACA,kC;AACA,qB;AACA,yB;AACA,qB;AACA,O;AACA,2C;AACA,e;AACA,mB;AACA,oB;AACA,G;AACA,yB;AACA,mD;AACA,gI;AACA,K;AACA,4B;AACA,iD;AACA,iF;AACA,c;AACA,gE;AACA,O;AACA,qI;AACA,iD;AACA,2J;AACA,O;AACA,K;AACA,gB;AACA,G;;AAEA,2B;AACA,iI;AACA,G;;AAEA,4B;AACA,8B;AACA,iE;AACA,yH;AACA,wD;AACA,uJ;AACA,K;AACA,U;AACA,+C;AACA,gF;AACA,Y;AACA,gE;AACA,K;AACA,uI;AACA,sD;AACA,uJ;AACA,K;AACA,G;AACA,e;AACA,E;;;AAGA,6B;AACA,sC;AACA,oC;AACA,c;AACA,G;AACA,iB;AACA,0B;AACA,mB;AACA,sF;AACA,iC;AACA,gC;AACA,+B;AACA,8B;AACA,uB;AACA,6B;AACA,sI;AACA,K;AACA,iB;AACA,G;;AAEA,qB;AACA,iF;AACA,oC;AACA,G;AACA,6C;AACA,oD;AACA,+B;AACA,gC;AACA,yB;AACA,K;AACA,Y;AACA,qB;AACA,c;AACA,E","sourcesContent":["Queue = {};\nif (typeof Queue.loglevel === \"undefined\") {\n  Queue.loglevel = 3; /* 3 only includes lock conflicts.  2,3 includes successes */\n}\nif (typeof Queue.logLife === \"undefined\") {\n  Queue.logLife = 30; /* days to keep logfiles */\n}\nif (typeof Queue.defaultPriority === \"undefined\") {\n  Queue.defaultPriority = 5;/* 1 is highest */\n}\nif (typeof Queue.defaultStatus === \"undefined\") {\n  Queue.defaultStatus = \"pending\";/* by changing this to some other new word, you can make sure queue items are \"blessed\" in \"pending\" through another process. */\n}\nif (typeof Queue.keepsuccess === \"undefined\") {\n  Queue.keepsuccess = true; /* keep successful in queue as record */\n}\nif (typeof Queue.lockLife === \"undefined\") {\n  Queue.lockLife = 30; /* minutes to keep lockfiles */\n}\nif (typeof Queue.completedLife === \"undefined\") {\n  Queue.completedLife = 30; /* days to keep completed tasks */\n}\n\n","/** \n * queue schema\n *\n *{\n *    \"_id\" : ObjectId,\n *    \"status\" : string,\n *    \"priority\" : int, // 1s first\n *    \"command\" : string,\n *    \"execute_after\" : ISODate,\n *    \"lock_name\" : string, //only allow one task of this name to be queued\n *    \"history\" : {\n *   },\n *    \"reattempt\" :  //number of minutes to requeue\n *    \"log_success\" : //boolean\n *    \"created_at\": ISODate,\n *    \"updated_at\": ISODate \n *}\n *\n */\n\n\n/**\n *  queuelog schema\n *\n *  \"_id\" : ObjectId,\n *   \"status\" : string, // lockfailed\n *   \"created_at\" : ISODate\n *   \"command\" : string,\n *   \"parent_id\": string\n *  \"data\": {\n *     results\n *  }\n *   \n */\n\n\nQueue.entries = new Meteor.Collection(\"queue\");\nQueue.log = new Meteor.Collection(\"queuelog\");\n\n\nif (Meteor.isServer) {\n  Queue.entries._ensureIndex({ lock_name: 1 }, { unique: true, sparse: true });\n  /*just until Meteor bring findAndModify */\n  if (typeof Queue.entries.findAndModify === \"undefined\") {\n    Queue.entries.findAndModify = function (query, sort, mod) {\n      sort.reactive = false;\n      var results = Queue.entries.find(query, sort, {reactive: true}).fetch();\n      var modified = Queue.entries.update(query, mod, {multi: true});\n      if (modified) {\n        return results;\n      }\n    };\n  }\n  /* end fake findAndModify */\n}","Queue.purgeOldLogs = function () {\n  var before = new Date();\n  before.setDate(before.getDate() - Queue.logLife);\n  Queue.log.remove({created_at: {$lte: before}});\n};\n\nQueue.purgeOldLocks = function (before) {\n  if (typeof before === \"undefined\" || before === null) {\n    before = new Date();\n    before.setMinutes(before.getMinutes() - Queue.lockLife);\n  }\n  Queue.entries.remove({created_at: {$lte: before}, lockname: {$exists: true}});\n};\n\nQueue.purgeCompletedTasks = function (before) {\n  if (typeof before === \"undefined\" || before === null) {\n    before = new Date();\n    before.setDate(before.getDate() - Queue.completedLife);\n  }\n  Queue.entries.remove({updated_at: {$lte: before}, status: 'completed'});\n};\n\nQueue.add = function (entry) {\n  var res = false;\n  /*command, name,  priority, execute_after, reattempt, lock_name, logsuccesses*/\n  var entryarray = [];\n  if (typeof entry !== \"object\" || entry === null) {\n    return false;\n  }\n  if (typeof entry.command !== \"string\") {\n    return false;\n  }\n  entryarray.command = entry.command;\n\n  if (typeof entry.execute_after === \"undefined\" || entry.execute_after === null) {\n    entry.execute_after = new Date();\n  }\n  entryarray.execute_after = entry.execute_after;\n  /* force default state through this method */\n  entryarray.status = Queue.defaultStatus;\n\n\n  entryarray.priority = Queue.defaultPriority; /* default to mediocre default*/\n\n  if (typeof entry.priority === \"number\") {\n    entryarray.priority = entry.priority;\n  }\n\n  if (typeof entry.name === \"string\") {\n    entryarray.name = entry.name;\n  }\n\n  if (typeof entry.lock_name === \"string\") {\n    entryarray.lock_name = entry.lock_name;\n  }\n\n  if (typeof entry.execute_after === \"object\") {\n    entryarray.execute_after = entry.execute_after;\n  }\n\n  if (typeof entry.log_success === \"boolean\") {\n    entryarray.log_success = entry.log_success;\n  }\n\n  if (typeof entry.reattempt === \"number\") {\n    entryarray.reattempt = entry.reattempt;\n  }\n  entryarray.created_at = new Date();\n  entryarray.updated_at = new Date();\n\n  try {\n    res = Queue.entries.insert(entryarray);\n  } catch (e) {\n    /* lock errors are expected and should be logged only if verbose */\n    if (e.err !== 'undefined' && e.err.indexOf('E11000') === 0 &&\n        Queue.loglevel > 2) {\n      Queue.log.insert({command: 'Queue.add failed ' + entryarray.lock_name, status: 'lockfailed', data: e.err, created_at: new Date()});\n    } else if (Queue.loglevel > 0) {\n      /* otherwise include the whole stack */\n      Queue.log.insert({command: 'Queue.add failed ' + entryarray.lock_name, status: 'lockfailed', data: e, created_at: new Date()});\n    }\n  }\n  return res;\n};\n\n/* not much now, but might need to be complicated in the future */\nQueue.remove = function (entryId) {\n  return Queue.entries.remove({_id: entryId});\n};\n\n/* sets all found entries as 'locked'\n* @TODO by-priority \n*/\nQueue.get = function (args) {\n/* defaults status: pending,execute_after:now, */\n  var getstatus = \"pending\"; /* default retrieval status */\n  var execute_after = new Date();\n  /* do NOT use Queue.defaultStatus for getstatus, as you want to allow defaultStatus to serve an optional other purpose */\n  if (typeof args.execute_after !== \"undefined\" || args.execute_after === null) {\n    execute_after = args.execute_after;\n  }\n\n  if (typeof args.status === \"string\") {\n    getstatus = args.status;\n  }\n\n  return Queue.entries.findAndModify({execute_after: {$lte: execute_after}, status: getstatus}, {sort: {priority: 1}},\n    {$set: {status: 'locked'}}\n    );\n\n};\n\n/* just used for testing but will be helpful for \"blessed\" level*/\nQueue.changeStatus = function (id, status) {\n  var modified = Queue.entries.update({_id: id}, {$set: {status: status}});\n  if (modified === 1) {\n    return true;\n  }\n  return false;\n};\n\n/* @TODO: add some sanity checks */\nQueue.process = function (entry) {\n  var result = false;\n  var message = 'failed';\n  var history = null;\n  try {\n    result = new Function(entry.command)();\n  } catch (e) {\n    result = false;\n    message = e.err;\n  }\n  if (result !== false) {\n    if (entry.log_success ||  Queue.loglevel > 1) {\n      Queue.log.insert({command: entry.command, parent_id: entry._id, status: 'success', data: result, created_at: new Date()});\n    }\n    if (Queue.keepsuccess) {\n      if (typeof entry.history !== \"undefined\") {\n        history = entry.history + ' command returned true (' + new Date() + ');';\n      } else {\n        history = 'command returned true (' + new Date() + ');';\n      }\n      var modified = Queue.entries.update({_id: entry._id}, {$set: {status: 'completed', history: history, updated_at: new Date()}});\n      if (modified !== 1 && Queue.loglevel > 0) {\n        Queue.log.insert({command: 'update on succes', parent_id: entry._id, status: 'exception', data: 'unable to update entry', created_at: new Date()});\n      }\n    }\n    return true;\n  }\n\n  if (Queue.loglevel > 0) {\n    Queue.log.insert({command: entry.command, parent_id: entry._id, status: 'exception', data: message, created_at: new Date()});\n  }\n\n  if (entry.reattempt > 0) {\n    var execdate = new Date();\n    execdate.setMinutes(execdate.getMinutes() + entry.reattempt);\n    var reattemptmodified = Queue.entries.update({_id: entry._id}, {$set: {status: 'pending', execute_after: execdate}});\n    if (reattemptmodified !== 1 && Queue.loglevel > 0) {\n      Queue.log.insert({command: entry.command, parent_id: entry._id, status: 'exception', data: 'unable to requeue command', created_at: new Date()});\n    }\n  } else {\n    if (typeof entry.history !== \"undefined\") {\n      history = entry.history + ' command returned false (' + new Date() + ');';\n    } else {\n      history = ' command returned false (' + new Date() + ');';\n    }\n    var historymodified = Queue.entries.update({_id: entry._id}, {$set: {status: 'failed', history: history, updated_at: new Date()}});\n    if (historymodified !== 1 && Queue.loglevel > 0) {\n      Queue.log.insert({command: entry.command, parent_id: entry._id, status: 'exception', data: 'unable to requeue command', created_at: new Date()});\n    }\n  }\n  return false;\n};\n\n\nQueue.run = function (args) {\n  /* hacky locking with entry table */\n  if (typeof args === \"undefined\") {\n    args = [];\n  }\n  var entry = [];\n  var future = new Date();\n  var getargs = [];\n  future.setDate(future.getDate() + 600); /* put it out there so it doesn't execute */\n  entry.command = 'return true;';\n  entry.lock_name = 'query.run';\n  entry.execute_after = future;\n  var lock = Queue.add(entry);\n  if (lock === false) {\n    if (Queue.loglevel > 0) {\n      Queue.log.insert({command: 'Queue.run failed due to locking ' + entry.lock_name, status: 'lockfailed', created_at: new Date()});\n    }\n    return false;\n  }\n\n  /* lock obtained */\n  if (typeof args.execute_after === \"undefined\" || args.execute_after === null) {\n    args.execute_after = new Date();\n  }\n  getargs.execute_after = args.execute_after;\n  /* @TODO: add args for status and execute_after */\n  var all = Queue.get(getargs);\n  _.each(all, function (entry) {\n    Queue.process(entry);\n  });\n  /* lock */\n  Queue.remove(lock);\n  return true;\n};"]}