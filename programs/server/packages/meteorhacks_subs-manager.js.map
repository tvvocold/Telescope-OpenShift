{"version":3,"file":"/packages/meteorhacks:subs-manager.js","sources":["meteorhacks:subs-manager/lib/sub_manager.js"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;AAAA,kC;AACA,kB;AACA,+B;AACA,gD;AACA,0D;AACA,iD;AACA,qD;;AAEA,sB;AACA,uB;AACA,qB;AACA,mC;;AAEA,iD;AACA,E;;AAEA,8C;AACA,kB;AACA,uB;AACA,4B;;AAEA,Y;AACA,yB;AACA,0B;AACA,0B;AACA,O;AACA,M;AACA,U;AACA,6B;AACA,0B;AACA,uD;AACA,K;AACA,G;AACA,E;;AAEA,gD;AACA,kB;AACA,mC;AACA,6B;AACA,e;AACA,iB;AACA,gB;AACA,M;;AAEA,+B;AACA,8B;;AAEA,uB;AACA,wD;AACA,iC;AACA,kC;AACA,sC;AACA,S;AACA,Y;AACA,oC;AACA,K;AACA,G;;AAEA,+C;AACA,iC;AACA,qC;;AAEA,2C;AACA,mC;AACA,4B;AACA,E;;AAEA,sD;AACA,kB;AACA,kE;AACA,oB;AACA,0D;AACA,uC;AACA,sC;AACA,O;AACA,G;AACA,E;;AAEA,sD;AACA,kB;AACA,wB;;AAEA,gF;AACA,yC;AACA,uC;AACA,6B;AACA,Y;AACA,sC;AACA,K;AACA,K;;AAEA,iC;AACA,E;;AAEA,yD;AACA,kB;AACA,6C;AACA,6B;AACA,4B;;AAEA,qB;AACA,2C;AACA,mE;AACA,iC;AACA,O;;AAEA,e;AACA,wB;AACA,yB;AACA,K;AACA,K;;AAEA,qB;AACA,E;;AAEA,0C;AACA,kB;AACA,wC;AACA,iD;AACA,E;AACA,qE;AACA,gC;;AAEA,sE;AACA,mC;AACA,uE;AACA,8B;AACA,0B;AACA,K;AACA,E","sourcesContent":["SubsManager = function (options) {\n  var self = this;\n  self.options = options || {};\n  // maxiumum number of subscriptions are cached\n  self.options.cacheLimit = self.options.cacheLimit || 10;\n  // maximum time, subscription stay in the cache\n  self.options.expireIn = self.options.expireIn || 5;\n\n  self._cacheMap = {};\n  self._cacheList = [];\n  self.ready = false;\n  self.dep = new Deps.Dependency();\n\n  self.computation = self._registerComputation();\n};\n\nSubsManager.prototype.subscribe = function() {\n  var self = this;\n  if(Meteor.isClient) {\n    this._addSub(arguments);\n\n    return {\n      ready: function() {\n        self.dep.depend();\n        return self.ready;\n      }\n    };\n  } else {\n    // to support fast-render\n    if(Meteor.subscribe) {\n      return Meteor.subscribe.apply(Meteor, arguments);\n    }\n  }\n};\n\nSubsManager.prototype._addSub = function(args) {\n  var self = this;\n  var hash = EJSON.stringify(args);\n  if(!self._cacheMap[hash]) {\n    var sub = {\n      args: args,\n      hash: hash\n    };\n\n    self._cacheMap[hash] = sub;\n    self._cacheList.push(sub);\n\n    self.ready = false;\n    // no need to interfere with the current computation\n    if(Deps.currentComputation) {\n      Deps.afterFlush(function() {\n        self.computation.invalidate();\n      });\n    } else {\n      self.computation.invalidate();\n    }\n  }\n\n  // add the current sub to the top of the list\n  var sub = self._cacheMap[hash];\n  sub.updated = (new Date).getTime();\n\n  var index = self._cacheList.indexOf(sub);\n  self._cacheList.splice(index, 1);\n  self._cacheList.push(sub);\n};\n\nSubsManager.prototype._applyCacheLimit = function () {\n  var self = this;\n  var overflow = self._cacheList.length - self.options.cacheLimit;\n  if(overflow > 0) {\n    var removedSubs = self._cacheList.splice(0, overflow);\n    _.each(removedSubs, function(sub) {\n      delete self._cacheMap[sub.hash];\n    });\n  }\n};\n\nSubsManager.prototype._applyExpirations = function() {\n  var self = this;\n  var newCacheList = [];\n\n  var expirationTime = (new Date).getTime() - self.options.expireIn * 60 * 1000;\n  _.each(self._cacheList, function(sub) {\n    if(sub.updated >= expirationTime) {\n      newCacheList.push(sub);\n    } else {\n      delete self._cacheMap[sub.hash];\n    }\n  });\n\n  self._cacheList = newCacheList;\n};\n\nSubsManager.prototype._registerComputation = function() {\n  var self = this;\n  var computation = Deps.autorun(function() {\n    self._applyExpirations();\n    self._applyCacheLimit();\n\n    var ready = true;\n    _.each(self._cacheList, function(sub) {\n      sub.ready = Meteor.subscribe.apply(Meteor, sub.args).ready();\n      ready = ready && sub.ready;\n    });\n\n    if(ready) {\n      self.ready = true;\n      self.dep.changed();\n    }\n  });\n\n  return computation;\n};\n\nSubsManager.prototype.reset = function() {\n  var self = this;\n  var oldComputation = self.computation;\n  self.computation = self._registerComputation();\n  \n  // invalidate the new compuation and it will fire new subscriptions\n  self.computation.invalidate();\n\n  // after above invalidation completed, fire stop the old computation\n  // which then send unsub messages\n  // mergeBox will correct send changed data and there'll be no flicker\n  Deps.afterFlush(function() {\n    oldComputation.stop();\n  });\n};"]}