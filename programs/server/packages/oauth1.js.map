{"version":3,"sources":["oauth1/oauth1_binding.js","oauth1/oauth1_server.js","oauth1/oauth1_pending_request_tokens.js"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;AAAA,mC;AACA,6C;AACA,mC;;AAEA,iE;AACA,6B;AACA,E;AACA,yB;AACA,+C;AACA,6C;AACA,uB;AACA,iC;AACA,8B;AACA,gC;AACA,iC;AACA,wC;AACA,wB;AACA,oB;AACA,E;;AAEA,qE;AACA,kB;;AAEA,mC;AACA,+B;AACA,K;;AAEA,sE;AACA,mD;;AAEA,wC;AACA,4F;AACA,mD;;AAEA,yC;AACA,sD;AACA,E;;AAEA,kF;AACA,kB;;AAEA,oE;AACA,wB;AACA,I;AACA,qE;AACA,mE;AACA,mC;AACA,yB;AACA,gD;;AAEA,mC;AACA,mC;AACA,wC;AACA,K;;AAEA,qE;AACA,mD;;AAEA,4D;AACA,2D;AACA,2F;AACA,8D;AACA,4C;AACA,K;AACA,gB;AACA,G;;AAEA,wC;AACA,qD;AACA,E;;AAEA,wE;AACA,kB;;AAEA,mC;AACA,iC;AACA,K;;AAEA,gB;AACA,gB;AACA,G;;AAEA,4D;AACA,E;;AAEA,+D;AACA,iD;AACA,E;;AAEA,gE;AACA,kD;AACA,E;;AAEA,0D;AACA,kB;AACA,mB;AACA,iD;AACA,oD;AACA,wC;AACA,sE;AACA,wB;AACA,c;AACA,E;;AAEA,sG;AACA,kB;AACA,iE;;AAEA,sD;AACA,2B;AACA,sB;;AAEA,uB;AACA,W;AACA,4B;AACA,kC;AACA,c;;AAEA,qD;;AAEA,oD;AACA,wB;AACA,wD;;AAEA,sF;AACA,E;;AAEA,kF;AACA,kB;;AAEA,iE;AACA,iC;AACA,oB;AACA,G;;AAEA,0B;AACA,wB;;AAEA,8D;AACA,6C;AACA,6E;AACA,iD;;AAEA,iE;AACA,6B;AACA,uB;AACA,wB;AACA,oC;;AAEA,sB;AACA,2B;AACA,6E;;AAEA,yD;AACA,sD;;AAEA,wB;AACA,O;AACA,2C;AACA,qB;AACA,gB;AACA,iC;AACA,O;AACA,+C;AACA,oB;AACA,6C;AACA,O;AACA,gC;AACA,O;AACA,mD;AACA,iB;AACA,2C;AACA,oB;AACA,iB;AACA,6F;AACA,6C;AACA,G;AACA,E;;AAEA,0D;AACA,kB;AACA,oD;AACA,4D;AACA,gB;AACA,S;AACA,E;;AAEA,uD;AACA,kF;AACA,E;;AAEA,kE;AACA,kB;AACA,wD;AACA,0E;AACA,uB;AACA,E;;;;;;;;;;;;;;;;;;;ACpMA,6B;;AAEA,qB;AACA,8D;AACA,2F;AACA,iB;AACA,oE;AACA,G;;AAEA,0B;AACA,qD;;AAEA,uB;;AAEA,sC;AACA,6C;AACA,uE;AACA,yB;AACA,0C;AACA,yC;AACA,O;;AAEA,gD;AACA,kD;;AAEA,uE;AACA,6B;AACA,6C;AACA,gC;AACA,uC;;AAEA,wC;AACA,gC;AACA,iD;AACA,qD;AACA,oB;AACA,S;AACA,Y;AACA,kF;AACA,8D;AACA,wD;AACA,mE;AACA,iC;AACA,wF;AACA,+C;AACA,K;;AAEA,6E;;AAEA,kD;AACA,c;AACA,U;AACA,gE;AACA,iE;;AAEA,oE;AACA,uD;AACA,8C;;AAEA,6B;AACA,0D;AACA,K;;AAEA,gE;AACA,0C;AACA,mF;;AAEA,kE;AACA,iE;;AAEA,kD;AACA,kF;;AAEA,sC;AACA,mD;AACA,wC;;AAEA,mE;AACA,yC;;AAEA,iE;AACA,0C;AACA,sD;AACA,yC;AACA,6C;AACA,oC;AACA,2B;AACA,K;;AAEA,2D;AACA,wB;AACA,4D;AACA,G;AACA,E;;;;;;;;;;;;;;;;;;;AC7FA,E;AACA,mE;AACA,4C;AACA,E;AACA,gE;AACA,kE;AACA,2D;AACA,4D;AACA,+D;AACA,E;AACA,+D;AACA,gE;AACA,iE;AACA,E;AACA,wE;AACA,mD;AACA,E;AACA,qE;AACA,qC;;AAEA,+C;AACA,mE;AACA,mD;AACA,wC;AACA,6B;AACA,K;;AAEA,6D;AACA,sD;;;;AAIA,0D;AACA,qC;AACA,8C;AACA,8B;AACA,qD;AACA,yE;AACA,E;AACA,uE;;;AAGA,4E;AACA,oD;AACA,E;AACA,sB;AACA,+B;AACA,qC;AACA,E;AACA,6E;AACA,qB;;AAEA,uE;AACA,qE;AACA,gD;AACA,sC;AACA,Y;AACA,M;AACA,a;AACA,iD;AACA,6D;AACA,yB;AACA,K;AACA,E;;;AAGA,kF;AACA,8E;AACA,E;AACA,sB;AACA,E;AACA,8C;AACA,qB;;AAEA,8E;AACA,4B;AACA,yE;AACA,Y;AACA,uE;AACA,2C;AACA,+C;AACA,M;AACA,U;AACA,qB;AACA,G;AACA,E","file":"/packages/oauth1.js","sourcesContent":["var crypto = Npm.require(\"crypto\");\nvar querystring = Npm.require(\"querystring\");\nvar urlModule = Npm.require(\"url\");\n\n// An OAuth1 wrapper around http calls which helps get tokens and\n// takes care of HTTP headers\n//\n// @param config {Object}\n//   - consumerKey (String): oauth consumer key\n//   - secret (String): oauth consumer secret\n// @param urls {Object}\n//   - requestToken (String): url\n//   - authorize (String): url\n//   - accessToken (String): url\n//   - authenticate (String): url\nOAuth1Binding = function(config, urls) {\n  this._config = config;\n  this._urls = urls;\n};\n\nOAuth1Binding.prototype.prepareRequestToken = function(callbackUrl) {\n  var self = this;\n\n  var headers = self._buildHeader({\n    oauth_callback: callbackUrl\n  });\n\n  var response = self._call('POST', self._urls.requestToken, headers);\n  var tokens = querystring.parse(response.content);\n\n  if (! tokens.oauth_callback_confirmed)\n    throw _.extend(new Error(\"oauth_callback_confirmed false when requesting oauth1 token\"),\n                             {response: response});\n\n  self.requestToken = tokens.oauth_token;\n  self.requestTokenSecret = tokens.oauth_token_secret;\n};\n\nOAuth1Binding.prototype.prepareAccessToken = function(query, requestTokenSecret) {\n  var self = this;\n\n  // support implementations that use request token secrets. This is\n  // read by self._call.\n  //\n  // XXX make it a param to call, not something stashed on self? It's\n  // kinda confusing right now, everything except this is passed as\n  // arguments, but this is stored.\n  if (requestTokenSecret)\n    self.accessTokenSecret = requestTokenSecret;\n\n  var headers = self._buildHeader({\n    oauth_token: query.oauth_token,\n    oauth_verifier: query.oauth_verifier\n  });\n\n  var response = self._call('POST', self._urls.accessToken, headers);\n  var tokens = querystring.parse(response.content);\n\n  if (! tokens.oauth_token || ! tokens.oauth_token_secret) {\n    var error = new Error(\"missing oauth token or secret\");\n    // We provide response only if no token is available, we do not want to leak any tokens\n    if (! tokens.oauth_token && ! tokens.oauth_token_secret) {\n      _.extend(error, {response: response});\n    }\n    throw error;\n  }\n\n  self.accessToken = tokens.oauth_token;\n  self.accessTokenSecret = tokens.oauth_token_secret;\n};\n\nOAuth1Binding.prototype.call = function(method, url, params, callback) {\n  var self = this;\n\n  var headers = self._buildHeader({\n    oauth_token: self.accessToken\n  });\n\n  if(! params) {\n    params = {};\n  }\n\n  return self._call(method, url, headers, params, callback);\n};\n\nOAuth1Binding.prototype.get = function(url, params, callback) {\n  return this.call('GET', url, params, callback);\n};\n\nOAuth1Binding.prototype.post = function(url, params, callback) {\n  return this.call('POST', url, params, callback);\n};\n\nOAuth1Binding.prototype._buildHeader = function(headers) {\n  var self = this;\n  return _.extend({\n    oauth_consumer_key: self._config.consumerKey,\n    oauth_nonce: Random.secret().replace(/\\W/g, ''),\n    oauth_signature_method: 'HMAC-SHA1',\n    oauth_timestamp: (new Date().valueOf()/1000).toFixed().toString(),\n    oauth_version: '1.0'\n  }, headers);\n};\n\nOAuth1Binding.prototype._getSignature = function(method, url, rawHeaders, accessTokenSecret, params) {\n  var self = this;\n  var headers = self._encodeHeader(_.extend(rawHeaders, params));\n\n  var parameters = _.map(headers, function(val, key) {\n    return key + '=' + val;\n  }).sort().join('&');\n\n  var signatureBase = [\n    method,\n    self._encodeString(url),\n    self._encodeString(parameters)\n  ].join('&');\n\n  var secret = OAuth.openSecret(self._config.secret);\n\n  var signingKey = self._encodeString(secret) + '&';\n  if (accessTokenSecret)\n    signingKey += self._encodeString(accessTokenSecret);\n\n  return crypto.createHmac('SHA1', signingKey).update(signatureBase).digest('base64');\n};\n\nOAuth1Binding.prototype._call = function(method, url, headers, params, callback) {\n  var self = this;\n\n  // all URLs to be functions to support parameters/customization\n  if(typeof url === \"function\") {\n    url = url(self);\n  }\n\n  headers = headers || {};\n  params = params || {};\n\n  // Extract all query string parameters from the provided URL\n  var parsedUrl = urlModule.parse(url, true);\n  // Merge them in a way that params given to the method call have precedence\n  params = _.extend({}, parsedUrl.query, params);\n\n  // Reconstruct the URL back without any query string parameters\n  // (they are now in params)\n  parsedUrl.query = {};\n  parsedUrl.search = '';\n  url = urlModule.format(parsedUrl);\n\n  // Get the signature\n  headers.oauth_signature =\n    self._getSignature(method, url, headers, self.accessTokenSecret, params);\n\n  // Make a authorization string according to oauth1 spec\n  var authString = self._getAuthHeaderString(headers);\n\n  // Make signed request\n  try {\n    var response = HTTP.call(method, url, {\n      params: params,\n      headers: {\n        Authorization: authString\n      }\n    }, callback && function (error, response) {\n      if (! error) {\n        response.nonce = headers.oauth_nonce;\n      }\n      callback(error, response);\n    });\n    // We store nonce so that JWTs can be validated\n    if (response)\n      response.nonce = headers.oauth_nonce;\n    return response;\n  } catch (err) {\n    throw _.extend(new Error(\"Failed to send OAuth1 request to \" + url + \". \" + err.message),\n                   {response: err.response});\n  }\n};\n\nOAuth1Binding.prototype._encodeHeader = function(header) {\n  var self = this;\n  return _.reduce(header, function(memo, val, key) {\n    memo[self._encodeString(key)] = self._encodeString(val);\n    return memo;\n  }, {});\n};\n\nOAuth1Binding.prototype._encodeString = function(str) {\n  return encodeURIComponent(str).replace(/[!'()]/g, escape).replace(/\\*/g, \"%2A\");\n};\n\nOAuth1Binding.prototype._getAuthHeaderString = function(headers) {\n  var self = this;\n  return 'OAuth ' +  _.map(headers, function(val, key) {\n    return self._encodeString(key) + '=\"' + self._encodeString(val) + '\"';\n  }).sort().join(', ');\n};\n","var url = Npm.require(\"url\");\n\n// connect middleware\nOAuth._requestHandlers['1'] = function (service, query, res) {\n  var config = ServiceConfiguration.configurations.findOne({service: service.serviceName});\n  if (! config) {\n    throw new ServiceConfiguration.ConfigError(service.serviceName);\n  }\n\n  var urls = service.urls;\n  var oauthBinding = new OAuth1Binding(config, urls);\n\n  var credentialSecret;\n\n  if (query.requestTokenAndRedirect) {\n    // step 1 - get and store a request token\n    var callbackUrl = OAuth._redirectUri(service.serviceName, config, {\n      state: query.state,\n      cordova: (query.cordova === \"true\"),\n      android: (query.android === \"true\")\n    });\n\n    // Get a request token to start auth process\n    oauthBinding.prepareRequestToken(callbackUrl);\n\n    // Keep track of request token so we can verify it on the next step\n    OAuth._storeRequestToken(\n      OAuth._credentialTokenFromQuery(query),\n      oauthBinding.requestToken,\n      oauthBinding.requestTokenSecret);\n\n    // support for scope/name parameters\n    var redirectUrl = undefined;\n    if(typeof urls.authenticate === \"function\") {\n      redirectUrl = urls.authenticate(oauthBinding, {\n        query: query\n      });\n    } else {\n      // Parse the URL to support additional query parameters in urls.authenticate\n      var redirectUrlObj = url.parse(urls.authenticate, true);\n      redirectUrlObj.query = redirectUrlObj.query || {};\n      redirectUrlObj.query.oauth_token = oauthBinding.requestToken;\n      redirectUrlObj.search = '';\n      // Reconstruct the URL back with provided query parameters merged with oauth_token\n      redirectUrl = url.format(redirectUrlObj);\n    }\n\n    // redirect to provider login, which will redirect back to \"step 2\" below\n\n    res.writeHead(302, {'Location': redirectUrl});\n    res.end();\n  } else {\n    // step 2, redirected from provider login - store the result\n    // and close the window to allow the login handler to proceed\n\n    // Get the user's request token so we can verify it and clear it\n    var requestTokenInfo = OAuth._retrieveRequestToken(\n      OAuth._credentialTokenFromQuery(query));\n\n    if (! requestTokenInfo) {\n      throw new Error(\"Unable to retrieve request token\");\n    }\n\n    // Verify user authorized access and the oauth_token matches\n    // the requestToken from previous step\n    if (query.oauth_token && query.oauth_token === requestTokenInfo.requestToken) {\n\n      // Prepare the login results before returning.  This way the\n      // subsequent call to the `login` method will be immediate.\n\n      // Get the access token for signing requests\n      oauthBinding.prepareAccessToken(query, requestTokenInfo.requestTokenSecret);\n\n      // Run service-specific handler.\n      var oauthResult = service.handleOauthRequest(\n        oauthBinding, { query: query });\n\n      var credentialToken = OAuth._credentialTokenFromQuery(query);\n      credentialSecret = Random.secret();\n\n      // Store the login result so it can be retrieved in another\n      // browser tab by the result handler\n      OAuth._storePendingCredential(credentialToken, {\n        serviceName: service.serviceName,\n        serviceData: oauthResult.serviceData,\n        options: oauthResult.options\n      }, credentialSecret);\n    }\n\n    // Either close the window, redirect, or render nothing\n    // if all else fails\n    OAuth._renderOauthResults(res, query, credentialSecret);\n  }\n};\n","//\n// _pendingRequestTokens are request tokens that have been received\n// but not yet fully authorized (processed).\n//\n// During the oauth1 authorization process, the Meteor App opens\n// a pop-up, requests a request token from the oauth1 service, and\n// redirects the browser to the oauth1 service for the user\n// to grant authorization.  The user is then returned to the\n// Meteor Apps' callback url and the request token is verified.\n//\n// When Meteor Apps run on multiple servers, it's possible that\n// 2 different servers may be used to generate the request token\n// and to verify it in the callback once the user has authorized.\n//\n// For this reason, the _pendingRequestTokens are stored in the database\n// so they can be shared across Meteor App servers.\n//\n// XXX This code is fairly similar to oauth/pending_credentials.js --\n// maybe we can combine them somehow.\n\n// Collection containing pending request tokens\n// Has key, requestToken, requestTokenSecret, and createdAt fields.\nOAuth._pendingRequestTokens = new Mongo.Collection(\n  \"meteor_oauth_pendingRequestTokens\", {\n    _preventAutopublish: true\n  });\n\nOAuth._pendingRequestTokens._ensureIndex('key', {unique: 1});\nOAuth._pendingRequestTokens._ensureIndex('createdAt');\n\n\n\n// Periodically clear old entries that never got completed\nvar _cleanStaleResults = function() {\n  // Remove request tokens older than 5 minute\n  var timeCutoff = new Date();\n  timeCutoff.setMinutes(timeCutoff.getMinutes() - 5);\n  OAuth._pendingRequestTokens.remove({ createdAt: { $lt: timeCutoff } });\n};\nvar _cleanupHandle = Meteor.setInterval(_cleanStaleResults, 60 * 1000);\n\n\n// Stores the key and request token in the _pendingRequestTokens collection.\n// Will throw an exception if `key` is not a string.\n//\n// @param key {string}\n// @param requestToken {string}\n// @param requestTokenSecret {string}\n//\nOAuth._storeRequestToken = function (key, requestToken, requestTokenSecret) {\n  check(key, String);\n\n  // We do an upsert here instead of an insert in case the user happens\n  // to somehow send the same `state` parameter twice during an OAuth\n  // login; we don't want a duplicate key error.\n  OAuth._pendingRequestTokens.upsert({\n    key: key\n  }, {\n    key: key,\n    requestToken: OAuth.sealSecret(requestToken),\n    requestTokenSecret: OAuth.sealSecret(requestTokenSecret),\n    createdAt: new Date()\n  });\n};\n\n\n// Retrieves and removes a request token from the _pendingRequestTokens collection\n// Returns an object containing requestToken and requestTokenSecret properties\n//\n// @param key {string}\n//\nOAuth._retrieveRequestToken = function (key) {\n  check(key, String);\n\n  var pendingRequestToken = OAuth._pendingRequestTokens.findOne({ key: key });\n  if (pendingRequestToken) {\n    OAuth._pendingRequestTokens.remove({ _id: pendingRequestToken._id });\n    return {\n      requestToken: OAuth.openSecret(pendingRequestToken.requestToken),\n      requestTokenSecret: OAuth.openSecret(\n        pendingRequestToken.requestTokenSecret)\n    };\n  } else {\n    return undefined;\n  }\n};\n"]}