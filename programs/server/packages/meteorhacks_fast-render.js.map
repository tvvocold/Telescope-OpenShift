{"version":3,"sources":["meteorhacks:fast-render/lib/utils.js","meteorhacks:fast-render/lib/server/utils.js","meteorhacks:fast-render/lib/server/fast_render.js","meteorhacks:fast-render/lib/server/publish_context.js","meteorhacks:fast-render/lib/server/context.js","meteorhacks:fast-render/lib/server/inject.js","meteorhacks:fast-render/lib/server/iron_router_support.js"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA,+B;AACA,2C;AACA,gC;AACA,E;;AAEA,sC;AACA,mD;AACA,6D;AACA,E;;AAEA,6C;AACA,wB;AACA,qB;AACA,oC;;AAEA,0C;AACA,sB;AACA,mD;AACA,gC;AACA,O;AACA,K;AACA,K;AACA,E;;AAEA,wC;AACA,kD;AACA,8B;AACA,iD;AACA,0B;AACA,O;AACA,uC;AACA,iD;AACA,0B;AACA,O;AACA,2C;AACA,yB;AACA,O;AACA,uC;AACA,kB;AACA,G;;AAEA,gB;AACA,E;;AAEA,oD;AACA,oD;AACA,wC;AACA,gC;AACA,oC;AACA,uD;AACA,C;AACA,qD;AACA,8B;AACA,8C;AACA,sH;AACA,mC;AACA,S;AACA,2E;AACA,sC;AACA,kE;AACA,W;AACA,S;AACA,kE;AACA,iE;AACA,sF;AACA,kB;AACA,iH;AACA,W;AACA,S;AACA,oE;AACA,mE;AACA,wF;AACA,kB;AACA,4D;AACA,W;AACA,gB;AACA,mC;AACA,S;AACA,O;AACA,K;AACA,K;AACA,a;AACA,E;;;;;;;;;;;;;;;;;;AClFA,E;AACA,2C;AACA,kD;AACA,E;;AAEA,W;;AAEA,yE;AACA,4D;AACA,6D;AACA,a;AACA,4B;AACA,+B;AACA,6B;AACA,wB;AACA,a;AACA,6C;AACA,2D;AACA,sD;AACA,0B;AACA,e;AACA,iC;AACA,e;AACA,iC;AACA,wB;AACA,kE;AACA,2B;AACA,M;AACA,gC;AACA,4B;AACA,4D;AACA,E;;AAEA,mD;AACA,uB;;AAEA,kB;AACA,iC;AACA,0B;AACA,iC;;AAEA,mB;AACA,2D;AACA,0C;AACA,gE;AACA,O;AACA,G;;AAEA,uB;AACA,kC;;AAEA,uB;;AAEA,iD;AACA,0B;;AAEA,S;AACA,uC;AACA,kC;AACA,e;AACA,gB;AACA,mE;AACA,uB;AACA,gB;AACA,K;;AAEA,c;AACA,6B;AACA,Y;AACA,uB;AACA,K;AACA,G;AACA,E;AACA,gB;AACA,E;;;;;;;;;;;;;;;;;;;AC1EA,kC;;AAEA,c;AACA,c;AACA,kB;AACA,E;;AAEA,mD;AACA,gB;AACA,2B;AACA,wD;AACA,uB;AACA,c;AACA,K;AACA,E;;AAEA,yD;AACA,yC;AACA,E;;AAEA,0F;AACA,uC;AACA,oB;AACA,a;;AAEA,qD;AACA,uC;AACA,2C;AACA,gB;AACA,4B;AACA,Y;AACA,K;AACA,G;;AAEA,oB;AACA,gE;AACA,S;;AAEA,6C;AACA,0D;AACA,qC;AACA,S;;AAEA,yB;AACA,2D;AACA,O;;AAEA,kC;AACA,kB;AACA,wF;AACA,qB;AACA,K;AACA,W;AACA,E;;AAEA,uC;AACA,mC;AACA,qB;AACA,sE;AACA,E;AACA,oC;AACA,mD;AACA,6D;AACA,sB;AACA,yE;AACA,O;AACA,G;AACA,G;;;;;;;;;;;;;;;;;;ACnEA,iE;AACA,+B;AACA,+B;AACA,oC;AACA,0B;AACA,4B;AACA,oB;AACA,wB;;AAEA,sB;AACA,qB;AACA,uB;AACA,yB;AACA,2B;AACA,6C;AACA,+B;AACA,gC;AACA,I;;AAEA,gE;AACA,wD;AACA,E;;AAEA,mE;AACA,0C;AACA,0C;;AAEA,oD;AACA,gD;AACA,qF;AACA,G;AACA,E;;AAEA,mE;AACA,qC;AACA,4B;AACA,e;AACA,6C;AACA,E;;AAEA,qE;AACA,4C;;AAEA,6E;AACA,yB;AACA,mC;AACA,K;;AAEA,e;AACA,K;AACA,E;;AAEA,6D;AACA,4C;;AAEA,gF;AACA,0B;AACA,K;AACA,E;;AAEA,gD;AACA,sB;AACA,S;AACA,U;AACA,0B;AACA,G;AACA,E;;AAEA,6C;AACA,uB;;AAEA,4C;AACA,0B;AACA,0C;AACA,4D;AACA,G;;AAEA,sD;AACA,qC;AACA,S;AACA,K;AACA,E;;AAEA,+C;AACA,8C;;;;;;;;;;;;;;;;;;ACpFA,mC;AACA,0C;;AAEA,qD;AACA,4B;AACA,2B;AACA,iC;AACA,gC;AACA,E;AACA,8B;;AAEA,iB;AACA,wB;AACA,iD;AACA,uD;AACA,oB;AACA,6E;AACA,6E;AACA,uC;AACA,sD;AACA,K;;AAEA,6B;AACA,yC;AACA,wE;;AAEA,c;AACA,6B;AACA,K;AACA,G;AACA,E;;AAEA,oE;AACA,kB;AACA,E;AACA,4E;AACA,sB;AACA,gE;AACA,0D;;AAEA,oE;AACA,U;AACA,0E;AACA,G;AACA,E;;AAEA,yF;AACA,kB;AACA,E;AACA,0B;AACA,yC;AACA,6D;AACA,oC;AACA,8B;AACA,sB;AACA,K;AACA,K;;AAEA,O;AACA,+D;AACA,e;AACA,kG;AACA,oE;AACA,6F;AACA,wE;AACA,qG;AACA,2B;AACA,G;;AAEA,e;AACA,4C;AACA,sC;AACA,0B;AACA,K;;AAEA,yB;AACA,sC;AACA,sB;AACA,2B;AACA,+G;AACA,qF;;AAEA,6C;AACA,gE;AACA,O;;AAEA,+B;AACA,2B;AACA,+B;AACA,8E;AACA,0E;AACA,8C;AACA,2B;AACA,G;;AAEA,6B;AACA,oD;AACA,kC;AACA,iC;AACA,6D;AACA,kG;AACA,wB;AACA,O;AACA,mF;AACA,G;AACA,E;;AAEA,mE;AACA,kB;AACA,wC;AACA,oC;AACA,mE;AACA,0F;AACA,G;;AAEA,gD;AACA,6C;AACA,K;AACA,E;;AAEA,gE;AACA,6C;AACA,8C;AACA,G;AACA,E;;AAEA,wC;AACA,mD;AACA,sD;AACA,kB;AACA,K;;AAEA,U;AACA,yC;AACA,uC;AACA,gC;AACA,I;AACA,E;;AAEA,8B;;;;;;;;;;;;;;;;;;AC3IA,yE;AACA,0B;AACA,mC;AACA,uC;;AAEA,+B;;AAEA,uB;AACA,mE;AACA,W;AACA,+E;AACA,U;AACA,iD;AACA,G;AACA,G;;AAEA,yD;AACA,kE;AACA,yC;AACA,wC;AACA,8D;;AAEA,0E;AACA,mE;AACA,qC;AACA,sD;AACA,uB;AACA,4F;AACA,gC;AACA,gD;AACA,a;AACA,K;;AAEA,iB;AACA,4B;AACA,qB;AACA,oD;AACA,4C;AACA,6C;AACA,O;AACA,sC;AACA,wD;AACA,iE;AACA,Y;AACA,2D;AACA,K;;AAEA,yB;AACA,G;;AAEA,4C;AACA,E;;AAEA,2E;AACA,4C;AACA,sB;AACA,sD;AACA,iB;;AAEA,kE;AACA,kE;AACA,oE;AACA,oE;AACA,8D;AACA,kD;AACA,8B;AACA,iB;;AAEA,iE;AACA,O;AACA,sE;AACA,qD;AACA,kC;AACA,wE;AACA,mB;AACA,e;AACA,4B;AACA,iB;AACA,G;;AAEA,wD;AACA,c;AACA,E;;AAEA,4B;AACA,kE;AACA,qD;AACA,uB;AACA,uD;AACA,qF;AACA,gC;AACA,yB;AACA,+D;AACA,mE;AACA,yD;AACA,sE;AACA,O;AACA,a;AACA,O;AACA,qD;AACA,U;AACA,W;AACA,G;AACA,G;;;;;;;;;;;;;;;;;;;ACvGA,mC;;AAEA,6D;AACA,2C;;AAEA,8B;AACA,2C;AACA,uC;AACA,E;;AAEA,2C;AACA,2B;AACA,mD;AACA,wC;AACA,gC;AACA,G;;AAEA,0B;AACA,yC;AACA,wC;AACA,kC;AACA,yB;AACA,c;AACA,gC;AACA,0C;AACA,iD;AACA,O;AACA,yB;AACA,K;AACA,K;;AAEA,2B;AACA,yB;AACA,kG;AACA,yD;AACA,sC;AACA,O;AACA,G;AACA,E;AACA,yC;AACA,oB;AACA,I;AACA,8B;AACA,4C;AACA,gC;AACA,O;AACA,I;AACA,iD;AACA,uC;AACA,O;AACA,K;AACA,E;;AAEA,6B;AACA,iC;AACA,E;AACA,+D;AACA,0D;AACA,0C;AACA,sC;AACA,0C;AACA,0C;AACA,sC;AACA,uC;AACA,2C;AACA,S;AACA,S;AACA,K;AACA,K;;AAEA,4C;;AAEA,kC;AACA,oB;AACA,mB;AACA,qB;AACA,gB;AACA,M;;AAEA,0B;AACA,8B;AACA,kD;AACA,yB;AACA,O;;AAEA,yE;AACA,gD;AACA,0C;AACA,4C;AACA,kE;AACA,qB;AACA,qE;AACA,kD;AACA,2C;AACA,uC;;AAEA,gE;AACA,4C;AACA,kE;AACA,W;AACA,W;AACA,c;AACA,iB;AACA,+C;AACA,4C;AACA,iD;AACA,oB;AACA,+B;AACA,S;AACA,O;AACA,K;;AAEA,iD;AACA,uC;AACA,O;AACA,G;AACA,C;;AAEA,yB;AACA,mB;AACA,iB;AACA,uB;AACA,U;AACA,iB;AACA,8C;AACA,8C;AACA,G;AACA,C;;AAEA,+B;AACA,uC;AACA,iB;AACA,6C;AACA,mC;AACA,iB;AACA,kC;AACA,U;AACA,gC;AACA,gB;AACA,G;AACA,C","file":"/packages/meteorhacks:fast-render.js","sourcesContent":["EncodeEJSON = function(ejson) {\n  var ejsonString = EJSON.stringify(ejson);\n  return encodeURI(ejsonString);\n};\n\nDecodeEJSON = function(encodedEjson) {\n  var decodedEjsonString = decodeURI(encodedEjson);\n  return EJSON.fromJSONValue(JSON.parse(decodedEjsonString));\n};\n\nAddedToChanged = function(localCopy, added) {\n  added.msg = \"changed\";\n  added.cleared = [];\n  added.fields = added.fields || {};\n\n  _.each(localCopy, function(value, key) {\n    if(key != '_id') {\n      if(typeof added.fields[key] == \"undefined\") {\n        added.cleared.push(key);\n      }\n    }\n  });\n};\n\nApplyDDP = function(existing, message) {\n  var newDoc = (!existing)? {}: _.clone(existing);\n  if(message.msg == 'added') {\n    _.each(message.fields, function(value, key) {\n      newDoc[key] = value;\n    });\n  } else if(message.msg == \"changed\") {\n    _.each(message.fields, function(value, key) {\n      newDoc[key] = value;\n    });\n    _.each(message.cleared, function(key) {\n      delete newDoc[key];\n    });\n  } else if(message.msg == \"removed\") {\n    newDoc = null;\n  }\n\n  return newDoc;\n};\n\n// source: https://gist.github.com/kurtmilam/1868955\n//  modified a bit to not to expose this as an _ api\nDeepExtend = function deepExtend (obj) {\n  var parentRE = /#{\\s*?_\\s*?}/,\n      slice = Array.prototype.slice,\n      hasOwnProperty = Object.prototype.hasOwnProperty;\n \n  _.each(slice.call(arguments, 1), function(source) {\n    for (var prop in source) {\n      if (hasOwnProperty.call(source, prop)) {\n        if (_.isUndefined(obj[prop]) || _.isFunction(obj[prop]) || _.isNull(source[prop]) || _.isDate(source[prop])) {\n          obj[prop] = source[prop];\n        }\n        else if (_.isString(source[prop]) && parentRE.test(source[prop])) {\n          if (_.isString(obj[prop])) {\n            obj[prop] = source[prop].replace(parentRE, obj[prop]);\n          }\n        }\n        else if (_.isArray(obj[prop]) || _.isArray(source[prop])){\n          if (!_.isArray(obj[prop]) || !_.isArray(source[prop])){\n            throw 'Error: Trying to combine an array with a non-array (' + prop + ')';\n          } else {\n            obj[prop] = _.reject(DeepExtend(obj[prop], source[prop]), function (item) { return _.isNull(item);});\n          }\n        }\n        else if (_.isObject(obj[prop]) || _.isObject(source[prop])){\n          if (!_.isObject(obj[prop]) || !_.isObject(source[prop])){\n            throw 'Error: Trying to combine an object with a non-object (' + prop + ')';\n          } else {\n            obj[prop] = DeepExtend(obj[prop], source[prop]);\n          }\n        } else {\n          obj[prop] = source[prop];\n        }\n      }\n    }\n  });\n  return obj;\n};","/*\n  stolen from express: http://goo.gl/qgarJu\n  some parts has been changed to deal with our api\n*/\n\nUtils = {};\n\nUtils._pathRegexp = function _pathRegexp(path, keys, sensitive, strict) {\n  if (toString.call(path) == '[object RegExp]') return path;\n  if (Array.isArray(path)) path = '(' + path.join('|') + ')';\n  path = path\n    .replace(/(.)\\/$/, '$1')\n    .concat(strict ? '' : '/?')\n    .replace(/\\/\\(/g, '(?:/')\n    .replace(/#/, '/?#')\n    .replace(\n      /(\\/)?(\\.)?:(\\w+)(?:(\\(.*?\\)))?(\\?)?/g,\n    function(match, slash, format, key, capture, optional){\n      keys.push({ name: key, optional: !! optional });\n      slash = slash || '';\n      return ''\n        + (optional ? '' : slash)\n        + '(?:'\n        + (optional ? slash : '')\n        + (format || '')\n        + (capture || (format && '([^/.]+?)' || '([^/]+?)')) + ')'\n        + (optional || '');\n    })\n    .replace(/([\\/.])/g, '\\\\$1')\n    .replace(/\\*/g, '(.*)');\n  return new RegExp('^' + path + '$', sensitive ? '' : 'i');\n};\n\nUtils._pathMatch = function _pathMatch(uri, route){\n  uri = decodeURI(uri);\n\n  var params = [];\n  var uriParts2 = uri.split('?');\n  var path = uriParts2[0];\n  var queryString = uriParts2[1];\n\n  if(queryString) {\n    _.each(queryString.split('&'), function (paramString) {\n      paramParts = paramString.split('=');\n      params[paramParts[0]] = decodeURIComponent(paramParts[1]);\n    });\n  }\n\n  var keys = route.keys\n    , m = route.regexp.exec(path);\n\n  if (!m) return false;\n\n  for (var i = 1, len = m.length; i < len; ++i) {\n    var key = keys[i - 1];\n\n    try {\n      var val = 'string' == typeof m[i]\n        ? decodeURIComponent(m[i])\n        : m[i];\n    } catch(e) {\n      var err = new Error(\"Failed to decode param '\" + m[i] + \"'\");\n      err.status = 400;\n      throw err;\n    }\n\n    if (key) {\n      params[key.name] = val;\n    } else {\n      params.push(val);\n    }\n  }\n  \n  return params;\n};\n","var Fiber = Npm.require('fibers');\n\nFastRender = {\n  _routes: [],\n  _onAllRoutes: []\n};\n\nFastRender.route = function route(path, callback) {\n  var keys = [];\n  FastRender._routes.push({\n    regexp: Utils._pathRegexp(path, keys, false, false),\n    callback: callback,\n    keys: keys\n  });\n};\n\nFastRender.onAllRoutes = function onAllRoutes(callback) {\n  FastRender._onAllRoutes.push(callback);\n};\n\nFastRender._processRoutes = function _processRoutes(path, loginToken, headers, callback) {\n  callback = callback || function() {};\n  var selectedRoute;\n  var params;\n\n  for(var lc=0; lc<FastRender._routes.length; lc++) {\n    var route = FastRender._routes[lc];\n    params = Utils._pathMatch(path, route);\n    if(params) {\n      selectedRoute = route;\n      break;\n    }\n  }\n\n  Fiber(function() {\n    var context = new Context(loginToken, { headers: headers });\n    try {\n\n      //run onAllRoutes callbacks if provided\n      FastRender._onAllRoutes.forEach(function(callback) {\n        callback.call(context, path);\n      });\n\n      if(selectedRoute) {\n        selectedRoute.callback.call(context, params, path);\n      }\n\n      callback(context.getData());\n    } catch(err) {\n      console.error('error on fast-rendering path: ' + path + \" ; error: \" + err.stack);\n      callback(null);\n    }\n  }).run();\n};\n\n// adding support for null publications\nFastRender.onAllRoutes(function() {\n  var context = this;\n  var nullHandlers = Meteor.default_server.universal_publish_handlers;\n  \n  if(nullHandlers && nullHandlers) {\n    nullHandlers.forEach(function(publishHandler) {\n      var publishContext = new PublishContext(context, null);\n      var params = [];\n      context.processPublication(publishHandler, publishContext, params);\n    });\n  }\n});","PublishContext = function PublishContext(context, subscription) {\n  this.userId = context.userId;\n  this.unblock = function() {};\n  this._subscription = subscription;\n  this._context = context;\n  this._collectionData = {};\n  this._onStop = [];\n  this._stopped = false;\n\n  // connection object\n  this.connection = {\n    _id: Meteor.uuid(),\n    close: function() {},\n    onClose: function() {},\n    // fake value, will be supported later on\n    clientAddress: \"127.0.0.1\",\n    httpHeaders: context.headers\n  };\n\n  // we won't be supporting all the other fields of the Meteor's\n  // Subscription class since they are private variables\n};\n\nPublishContext.prototype._ensureCollection = function(collection) {\n  if (!this._collectionData[collection]) {\n    this._collectionData[collection] = [];\n\n    //put this collection data in the parent context\n    this._context._ensureCollection(collection);\n    this._context._collectionData[collection].push(this._collectionData[collection]);\n  }\n};\n\nPublishContext.prototype.added = function(collection, id, fields) {\n  this._ensureCollection(collection);\n  var doc = _.clone(fields);\n  doc._id = id;\n  this._collectionData[collection].push(doc);\n};\n\nPublishContext.prototype.changed = function(collection, id, fields) {\n  var collectionData = this._collectionData;\n\n  collectionData[collection] = collectionData[collection].map(function(doc) {\n    if (doc._id === id) {\n      return _.extend(doc, fields);\n    }\n\n    return doc;\n  });\n};\n\nPublishContext.prototype.removed = function(collection, id) {\n  var collectionData = this._collectionData;\n\n  collectionData[collection] = collectionData[collection].filter(function(doc) {\n    return doc._id !== id;\n  });\n};\n\nPublishContext.prototype.onStop = function(cb) {\n  if (this._stopped) {\n    cb();\n  } else {\n    this._onStop.push(cb);\n  }\n};\n\nPublishContext.prototype.ready = function() {\n  this._stopped = true;\n\n  //make the subscription be marked as ready\n  if(this._subscription) {\n    //don't do this for null subscriptions\n    this._context.completeSubscriptions(this._subscription);\n  }\n\n  //make sure that any observe callbacks are cancelled\n  this._onStop.forEach(function(cb) {\n    cb();\n  });\n};\n\nPublishContext.prototype.error = function() {};\nPublishContext.prototype.stop = function() {};","var Fibers = Npm.require('fibers');\nvar Future = Npm.require('fibers/future');\n\nContext = function Context(loginToken, otherParams) {\n  this._collectionData = {};\n  this._subscriptions = {};\n  this._subscriptionFutures = [];\n  this._loginToken = loginToken;\n  \n  _.extend(this, otherParams);\n\n  // get the user\n  if(Meteor.users) {    \n    // check to make sure, we've the loginToken, \n    // otherwise a random user will fetched from the db\n    if(loginToken) {\n      var hashedToken = loginToken && Accounts._hashLoginToken( loginToken );\n      var query = {'services.resume.loginTokens.hashedToken': hashedToken }; \n      var options = {fields: {_id: 1}};\n      var user = Meteor.users.findOne(query, options);\n    }\n\n    //support for Meteor.user\n    Fibers.current._meteor_dynamics = {};\n    Fibers.current._meteor_dynamics[DDP._CurrentInvocation.slot] = this;\n\n    if(user) {\n      this.userId = user._id;\n    }\n  }\n};\n\nContext.prototype.subscribe = function(subscription /*, params */) {\n  var self = this;\n  \n  var publishHandler = Meteor.default_server.publish_handlers[subscription];\n  if(publishHandler) {\n    var publishContext = new PublishContext(this, subscription);\n    var params = Array.prototype.slice.call(arguments, 1);\n\n    this.processPublication(publishHandler, publishContext, params);\n  } else {\n    console.warn('There is no such publish handler named:', subscription);\n  }\n};\n\nContext.prototype.processPublication = function(publishHandler, publishContext, params) {\n  var self = this;\n  \n  var future = new Future;\n  this._subscriptionFutures.push(future);\n  //detect when the context is ready to be sent to the client\n  publishContext.onStop(function() {\n    if(!future.isResolved()) {\n      future.return();\n    }\n  });\n\n  try {\n    var cursors = publishHandler.apply(publishContext, params);\n  } catch(ex) {\n    console.warn('error caught on publication: ', publishContext._subscription, ': ', ex.message);\n    // since, this subscription caught on an error we can't proceed.\n    // but we can't also throws an error since other publications might have something useful\n    // So, it's not fair to ignore running them due to error of this sub\n    // this might also be failed due to the use of some private API's of Meteor's Susbscription class\n    publishContext.ready();\n  }\n\n  if(cursors) {\n    //the publish function returned a cursor\n    if(cursors.constructor != Array) {\n      cursors = [cursors];\n    }\n\n    //add collection data\n    cursors.forEach(function(cursor) {\n      cursor.rewind();\n      var collectionName = \n        (cursor._cursorDescription)? cursor._cursorDescription.collectionName: null || //for meteor-collections\n        (cursor._collection)? cursor._collection._name: null; //for smart-collections\n\n      self._ensureCollection(collectionName);\n      self._collectionData[collectionName].push(cursor.fetch());\n    });\n\n    //the subscription is ready\n    publishContext.ready();\n  } else if(cursors === null) {\n    //some developers send null to indicate they are not using the publication\n    //this is not the way to go, but meteor's accounts-base also does this\n    //so we need some special handling on this\n    publishContext.ready();\n  }\n\n  if (!future.isResolved()) {\n    //don't wait forever for handler to fire ready()\n    Meteor.setTimeout(function() {\n      if (!future.isResolved()) {\n        //publish handler failed to send ready signal in time\n        console.warn('Publish handler for', publishContext._subscription, 'sent no ready signal');\n        future.return();\n      }\n    }, 500);  //arbitrarially set timeout to 500ms, should probably be configurable\n  }\n};\n\nContext.prototype.completeSubscriptions = function(subscriptions) {\n  var self = this;\n  if(typeof subscriptions == 'string') {\n    subscriptions = [subscriptions];\n  } else if(!subscriptions || subscriptions.constructor != Array) {\n    throw new Error('subscriptions params should be either a string or array of strings');\n  }\n\n  subscriptions.forEach(function(subscription) {\n    self._subscriptions[subscription] = true;\n  });\n};\n\nContext.prototype._ensureCollection = function(collectionName) {\n  if(!this._collectionData[collectionName]) {\n    this._collectionData[collectionName] = [];\n  }\n};\n\nContext.prototype.getData = function() {\n  // Ensure that all of the subscriptions are ready\n  this._subscriptionFutures.forEach(function(future) {\n    future.wait();\n  });\n\n  return {\n    collectionData: this._collectionData,\n    subscriptions: this._subscriptions,\n    loginToken: this._loginToken\n  };\n};\n\nFastRender._Context = Context;","//When a HTTP Request comes, we need to figure out is it a proper request\n//then get some query data\n//then hijack html return by meteor\n//code below, does that in abstract way\n\nvar http = Npm.require('http');\n\nvar injectDataTemplate;\nAssets.getText('lib/server/inject_data.html', function(err, text) {\n  if(err) {\n    console.error('Error reading fast-render inject_data.html: ', err.message);\n  } else {\n    injectDataTemplate = _.template(text.trim());\n  }\n});\n\nvar originalWrite = http.OutgoingMessage.prototype.write;\nhttp.OutgoingMessage.prototype.write = function(chunk, encoding) {\n  //prevent hijacking other http requests\n  if(this.queryData && !this.injected &&\n    encoding === undefined && /<!DOCTYPE html>/.test(chunk)) {\n\n    //if cors headers included if may cause some security holes. see more:\n    //so we simply turn off fast-render if we detect an cors header\n    //read more: http://goo.gl/eGwb4e\n    if(this._headers['access-control-allow-origin']) {\n      var warnMessage =\n        'warn: fast-render turned off due to CORS headers. read more: http://goo.gl/eGwb4e';\n      console.warn(warnMessage);\n      originalWrite.call(this, chunk, encoding);\n      return;\n    }\n\n    //inject data\n    if(injectDataTemplate) {\n      var payload = {\n        subscriptions: this.queryData.subscriptions,\n        data: this.queryData.collectionData,\n        loginToken: this.queryData.loginToken\n      }\n      var data = EncodeEJSON(payload);\n      var injectHtml = injectDataTemplate({data: data});\n      chunk = chunk.replace('</head>', injectHtml + '\\n</head>');\n    } else {\n      console.warn('injectDataTemplate is not ready yet!');\n    }\n\n    this.injected = true;\n  }\n\n  originalWrite.call(this, chunk, encoding);\n};\n\n//meteor algorithm to check if this is a meteor serving http request or not\n//add routepolicy package to the fast-render\nfunction appUrl(url) {\n  if (url === '/favicon.ico' || url === '/robots.txt')\n    return false;\n\n  // NOTE: app.manifest is not a web standard like favicon.ico and\n  // robots.txt. It is a file name we have chosen to use for HTML5\n  // appcache URLs. It is included here to prevent using an appcache\n  // then removing it from poisoning an app permanently. Eventually,\n  // once we have server side routing, this won't be needed as\n  // unknown URLs with return a 404 automatically.\n  if (url === '/app.manifest')\n    return false;\n\n  // Avoid serving app HTML for declared routes such as /sockjs/.\n  try {\n    // If url is a absolute URL with http:// this throws and error and\n    // kill the app. Sometimes intruders will do this\n    // and that causes DOS for us.\n    if (typeof(RoutePolicy) != 'undefined' && RoutePolicy.classify(url))\n      return false;\n  } catch(ex) {\n    console.error(ex.stack);\n    return false;\n  }\n\n  // we currently return app HTML on all URLs by default\n  return true;\n};\n\n//check page and add queries\nWebApp.connectHandlers.use(Npm.require('connect').cookieParser());\nWebApp.connectHandlers.use(function(req, res, next) {\n  if(appUrl(req.url)) {\n    var loginToken = req.cookies['meteor_login_token'];\n    FastRender._processRoutes(req.url, loginToken, req.headers, function(queryData) {\n      res.queryData = queryData;\n      if(res.queryData) {\n        // encode the url and assign it. This is to prevent XSS\n        // some browsers like Chrome does the URL encoding manually\n        // So, we need to clear that and encode ourselves\n        res.queryData.serverRoutePath = encodeURI(decodeURI(req.url));\n      }\n      next();\n    });\n    //run our route handlers and add proper queryData\n  } else {\n    next();\n  }\n});\n","if(!Package['iron:router']) return;\n\nvar RouteController = Package['iron:router'].RouteController;\nvar Router = Package['iron:router'].Router;\n\nvar currentSubscriptions = [];\nMeteor.subscribe = function(subscription) {\n  currentSubscriptions.push(arguments);\n};\n\n//assuming, no runtime routes will be added\nMeteor.startup(function() {\n  // this is trick to run the processRoutes at the \n  // end of all Meteor.startup callbacks\n  Meteor.startup(processRoutes);\n});\n\nfunction processRoutes() {\n  Router.routes.forEach(function(route) {\n    route.options = route.options || {};\n    if(route.options.fastRender) {\n      handleRoute(route);\n    } else if(\n        getController(route) && \n        getController(route).prototype && \n        getController(route).prototype.fastRender\n    ) {\n      handleRoute(route);\n    }\n  });\n\n  // getting global waitOns\n  var globalWaitOns = [];\n  if(Router._globalHooks && Router._globalHooks.waitOn && Router._globalHooks.waitOn.length > 0) {\n    Router._globalHooks.waitOn.forEach(function(waitOn) {\n      globalWaitOns.push(waitOn.hook);\n    });\n  }\n  \n  FastRender.onAllRoutes(function(path) {\n    var self = this;\n    \n    currentSubscriptions = [];\n    globalWaitOns.forEach(function(waitOn) {\n      waitOn.call({path: path});\n    });\n    \n    currentSubscriptions.forEach(function(args) {\n      self.subscribe.apply(self, args);\n    });\n  });\n};\n\nfunction handleRoute(route) {\n  var subscriptionFunctions = [];\n  \n  // get potential subscription handlers from the route options\n  ['waitOn', 'subscriptions'].forEach(function(funcName) {\n    var handler = route.options[funcName];\n    if(typeof handler == 'function') {\n      subscriptionFunctions.push(handler);\n    } else if (handler instanceof Array) {\n      handler.forEach(function(func) {\n        if(typeof func == 'function') {\n          subscriptionFunctions.push(func);\n        }\n      });\n    }\n  });\n\n  FastRender.route(getPath(route), onRoute);\n\n  function onRoute(params, path) {\n    var self = this;\n    var context = {\n      params: params,\n      path: path\n    };\n\n    //reset subscriptions;\n    currentSubscriptions = [];\n    subscriptionFunctions.forEach(function(func) {\n      func.call(context);\n    });\n\n    // if there is a controller, try to initiate it and invoke potential \n    // methods which could give us subscriptions\n    var controller = getController(route);\n    if(controller && controller.prototype) {\n      if(typeof controller.prototype.lookupOption == 'function') {\n        // for IR 1.0\n        // it is possible to create a controller invoke methods on it\n        var controllerInstance = new controller();\n        controllerInstance.params = params;\n        controllerInstance.path = path;\n\n        ['waitOn', 'subscriptions'].forEach(function(funcName) {\n          if(controllerInstance[funcName]) {\n            controllerInstance[funcName].call(controllerInstance);\n          }\n        });\n      } else {\n        // IR 0.9\n        // hard to create a controller instance\n        // so this is the option we can take\n        var waitOn = controller.prototype.waitOn;\n        if(waitOn) {\n          waitOn.call(context);\n        }\n      }\n    }\n\n    currentSubscriptions.forEach(function(args) {\n      self.subscribe.apply(self, args);\n    });\n  }\n}\n\nfunction getPath(route) {\n  if(route._path) {\n    // for IR 1.0\n    return route._path;\n  } else {\n    // for IR 0.9\n    var name = (route.name == \"/\")? \"\" : name;\n    return route.options.path || (\"/\" + name);\n  }\n}\n\nfunction getController(route) {\n  if(route.findControllerConstructor) {\n    // for IR 1.0\n    return route.findControllerConstructor();\n  } else if(route.findController) {\n    // for IR 0.9\n    return route.findController();\n  } else {\n    // unsupported version of IR\n    return null;\n  }\n}"]}