{"version":3,"file":"/packages/kestanous:herald.js","sources":["kestanous:herald/lib/$herald.js","kestanous:herald/lib/collection.js","kestanous:herald/lib/couriers.js","kestanous:herald/lib/runners.js","kestanous:herald/lib/users.js","kestanous:herald/lib/onsite.js","kestanous:herald/lib/helpers.js","kestanous:herald/server/createNotification.js","kestanous:herald/server/escalate.js","kestanous:herald/server/publish.js"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA,qE;AACA,U;AACA,gC;AACA,a;AACA,0D;AACA,uB;AACA,gC;AACA,oC;AACA,uB;AACA,I;;AAEA,qB;AACA,mF;AACA,gF;AACA,I;AACA,0E;AACA,0E;AACA,4D;;;AAGA,Y;AACA,gB;AACA,oF;AACA,E;;AAEA,gF;AACA,2E;AACA,E;AACA,oE;AACA,E;AACA,8D;AACA,gB;AACA,E;AACA,0F;AACA,qF;AACA,4E;AACA,uC;AACA,2E;;AAEA,+F;AACA,iC;AACA,uC;AACA,Y;AACA,sC;AACA,oB;AACA,uG;AACA,O;AACA,K;AACA,G;AACA,qC;;AAEA,6B;AACA,8B;AACA,G;;AAEA,gC;AACA,yC;AACA,8B;AACA,O;AACA,G;;AAEA,Q;AACA,4F;AACA,G;AACA,E;;;;;;;;;;;;;;;;;;;AChEA,4B;AACA,iD;AACA,6E;AACA,wC;AACA,6F;AACA,6D;AACA,kG;AACA,qF;AACA,oD;AACA,gD;AACA,qF;AACA,oC;AACA,uD;AACA,c;AACA,kF;AACA,U;;AAEA,yE;AACA,gC;AACA,gD;AACA,0D;AACA,S;AACA,Q;AACA,yB;AACA,K;AACA,K;;AAEA,wE;AACA,+D;AACA,a;AACA,2B;AACA,kC;AACA,kE;AACA,mB;AACA,M;AACA,oC;AACA,iC;AACA,M;AACA,oC;AACA,iC;AACA,K;AACA,K;AACA,G;;;;;;;;;;;;;;;;;;;AC1CA,6C;AACA,qB;AACA,6B;AACA,qE;;AAEA,yB;AACA,2B;AACA,kC;AACA,I;AACA,oC;AACA,yF;AACA,wB;AACA,iC;AACA,qC;AACA,0B;AACA,oF;AACA,qC;AACA,gD;AACA,gF;;AAEA,iE;AACA,O;AACA,G;AACA,kB;AACA,+B;;AAEA,wC;;AAEA,+C;AACA,8D;AACA,C;;;;;;;;;;;;;;;;;;;AC9BA,sC;AACA,4F;AACA,sF;AACA,8F;AACA,kG;AACA,+D;AACA,0E;;AAEA,Y;AACA,+B;AACA,0B;AACA,M;AACA,wB;;AAEA,kC;AACA,0B;AACA,qD;AACA,0B;AACA,oD;AACA,K;;AAEA,oD;AACA,C;;;AAGA,sB;AACA,mC;AACA,2B;AACA,C;;AAEA,oC;AACA,4B;AACA,C;;AAEA,yC;AACA,yC;AACA,C;;AAEA,kD;AACA,wD;AACA,C;;;AAGA,6D;AACA,0B;AACA,e;AACA,sF;AACA,Y;AACA,gB;AACA,iB;AACA,Y;AACA,iB;AACA,iB;AACA,4F;AACA,sB;AACA,8C;AACA,qF;AACA,sF;AACA,qE;AACA,W;AACA,Q;AACA,Q;AACA,0C;AACA,iE;AACA,4E;AACA,O;AACA,Y;AACA,oB;AACA,iB;AACA,qF;AACA,uF;AACA,6C;AACA,2E;AACA,8C;AACA,kB;AACA,wB;AACA,+D;AACA,sB;AACA,4C;AACA,2E;AACA,Q;AACA,O;AACA,Y;AACA,Y;AACA,mG;AACA,G;AACA,Y;AACA,C;;AAEA,gB;AACA,iE;AACA,iE;AACA,4G;AACA,oE;AACA,mG;AACA,sF;AACA,oD;AACA,oB;AACA,mD;AACA,qF;AACA,wB;AACA,oE;AACA,Y;AACA,wC;AACA,S;AACA,K;AACA,K;AACA,iE;AACA,8F;AACA,iE;AACA,qG;AACA,6B;AACA,qC;AACA,+D;AACA,e;AACA,K;AACA,G;AACA,G;;;;;;;;;;;;;;;;;;;ACrHA,0E;AACA,mH;;;AAGA,8B;AACA,iE;;AAEA,qF;AACA,kF;;AAEA,uG;AACA,qD;AACA,yH;AACA,E;AACA,yB;AACA,sC;AACA,iC;AACA,yB;AACA,2B;AACA,Q;AACA,+C;AACA,G;AACA,uF;;AAEA,Y;AACA,sB;AACA,yF;AACA,G;AACA,oC;AACA,uH;AACA,G;;;AAGA,gC;;AAEA,4C;AACA,4C;AACA,8F;AACA,S;AACA,K;;AAEA,8B;AACA,iD;AACA,kD;AACA,wC;AACA,O;;AAEA,2F;AACA,sB;;;AAGA,yB;AACA,8F;AACA,kB;AACA,oE;AACA,0D;AACA,G;AACA,8B;AACA,0D;AACA,gD;AACA,qC;AACA,K;AACA,gB;AACA,4D;AACA,wD;;AAEA,C;;AAEA,yC;AACA,6D;AACA,yF;AACA,4C;AACA,gF;AACA,gE;AACA,kF;AACA,E;AACA,yB;AACA,sC;AACA,iC;AACA,yB;AACA,2B;AACA,Q;AACA,+C;AACA,G;;AAEA,uF;;AAEA,2D;AACA,E;AACA,W;AACA,oB;AACA,wB;AACA,kC;AACA,wB;;AAEA,gD;;AAEA,mD;;AAEA,mB;AACA,6C;AACA,wC;AACA,oE;AACA,wC;AACA,mG;AACA,kE;AACA,K;AACA,G;AACA,W;AACA,yC;AACA,wB;AACA,G;AACA,8D;AACA,mD;AACA,M;AACA,wB;AACA,C;;AAEA,8C;AACA,W;AACA,oB;AACA,yB;AACA,kB;AACA,M;AACA,I;AACA,E;;AAEA,0D;AACA,c;AACA,oB;AACA,gB;AACA,kB;AACA,M;AACA,I;AACA,mD;AACA,a;AACA,E;;;;;;;;;;;;;;;;;;;ACxIA,c;AACA,iB;AACA,mB;AACA,C;AACA,8C;AACA,8B;AACA,yB;;;;;;;;;;;;;;;;;;;ACNA,iD;AACA,qD;AACA,mD;AACA,4C;AACA,c;AACA,G;;AAEA,0B;AACA,sF;AACA,G;;AAEA,qE;AACA,2B;AACA,sF;AACA,G;;AAEA,0B;AACA,4B;AACA,0B;AACA,sB;AACA,S;;;AAGA,mC;AACA,iB;AACA,G;;AAEA,Y;AACA,0B;AACA,wC;AACA,kC;AACA,yB;AACA,2B;AACA,Y;AACA,+C;AACA,K;;AAEA,G;;AAEA,yB;AACA,0B;AACA,iE;AACA,G;;AAEA,kB;AACA,iE;AACA,sF;AACA,G;;AAEA,iB;AACA,sD;AACA,oF;AACA,G;;AAEA,8C;AACA,c;AACA,gD;AACA,G;AACA,e;AACA,gC;AACA,G;;AAEA,iD;AACA,E;;;AAGA,uC;AACA,gB;AACA,oC;AACA,6B;AACA,4B;AACA,O;AACA,e;AACA,oB;AACA,S;AACA,Q;AACA,mB;AACA,M;AACA,G;AACA,G;;;;;;;;;;;;;;;;;;;AC/EA,6D;AACA,wD;AACA,mF;AACA,wB;AACA,wC;AACA,kE;;AAEA,kC;AACA,8C;AACA,0E;AACA,uE;;AAEA,sC;AACA,O;AACA,iD;AACA,8C;AACA,oC;AACA,qD;AACA,kD;AACA,+D;AACA,0F;AACA,wF;;AAEA,wB;AACA,sC;AACA,uB;AACA,8B;AACA,wB;AACA,kB;AACA,uB;AACA,sB;AACA,e;AACA,M;;AAEA,8E;AACA,2D;AACA,qB;AACA,oE;AACA,oB;AACA,c;AACA,mF;AACA,Q;AACA,Q;AACA,4D;AACA,O;;AAEA,2C;AACA,gE;;AAEA,sF;AACA,yB;AACA,uC;AACA,2C;AACA,K;;AAEA,0B;AACA,K;AACA,E;;;;;;;;;;;;;;;;;;;ACzDA,0C;AACA,4B;AACA,4C;AACA,wD;AACA,oD;AACA,+F;AACA,G;;;AAGA,mD;AACA,wE;AACA,kF;AACA,iF;AACA,8G;AACA,+F;AACA,kC;AACA,K;AACA,6E;AACA,C;;AAEA,gB;AACA,O;AACA,qE;AACA,M;AACA,qC;AACA,6B;AACA,O;AACA,yD;AACA,a;AACA,oD;AACA,qB;AACA,wE;AACA,S;AACA,K;AACA,G;;;AAGA,qD;;AAEA,+D;AACA,4D;AACA,sE;AACA,4G;AACA,uE;;AAEA,sD;AACA,4C;;;AAGA,kE;AACA,6E;;AAEA,4E;AACA,gC;AACA,qE;AACA,gG;AACA,yD;AACA,G;;AAEA,Y;AACA,uC;AACA,+E;AACA,kB;AACA,0D;AACA,iE;AACA,U;AACA,mB;AACA,+C;AACA,iE;AACA,G;AACA,E;AACA,E;AACA,E;;;;;;;;;;;;;;;;;;;ACxEA,2D;AACA,4C;AACA,gE;AACA,oB;AACA,qD;AACA,kB;AACA,K;AACA,kE;AACA,G","sourcesContent":["//This is our Global Object. $herald.js will be the first file loaded\nHerald = {\n  //Notification global settings\n  settings: {\n    overrides: {}, //disable functionality for all users. \n    queueTimmer: 60000,\n    userPreferenceDefault: true,\n    collectionName: 'notifications',\n    useIronRouter: true\n  },\n\n  //media and runners\n  _media: function () { //supported media, extension packages should push new kinds\n    return _.union(_.keys(Herald._serverRunners), _.keys(Herald._clientRunners))\n  },\n  _serverRunners: {}, //extension packages load their code here on servers\n  _clientRunners: {}, //extension packages load their code here on clients\n  _runnerCheckers: {}, //test if courier media data is valid\n\n\n  //couriers\n  _couriers: {},\n  _extentionParams: [] //UNDOCUMENTED: allow for more top level params on EventTypes\n};\n\n// Package users can define a predefined message from the notification instance.\n// It requires the user pass a options.message function, string, or object.\n//\n// If its a function it will be run with the from the instance scope\n//\n// If its a string it will return a template with the instance\n// as its data. \n//\n// If its an object it will run any number of templates or functions based on the optional\n// string argument given at the time of call. If no string is passed it will default \n// to 'default'. From there it acts the same as ether of the above patterns.\nHerald._message = function (template) {\n  var message, messageFormat = Herald._couriers[this.courier].messageFormat\n\n  if(_.isObject(messageFormat) && !_.isFunction(messageFormat) && !_.isString(messageFormat)) {\n    if(messageFormat[template]) {\n      message = messageFormat[template]\n    } else {\n      message = messageFormat.default;\n      if(!message) {\n        throw new Error('Herald: No default message defined for \"' + this.courier + '\" notifications');\n      }\n    }\n  }\n  message = message || messageFormat;\n\n  if(_.isFunction(message)) {\n    return message.apply(this)\n  }\n\n  else if(_.isString(message)) {\n    return Blaze.With(this, function () {\n      return Template[message]\n    });\n  }\n\n  else {\n    throw new Error('Herald: message not defined for \"' + this.courier + '\" notifications');\n  }\n};\n","Meteor.startup(function () {\n  //The collection and any instance functionality\n  Herald.collection = new Meteor.Collection(Herald.settings.collectionName, {\n    transform: function (notification) {\n      if (notification.courier) { //courier may not be available if fields filter was called.\n        var courier = Herald._couriers[notification.courier];\n        //This is the basic message you want to output. Use in the app or as an email subject line\n        // it is optional and is set up with createNotification from the server code.\n        notification.message = function (template) {\n          if (template && !_.isString(template))\n            throw new Error('Herald: message argument must be undefined or a string')\n          if (courier.messageFormat)\n            return Herald._message.call(this, template)\n          else\n            throw new Error('Herald: no message defined for \"'+ this.courier +'\"')\n        };\n\n        //internal scoping and cloning, because js is magically confusing\n        if (courier.transform) {\n          transform = _.clone(courier.transform)\n          notification = _.extend(transform, notification)\n        }\n      };\n      return notification\n    }\n  });\n\n  //Minimum requirement for notifications to work while still providing \n  //basic security. For added limitations use `Herald.deny` in \n  //your app.\n  Herald.collection.allow({\n    insert: function(userId, doc){\n      // new notifications can only be created via a Meteor method\n      return false;\n    },\n    update: function (userId, doc) {\n      return userId == doc.userId\n    },\n    remove: function (userId, doc) {\n      return userId == doc.userId\n    }\n  });\n});\n","Herald.addCourier = function (key, options) {\n  check(key, String);\n  if (Herald._couriers[key]) \n    throw new Error('Herald: courier \"' + key + '\"\" already exists');\n\n  check(options, Object);\n  Herald._couriers[key] = {\n    messageFormat: options.message\n  };\n var courier = Herald._couriers[key]\n  //media is required but should only throw exceptions on the server, where it is needed.\n  if (Meteor.isServer) {\n    check(options.media, Object);\n    var media = _.keys(options.media)\n    if (media.length == 0)\n      throw new Error('Herald: courier \"'+ key + '\" must have at least one medium');\n    media.forEach(function (medium) {\n      if (!_.contains(Herald._media(), medium)) \n        throw new Error('Herald: medium \"' + medium + '\" is not a known media');\n\n      Herald._runnerCheckers[medium].apply(options.media[medium])\n    });\n  }\n  //define on both\n  courier.media = options.media\n\n  courier.transform = options.transform;\n\n  //white-listed params from extension packages\n  _.extend(courier, _.pick(options, Herald._extentionParams)) \n}\n","Herald.addRunner = function (object) {\n  if (!_.isObject(object)) throw new Error('Herald: Runner must have an `object` argument');\n  if (! _.isString(object.name)) throw new Error('Herald: Runner must medium `name`');\n  if (!_.isFunction(object.run)) throw new Error('Herald: Runner must have a `run` function');\n  if (!_.isFunction(object.check)) throw new Error('Herald: Runner must have a `check` function');\n  if (! (_.isArray(object.where) || _.isString(object.where))) \n    throw new Error('Herald: Runner `where` must be a valid environment');\n\n  var where;\n  if (_.isString(object.where))\n    where = [object.where]\n  else\n    where = object.where\n\n  _.each(where, function (where) {\n    if (where == 'server')\n      Herald._serverRunners[object.name] = object.run\n    if (where == 'client')\n     Herald._clientRunners[object.name] = object.run\n  });\n\n  Herald._runnerCheckers[object.name] = object.check\n}\n\n\nonRun = function () {}\nonRun.prototype.run = function () {\n  return { command: 'run' }\n}\n\nonRun.prototype.stop = function () {\n  return { command: 'stop' }\n}\n\nonRun.prototype.delay = function (time) {\n  return { command: 'delay', time: time }\n}\n\nonRun.prototype.transfer = function (name, time) {\n  return { command: 'transfer', name: name, time: time }\n}\n\n\nonRunResolve = function (notification, medium, result, run) {\n  switch(result.command) {\n    case 'run':\n      //run true, but invalidation could have been triggered elsewhere so don't change\n      break;\n    case 'stop':\n      run = false\n      break;\n    case 'delay':\n      run = false\n      if (Herald._serverRunners[medium]) { //will only be called on server, no method needed\n        var query = {}\n        query['media.'+medium+'.send'] = true;\n        var command = 'Herald.escalate(\"' + notification._id + '\", \"' + medium + '\")'\n        Herald.collection.update(notificationId, {$set: query},function (err, count) {\n          Queue.add({command: command, execute_after: result.time})  \n        });\n        \n      } \n      if (Herald._clientRunners[medium]) {\n        var delay = result.time.getTime() - new Date().getTime();\n        Meteor.call('HeraldUpdateAndDelay', notification._id, medium, delay)\n      }\n      break;\n    case 'transfer':\n      run = false\n      if (!Herald._clientRunners[result.name] && !Herald._serverRunners[result.name])\n        throw new Error('Herald: '+ medium +' transfer call - no medium '+ result.name)\n      if (Herald._serverRunners[result.name])\n        Meteor.call('HeraldTransferServerMedium', notification._id, result)\n      if (Herald._clientRunners[result.name]){\n        var delay;\n        if (result.time)\n          delay = result.time.getTime() - new Date().getTime();\n        var query = {}\n        query['media.' + result.name] = true\n        Meteor.call('HeraldUpdateAndDelay', notification._id, query, delay)\n        \n      }\n      break;\n    default:\n      throw new Error('Herald:' + medium + ' onRun returned the unknown command ' + result.command)\n  }\n  return run\n}\n\nMeteor.methods({\n  HeraldTransferServerMedium: function (notificationId, result) {\n    var notification = Herald.collection.findOne(notificationId);\n    if (this.userId != notification.userId) throw new Meteor.Meteor.Error(550, 'Herald: permission denied');\n    if (!Herald._couriers[notification.courier].media[result.name]) \n      throw new Error('Herald: '+ notification.courier +' transfer call - no medium '+ result.name)\n    var command = 'Herald.escalate(\"' + notification._id + '\", \"' + result.name + '\")'\n    if (Meteor.isServer) {//simulation causes errors\n      var query = {}\n      query['media.'+ result.name +'.send'] = true;\n      Herald.collection.update(notificationId, {$set: query}, function (err, count) {\n        if (result.time)\n          Queue.add({command: command, execute_after: result.time});\n        else\n          Queue.add({command: command});\n      });\n    }\n  }, \n  HeraldUpdateAndDelay: function (notificationId, query, delay) {\n    if (!delay || delay < 1000) delay = 1000 //give at least one second for the dust to settle\n    var notification = Herald.collection.findOne(notificationId);\n    if (this.userId != notification.userId) throw new Meteor.Error(550, 'Herald: permission denied');\n    if (!this.isSimulation) {\n      Meteor.setTimeout(function () {\n        Herald.collection.update(notificationId, {$set: query})\n      }, delay)\n    }\n  }\n});\n","//userPreference - can be easily overloaded without loss of functionality.\nHerald.userPreference = function (user, medium, courier) { return Herald.getUserPreference(user, medium, courier) }\n\n\n// set user medium preference \nHerald.setUserPreference = function (user, preference, courier) {\n\n  if (courier && !_.contains(_.keys(Herald._couriers), courier)) //optional and check\n    throw new Error('Herald - getUserPreference: courier \"'+courier+'\" not found')\n\n  if (!_.isObject(preference)) throw new Error('Herald - getUserPreference: no media preference given')\n  var badKeys = _.omit(preference, Herald._media() ) \n  if (!_.isEmpty(badKeys)) throw new Error('Herald - getUserPreference: \"'+ _.toArray(badKeys) + '\" are not valid media')\n  \n  if (_.isString(user)) {\n    user = Meteor.users.findOne(user);\n  } else if (!_.isObject(user)) {\n    if (Meteor.isClient) \n      user = Meteor.user();\n    else\n      user = Meteor.users.findOne(this.userId);\n  }\n  if (!user || !user._id) throw new Error('Herald - setUserPreference: user not found')\n\n  //not set \n  if (!user.profile) {\n    return Meteor.users.update(user._id, {$set: {profile: newProfileMedia(preference)}});\n  }\n  if (!user.profile.notifications) {\n    return Meteor.users.update(user._id, {$set: {'profile.notifications': newProfileMedia(preference).notifications}});\n  }\n\n\n  if (!courier) { //generic only\n\n    if (!user.profile.notifications.media) {\n      return Meteor.users.update(user._id, {\n        $set: {'profile.notifications.media': newProfileMedia(preference).notifications.media}\n      });\n    }\n\n    //merge medium preferences\n    var media = user.profile.notifications.media;\n    _.keys(preference).forEach(function (medium) {\n      media[medium] = preference[medium]\n    });\n\n    return Meteor.users.update(user._id, { $set: {'profile.notifications.media': media} });\n  } //generic only end\n\n\n  //for courier set only \n  if (!user.profile.notifications.couriers || !user.profile.notifications.couriers[courier]) {\n    var query = {}\n    query['profile.notifications.couriers.' + courier] = preference;\n    return Meteor.users.update(user._id, { $set: query });\n  }\n  //merge couriers preferences\n  var pref = user.profile.notifications.couriers[courier];\n  _.keys(preference).forEach(function (medium) {\n    pref[medium] = preference[medium]\n  });\n  var query = {}\n  query['profile.notifications.couriers.' + courier] = pref;\n  return Meteor.users.update(user._id, { $set: query });\n\n}\n\n// get user [medium [courier]] preference\nHerald.getUserPreference = function (user, medium, courier) {\n  if (!_.isString(medium)) throw new Error('Herald - getUserPreference: no medium given')\n  if (!_.contains(Herald._media(), medium)) \n    throw new Error('Herald - getUserPreference: medium \"'+medium+'\" not found')\n  if (courier && !_.contains(_.keys(Herald._couriers), courier))\n    throw new Error('Herald - getUserPreference: courier \"'+courier+'\" not found')\n  \n  if (_.isString(user)) {\n    user = Meteor.users.findOne(user);\n  } else if (!_.isObject(user)) {\n    if (Meteor.isClient) \n      user = Meteor.user();\n    else\n      user = Meteor.users.findOne(this.userId);\n  }\n\n  if (!user || !user._id) throw new Error('Herald - getUserPreference: user not found')\n\n  var defaultOutput = Herald.settings.userPreferenceDefault\n  \n  //not set\n  if (!user.profile)\n    return defaultOutput\n  if (!user.profile.notifications)\n    return defaultOutput\n\n  var useCourier = false; //assume not set, skip\n\n  if (courier) useCourier = true; //set, don't skip\n\n  if (useCourier) {\n    if (!user.profile.notifications.couriers)\n      useCourier = false //not set, skip\n    if (useCourier && !user.profile.notifications.couriers[courier])\n      useCourier = false //not set, skip\n    if (useCourier && user.profile.notifications.couriers[courier].hasOwnProperty(medium)) {//skip?\n      return user.profile.notifications.couriers[courier][medium];\n    }\n  }\n  //general\n  if (!user.profile.notifications.media){\n    return defaultOutput\n  }\n  if (user.profile.notifications.media.hasOwnProperty(medium))\n    return user.profile.notifications.media[medium]\n  else\n    return defaultOutput\n}\n\nvar newProfileMedia = function (preferences) {\n  return { \n    notifications: {\n      media: preferences,\n      couriers: {}\n    } \n  };\n} \n\nvar newProfileCouriers = function (courier, preferences) {\n  var obj = { \n    notifications: {\n      media: {},\n      couriers: {}\n    } \n  };\n  obj.notifications.couriers[courier] = preferences\n  return obj;\n} \n","var runner = {\n  name: 'onsite',\n  where: ['client']\n}\nrunner.run = function (notification, user) {};\nrunner.check = function () {};\nHerald.addRunner(runner);\n","//get notifications by user, [courier, [[medium]]\nHerald.getNotifications = function (query, options) {\n  // break function if not finished with logging in\n  if(Meteor.isClient && Meteor.loggingIn()){\n    return [];\n  }\n\n  if(!_.isObject(query)) {\n    throw new Meteor.Error(\"Herald getNotifications must contain Mongo filter query\");\n  }\n\n  var badKeys = _.omit(query, ['user', 'courier', 'medium', 'read']);\n  if(!_.isEmpty(badKeys)) {\n    throw new Error('Herald - getNotifications: unknown key(s) ' + _.toArray(badKeys))\n  }\n\n  var userId = query.user,\n    courier = query.courier,\n    medium = query.medium,\n    read = query.read,\n    user;\n\n\n  if(typeof read === \"undefined\") {\n    read = false;\n  }\n\n  //get user\n  if(_.isString(userId)) {\n    user = Meteor.users.findOne(userId);\n  } else if(!_.isObject(userId)) {\n    if(Meteor.isClient) {\n      user = Meteor.user();\n    } else {\n      user = Meteor.users.findOne(this.userId);\n    }\n\n  }\n\n  // check if user exists\n  if(!user || !user._id) {\n    throw new Error('Herald - getNotifications: user not found');\n  }\n\n  // check courier\n  if(courier && !_.contains(_.keys(Herald._couriers), courier)) {\n    throw new Error('Herald - getNotifications: courier \"' + courier + '\" not found');\n  }\n\n  // check medium\n  if(medium && !_.contains(Herald._media(), medium)) {\n    throw new Error('Herald - getNotifications: medium \"' + medium + '\" not found');\n  }\n\n  var filter = {userId: user._id, read: read};\n  if(medium) {\n    filter['media.' + medium] = {$exists: true};\n  }\n  if(courier) {\n    filter['courier'] = courier;\n  }\n\n  return Herald.collection.find(filter, options);\n};\n\n\n//literally mark-All-As-Read, cheers :)\nMeteor.methods({\n  heraldMarkAllAsRead: function () {\n    Herald.collection.update(\n      {userId: this.userId},\n      {\n        $set: {\n          read: true\n        }\n      },\n      {multi: true}\n    );\n  }\n});\n","//You can insert manually but this should save you some work.\nHerald.createNotification = function (userIds, params) {\n  check(userIds, Match.OneOf([String], String)); //TODO: better Collection ID check\n  check(params, Object);\n  if (!Herald._couriers[params.courier])\n    throw new Error('Notification: courier type does not exists');\n\n  // always assume multiple users.\n  if (_.isString(userIds)) userIds = [userIds]\n  users = Meteor.users.find({_id: {$in: userIds}}, {fields: {profile: 1}})\n  users.forEach(function (user) { //create a notification for each user\n\n    //When creating a new notification\n    // \n    // timestamp - you should timestamp every doc\n    // userId - there must be a user to notify\n    // courier - this is the courier\n    // data - in database metadata, consider renaming\n    // read - default false, consider auto-delete?\n    // escalated - track if higher level notifications have run\n    // url - allow of iron:router magic. set read to true if visited (see routeSeenByUser)\n    // media - a list of all the media the notification can be sent on but has not been.\n\n    var notification = {\n      timestamp: new Date().getTime(),\n      userId: user._id,\n      courier: params.courier,\n      data: params.data,\n      read: false,\n      escalated: false,\n      url: params.url,\n      media: {}\n    };\n\n    _.each(_.keys(Herald._couriers[params.courier].media), function (medium) {\n      //check if this notification should be sent to medium\n      var run = true;\n      if (Herald._couriers[params.courier].media[medium].fallback) {\n        run = false;\n      } else {\n       if (!Herald.userPreference(user, medium, notification.courier)) run = false;\n      };\n        \n      notification.media[medium] = {send: run, sent: false};\n    });\n\n    //create notification and return its id\n    var notificationId = Herald.collection.insert(notification);\n\n    //if no notificationId then insert failed anD PANIC, STOP, DON'T ACUTALLY DO THIS!\n    if (notificationId) {\n      notification._id = notificationId\n      Herald.SetupEscalations(notification)\n    }\n\n    return notificationId;\n  });\n};\n","//allow package users to delay escalations\nMeteor.startup(function () {\n  //if no pattern is defined then skip this.\n  // if (!Herald.settings.delayEscalation) return false;\n  console.log('Starting artwells:queue for Herald');\n  Meteor.setInterval(function(){Queue.run()}, Herald.settings.queueTimmer); /* once a minute */\n});\n\n\nHerald.SetupEscalations = function (notification) {\n  if (notification.escalated) return false; //don't resend notifications\n  _.each(_.keys(Herald._couriers[notification.courier].media), function (medium) {\n    if (!_.contains(_.keys(Herald._serverRunners), medium)) return; //Server only\n    if (!notification.media[medium].send || notification.media[medium].sent) return; //already sent/don't send\n    var command = 'Meteor.call(\"heraldEscalate\",\"' + notification._id + '\", \"' + medium + '\")';\n    Queue.add({command: command })\n  });\n  Herald.collection.update(notification._id, { $set: { escalated: true } } );\n}\n\nMeteor.methods({\n    /**\n     * Server method to call Herald.escalate out of the queue package\n     *\n     * @param {string} notificationId\n     * @param {string} medium\n     */\n    \"heraldEscalate\": function (notificationId, medium) {\n        try {\n            Herald.escalate(notificationId, medium);\n        } catch (e) {\n            throw new Meteor.Error(\"Can't start Herald.escalate: \" + e);\n        }\n    }\n});\n\n\nHerald.escalate = function (notificationId, medium) {\n\n  var notification = Herald.collection.findOne(notificationId);\n  if (!notification) return; //notification has been removed\n  if (notification.read) return; //don't escalate a read notification!\n  if (!notification.media[medium].send || notification.media[medium].sent) return; //already sent/don't send\n  if (Herald.settings.overrides[medium]) return; //disabled by override\n\n  var user = Meteor.users.findOne(notification.userId)\n  if (!user) return; //user has been removed\n\n\n  var run = true; //does the user want you to send on this medium?\n  if (!Herald.userPreference(user, medium, notification.courier)) run = false\n\n  var thisOnRun = Herald._couriers[notification.courier].media[medium].onRun\n  if (_.isFunction(thisOnRun)) {\n    var result = thisOnRun.call(new onRun(), notification, user, run)\n    if (!result.command) throw new Error('Herald:' + medium + ' onRun did not return a command')\n    run = onRunResolve(notification, medium, result, run)\n  }\n\n  if (run) {\n    Herald._serverRunners[medium].call(\n      Herald._couriers[notification.courier].media[medium], notification, user)\n    var query = {}\n    query[ 'media.' + medium] = {send: false, sent: true};\n    Herald.collection.update(notification._id, { $set: query } );\n  } else {\n    var query = {};\n    query['media.' + medium + '.send'] =  false\n    Herald.collection.update(notification._id, { $set: query } );\n  }\n  \n  \n};\n","// only publish notifications belonging to the current user\nMeteor.publish('notifications', function() {\n  var media = _.keys(Herald._clientRunners).map(function (key) {\n    var medium = {};\n    medium['media.'+key] = {send: true, sent: false};\n    return medium;\n  });\n  return Herald.collection.find({userId:this.userId, $or: media});\n});\n"]}