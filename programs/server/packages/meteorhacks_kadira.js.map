{"version":3,"file":"/packages/meteorhacks:kadira.js","sources":["meteorhacks:kadira/lib/common/unify.js","meteorhacks:kadira/lib/models/base_error.js","meteorhacks:kadira/lib/jobs.js","meteorhacks:kadira/lib/retry.js","meteorhacks:kadira/lib/utils.js","meteorhacks:kadira/lib/ntp.js","meteorhacks:kadira/lib/wait_time_builder.js","meteorhacks:kadira/lib/models/0model.js","meteorhacks:kadira/lib/models/methods.js","meteorhacks:kadira/lib/models/pubsub.js","meteorhacks:kadira/lib/models/system.js","meteorhacks:kadira/lib/models/errors.js","meteorhacks:kadira/lib/kadira.js","meteorhacks:kadira/lib/check_for_oplog.js","meteorhacks:kadira/lib/tracer.js","meteorhacks:kadira/lib/tracer_store.js","meteorhacks:kadira/lib/hijack/wrap_server.js","meteorhacks:kadira/lib/hijack/wrap_session.js","meteorhacks:kadira/lib/hijack/wrap_subscription.js","meteorhacks:kadira/lib/hijack/wrap_observers.js","meteorhacks:kadira/lib/hijack/session.js","meteorhacks:kadira/lib/hijack/db.js","meteorhacks:kadira/lib/hijack/http.js","meteorhacks:kadira/lib/hijack/email.js","meteorhacks:kadira/lib/hijack/async.js","meteorhacks:kadira/lib/hijack/error.js","meteorhacks:kadira/lib/profile/server.js","meteorhacks:kadira/lib/profile/set_labels.js","meteorhacks:kadira/lib/auto_connect.js","meteorhacks:kadira/lib/common/default_error_filters.js","meteorhacks:kadira/lib/common/send.js"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA,Y;AACA,oB;;AAEA,sB;AACA,uC;AACA,Q;AACA,wC;AACA,C;;AAEA,8C;AACA,8C;AACA,gD;AACA,U;AACA,mC;AACA,G;AACA,E;;;;;;;;;;;;;;;;;;ACfA,oC;AACA,qB;AACA,E;;AAEA,uD;AACA,oC;AACA,+B;AACA,U;AACA,uD;AACA,G;AACA,E;;AAEA,0D;AACA,4C;AACA,kB;AACA,mC;AACA,G;AACA,E;;AAEA,iF;AACA,gD;AACA,mC;AACA,S;AACA,4D;AACA,kC;AACA,kB;AACA,sC;AACA,yC;AACA,kC;AACA,kF;AACA,K;AACA,G;;AAEA,c;AACA,E;;;;;;;;;;;;;;;;;;AClCA,U;AACA,wC;AACA,iB;AACA,kB;AACA,a;AACA,Y;AACA,K;AACA,I;;AAEA,0C;AACA,E;;AAEA,iD;AACA,iB;AACA,kB;AACA,a;AACA,Y;AACA,K;AACA,I;AACA,oC;;AAEA,0C;AACA,E;;;AAGA,4C;AACA,4C;;;;;;;;;;;;;;;;;;AC1BA,2C;AACA,E;AACA,W;AACA,yD;AACA,kE;AACA,kD;AACA,sD;AACA,mE;AACA,qE;;AAEA,4E;;AAEA,4B;AACA,kB;AACA,qD;AACA,kC;AACA,kB;AACA,oE;AACA,8B;AACA,uC;AACA,mB;AACA,gB;AACA,uB;AACA,M;AACA,yB;AACA,E;;AAEA,2B;;AAEA,mC;AACA,sB;AACA,oB;AACA,uB;AACA,oC;AACA,2B;AACA,I;;AAEA,sE;AACA,oC;AACA,8B;AACA,oB;;AAEA,6B;AACA,6B;;AAEA,2B;AACA,sB;AACA,yD;AACA,kE;AACA,wB;AACA,0D;AACA,4C;AACA,8B;AACA,I;;AAEA,0E;AACA,oC;AACA,oB;AACA,uC;AACA,uB;AACA,oC;;AAEA,8C;AACA,mB;AACA,G;;AAEA,G;;;;;;;;;;;;;;;;;;;AClEA,kC;;AAEA,oC;AACA,qC;AACA,wC;AACA,E;;AAEA,4B;AACA,c;AACA,C;;AAEA,qC;AACA,wB;AACA,E;;AAEA,iC;;;;;;;;;;;;;;;;;;;ACfA,yB;;AAEA,2B;AACA,6B;AACA,gB;AACA,sB;AACA,uB;AACA,2B;AACA,yB;AACA,2B;AACA,e;AACA,K;AACA,C;;AAEA,uB;AACA,uB;AACA,8B;AACA,e;AACA,kC;AACA,4E;AACA,+D;AACA,yB;AACA,U;AACA,4C;AACA,kC;AACA,G;AACA,E;;AAEA,gD;AACA,+C;AACA,E;;AAEA,oC;AACA,4C;AACA,E;;AAEA,8C;AACA,0C;AACA,E;;AAEA,iC;AACA,sB;AACA,kB;AACA,qB;AACA,yB;AACA,yB;AACA,wB;AACA,gB;AACA,iB;AACA,K;AACA,a;;AAEA,wB;AACA,sB;AACA,0D;AACA,sE;AACA,+C;AACA,Y;AACA,wC;AACA,8D;AACA,4C;AACA,oC;AACA,S;AACA,K;AACA,G;;AAEA,4D;AACA,gC;AACA,wB;AACA,sC;AACA,gB;AACA,4B;AACA,c;AACA,mB;AACA,O;AACA,O;AACA,G;;AAEA,iC;AACA,2C;AACA,kD;AACA,8B;AACA,oE;AACA,wE;AACA,2B;AACA,6C;AACA,gE;AACA,8C;AACA,sC;AACA,W;AACA,6D;AACA,c;AACA,mB;AACA,O;AACA,O;AACA,G;AACA,C;;AAEA,kD;AACA,kB;;AAEA,uB;AACA,sC;AACA,0B;AACA,mD;AACA,iB;AACA,wB;AACA,gB;AACA,gD;AACA,qC;AACA,S;AACA,S;AACA,a;AACA,U;AACA,Y;AACA,kB;AACA,yB;AACA,qC;AACA,6C;AACA,Q;AACA,4B;AACA,sB;AACA,O;AACA,O;AACA,G;AACA,E;;AAEA,sB;AACA,uB;AACA,8C;AACA,U;AACA,8B;AACA,wB;AACA,2D;AACA,0C;;AAEA,wB;AACA,qB;AACA,4C;AACA,iC;AACA,S;AACA,8C;AACA,O;AACA,K;AACA,G;AACA,C;;;;;;;;;;;;;;;;;;;ACjJA,wE;;AAEA,2D;AACA,8B;AACA,2B;AACA,uC;AACA,0B;AACA,E;;AAEA,+D;AACA,kB;AACA,uD;;AAEA,oD;AACA,sD;AACA,2C;AACA,K;;AAEA,kD;AACA,+E;AACA,kC;AACA,6E;AACA,6E;AACA,G;;AAEA,0C;AACA,E;;AAEA,4D;AACA,uD;AACA,oD;AACA,sC;;AAEA,2E;AACA,0B;AACA,E;;AAEA,uE;AACA,kC;AACA,E;;AAEA,iE;AACA,kB;AACA,8C;AACA,sB;AACA,iF;AACA,6B;AACA,kC;AACA,U;AACA,gC;AACA,G;;AAEA,uB;AACA,E;;AAEA,8D;AACA,oB;AACA,4B;AACA,wC;AACA,G;;AAEA,wC;AACA,wC;AACA,4C;AACA,E;;AAEA,2E;AACA,kB;AACA,2B;AACA,oD;;AAEA,wB;AACA,mC;AACA,oB;AACA,0C;AACA,wD;AACA,kD;AACA,yB;AACA,0C;AACA,O;AACA,yD;AACA,uB;AACA,gB;AACA,K;AACA,I;;AAEA,wB;AACA,E;;;;;;;;;;;;;;;;;;ACvFA,0B;;AAEA,E;;AAEA,wD;AACA,0C;AACA,qC;AACA,gB;AACA,E;;;;;;;;;;;;;;;;;;ACRA,yF;;AAEA,4C;AACA,kB;;AAEA,kC;AACA,qB;;AAEA,qC;AACA,gB;AACA,c;AACA,iB;AACA,iB;AACA,iB;AACA,mB;AACA,gB;AACA,6B;;AAEA,wE;AACA,oC;;AAEA,sC;AACA,sD;AACA,wC;AACA,uD;AACA,K;;AAEA,2B;AACA,E;;AAEA,wD;;AAEA,8D;AACA,+C;;AAEA,qC;AACA,2C;AACA,2B;AACA,0E;AACA,G;;AAEA,yC;AACA,E;;AAEA,mE;AACA,6C;AACA,uC;AACA,sC;AACA,uE;AACA,gC;AACA,iB;AACA,M;AACA,G;;AAEA,uD;;AAEA,qB;AACA,kC;AACA,iC;AACA,e;AACA,e;AACA,M;;AAEA,mD;AACA,2C;AACA,O;AACA,G;;AAEA,S;AACA,iD;AACA,2C;AACA,mB;AACA,gD;AACA,K;AACA,K;;AAEA,oC;AACA,kE;AACA,E;;AAEA,E;AACA,6B;;AAEA,kE;AACA,6F;AACA,E;AACA,mE;AACA,iB;AACA,sB;AACA,sB;AACA,I;;AAEA,oB;AACA,yD;AACA,kC;;AAEA,yC;AACA,yC;AACA,mD;AACA,sD;AACA,4C;AACA,oE;;AAEA,kD;AACA,qD;AACA,mD;AACA,kD;AACA,S;AACA,K;;AAEA,2D;AACA,G;;AAEA,iD;AACA,4D;;AAEA,iB;AACA,E;;;;;;;;;;;;;;;;;;;ACrHA,mD;;AAEA,0B;AACA,4B;AACA,0B;;AAEA,sC;AACA,sD;AACA,wC;AACA,uD;AACA,K;;AAEA,2B;AACA,C;;AAEA,0D;AACA,2D;AACA,uD;AACA,8B;AACA,6B;AACA,yD;;AAEA,iB;AACA,gC;AACA,yE;AACA,wC;AACA,kD;AACA,yB;AACA,6B;AACA,uB;AACA,c;AACA,I;;AAEA,2B;AACA,uD;AACA,E;;AAEA,uD;;AAEA,4D;AACA,oD;AACA,wD;AACA,2C;AACA,6D;;AAEA,uB;AACA,wC;AACA,yB;AACA,4C;AACA,U;AACA,kE;AACA,kC;AACA,mC;AACA,G;;AAEA,uC;AACA,iB;AACA,+B;AACA,2D;AACA,qB;AACA,2B;AACA,qD;AACA,0C;AACA,uB;AACA,K;AACA,kE;AACA,8C;AACA,gE;AACA,8C;AACA,G;AACA,E;;AAEA,mE;AACA,oD;AACA,mD;AACA,wD;AACA,2C;AACA,6B;AACA,yD;;AAEA,6D;AACA,4D;AACA,+D;AACA,0C;AACA,G;;AAEA,a;AACA,qC;AACA,G;AACA,E;;AAEA,mE;AACA,oD;AACA,mD;AACA,wD;AACA,2C;AACA,6B;AACA,yD;;AAEA,mB;;AAEA,a;AACA,qC;AACA,G;AACA,E;;AAEA,8G;AACA,yE;AACA,+C;AACA,6C;AACA,+D;;AAEA,0D;AACA,+B;AACA,2D;;AAEA,2B;AACA,iE;AACA,mD;AACA,2B;AACA,mD;AACA,4C;AACA,0C;AACA,2D;AACA,8B;AACA,0D;AACA,uC;AACA,4D;AACA,U;AACA,c;AACA,oD;AACA,O;AACA,K;AACA,G;AACA,E;;AAEA,sE;AACA,0C;;AAEA,qC;AACA,oC;AACA,iF;AACA,2B;AACA,c;AACA,M;AACA,G;;AAEA,uD;AACA,sD;AACA,c;AACA,gB;AACA,iB;AACA,0B;AACA,8B;AACA,gC;AACA,oB;AACA,oB;AACA,kB;AACA,wB;AACA,yB;AACA,0B;AACA,0B;AACA,oB;AACA,e;AACA,M;AACA,G;;AAEA,wD;AACA,E;;AAEA,4D;AACA,qC;AACA,E;;AAEA,yD;AACA,kB;AACA,sB;AACA,sB;AACA,yB;AACA,yB;AACA,0B;AACA,2B;;AAEA,wD;AACA,4D;AACA,6C;AACA,iD;AACA,G;;AAEA,sB;AACA,sD;AACA,sF;AACA,K;;AAEA,4B;AACA,uD;AACA,+F;AACA,K;;AAEA,U;AACA,2B;AACA,2B;AACA,2B;AACA,sC;AACA,I;;AAEA,+B;AACA,0D;AACA,yC;AACA,qC;AACA,yC;AACA,yC;AACA,qC;AACA,G;;AAEA,kD;AACA,2D;AACA,8B;AACA,G;;AAEA,8C;AACA,2D;AACA,2C;AACA,+E;AACA,K;AACA,G;;AAEA,kD;AACA,iE;AACA,qD;AACA,G;;AAEA,kD;AACA,iE;AACA,qD;AACA,G;;AAEA,6C;AACA,mE;AACA,qE;;AAEA,uD;AACA,yD;AACA,G;AACA,C;;AAEA,gE;AACA,6C;AACA,4B;;AAEA,iB;AACA,kB;AACA,I;;AAEA,qD;AACA,+C;AACA,+C;AACA,+C;AACA,2D;;AAEA,oB;AACA,sC;AACA,8C;AACA,0D;AACA,8E;;AAEA,0D;AACA,uE;AACA,wD;AACA,wD;AACA,+D;AACA,6C;AACA,2D;AACA,iE;;AAEA,gF;AACA,kD;AACA,uD;;AAEA,8F;AACA,wD;AACA,iE;AACA,iE;AACA,iE;AACA,6E;AACA,K;AACA,qD;AACA,G;;AAEA,iD;AACA,yD;;AAEA,iB;AACA,E;;AAEA,wE;AACA,mC;AACA,6B;AACA,iE;;AAEA,8D;AACA,e;AACA,2C;AACA,a;AACA,qD;AACA,uD;AACA,K;AACA,G;AACA,wE;AACA,yD;;AAEA,+B;AACA,wB;AACA,gB;AACA,kC;AACA,2B;AACA,G;AACA,C;;AAEA,6D;AACA,6B;AACA,2D;AACA,iC;AACA,C;;AAEA,6D;AACA,6B;AACA,2D;AACA,iC;AACA,C;;;;;;;;;;;;;;;;;;;ACzUA,2B;;AAEA,2B;AACA,kB;AACA,8B;AACA,uB;AACA,gD;;AAEA,O;AACA,+C;AACA,mE;AACA,e;AACA,4E;AACA,G;AACA,C;;AAEA,uD;;AAEA,iD;AACA,mB;AACA,uB;AACA,iE;AACA,oD;;AAEA,mE;AACA,2D;AACA,yC;AACA,uB;;AAEA,oC;AACA,2B;AACA,qB;AACA,4C;AACA,8C;AACA,kD;AACA,G;;AAEA,uB;AACA,oC;AACA,E;;AAEA,6C;AACA,iD;AACA,S;AACA,gE;AACA,iB;AACA,6C;AACA,oC;AACA,qB;AACA,2D;AACA,sD;AACA,8B;AACA,c;AACA,iB;AACA,O;AACA,K;AACA,G;AACA,E;;AAEA,sE;AACA,6C;AACA,kC;AACA,uD;AACA,wC;AACA,oC;AACA,K;AACA,G;AACA,iC;AACA,C;;AAEA,2D;AACA,uC;AACA,uB;AACA,G;AACA,C;;AAEA,2D;AACA,oD;AACA,4C;AACA,C;;AAEA,+E;;AAEA,iC;AACA,wK;;AAEA,iC;AACA,yI;;AAEA,kC;AACA,oC;AACA,8C;AACA,0E;AACA,uD;AACA,C;;;;;;;;;;;;;;;;;;;AC9FA,+B;AACA,4B;AACA,kB;AACA,qB;AACA,mB;AACA,8B;AACA,sB;AACA,C;;AAEA,sD;AACA,yD;;AAEA,gD;AACA,sC;AACA,8B;AACA,mB;AACA,2B;AACA,E;;AAEA,+C;AACA,sC;AACA,E;;AAEA,uD;AACA,0C;AACA,wB;AACA,6B;AACA,kD;AACA,gD;AACA,+E;AACA,sD;AACA,K;AACA,G;AACA,E;;AAEA,yD;AACA,wB;AACA,U;AACA,sB;AACA,qB;AACA,qB;AACA,oB;AACA,yC;AACA,iB;AACA,gC;AACA,a;AACA,G;AACA,E;;;;;;;;;;;;;;;;;;;AC/CA,+B;AACA,4C;AACA,gD;AACA,mC;;AAEA,mB;AACA,oB;AACA,c;AACA,2D;AACA,+C;AACA,E;AACA,+C;AACA,mB;AACA,iE;;AAEA,sD;AACA,0B;AACA,wB;AACA,gC;AACA,+D;AACA,oE;AACA,gD;AACA,kD;;AAEA,qD;AACA,wC;AACA,+E;AACA,G;;AAEA,yC;AACA,iD;AACA,uC;AACA,G;;AAEA,2B;AACA,gC;AACA,0C;AACA,iD;AACA,I;;AAEA,gD;AACA,2B;AACA,uE;AACA,2C;AACA,2C;AACA,8C;;AAEA,6B;AACA,4E;AACA,qC;AACA,sC;;AAEA,uD;AACA,sC;AACA,iB;AACA,8B;AACA,I;;AAEA,mC;AACA,iC;AACA,U;AACA,kC;AACA,G;;AAEA,0B;AACA,yC;AACA,iD;AACA,uC;AACA,wD;AACA,qD;AACA,2C;AACA,oC;AACA,O;AACA,wC;AACA,U;AACA,4D;AACA,G;;AAEA,0B;AACA,8B;AACA,8B;AACA,uB;AACA,I;;AAEA,4C;AACA,yC;AACA,0D;AACA,4B;AACA,K;;AAEA,oC;AACA,mD;AACA,wD;AACA,iB;AACA,K;AACA,E;;AAEA,4D;AACA,oC;AACA,gD;AACA,mD;AACA,2E;AACA,0E;AACA,yD;AACA,0C;AACA,0D;AACA,G;;AAEA,iB;AACA,C;;AAEA,0B;AACA,sF;AACA,sC;AACA,yE;AACA,C;;AAEA,6B;AACA,+C;AACA,oE;AACA,mD;AACA,6B;AACA,kD;AACA,yB;AACA,K;;AAEA,yB;AACA,qE;AACA,oB;AACA,wC;AACA,4D;AACA,4B;AACA,qB;AACA,+C;AACA,uF;AACA,gB;AACA,iC;AACA,S;AACA,c;AACA,+B;AACA,O;AACA,O;AACA,W;;AAEA,kC;AACA,oD;AACA,8D;AACA,wC;AACA,O;AACA,G;AACA,C;;AAEA,oC;AACA,oB;AACA,oC;AACA,gC;AACA,0B;AACA,2D;AACA,2E;AACA,kE;AACA,G;;AAEA,mD;AACA,sC;AACA,+D;AACA,K;;AAEA,gB;AACA,kC;AACA,0B;AACA,sB;AACA,K;AACA,C;;AAEA,2C;AACA,0B;AACA,qD;AACA,oC;AACA,C;;AAEA,2C;AACA,yB;AACA,yC;AACA,0C;AACA,e;AACA,4F;AACA,O;;AAEA,6B;AACA,O;AACA,W;AACA,C;;AAEA,6C;AACA,yC;AACA,yE;AACA,yB;AACA,gC;AACA,yD;AACA,wB;AACA,qB;AACA,K;;AAEA,a;;AAEA,uB;AACA,2B;AACA,uE;AACA,qD;AACA,iD;AACA,6E;AACA,S;;AAEA,oD;AACA,kC;AACA,uD;AACA,W;AACA,6B;AACA,iC;AACA,gB;AACA,wB;AACA,S;AACA,S;AACA,a;AACA,G;;AAEA,0B;AACA,oB;AACA,gD;AACA,8B;AACA,wD;AACA,Y;AACA,yB;AACA,gC;AACA,K;AACA,G;;AAEA,+B;AACA,uB;AACA,yB;AACA,G;AACA,C;;AAEA,iE;AACA,wE;AACA,6B;AACA,E;AACA,0D;AACA,yE;AACA,kE;AACA,gD;AACA,oB;AACA,gC;AACA,yC;AACA,K;AACA,qC;AACA,G;AACA,E;;AAEA,yD;AACA,kC;AACA,qC;AACA,E;;AAEA,0C;AACA,8D;AACA,4C;AACA,E;;AAEA,2C;AACA,+D;AACA,6C;AACA,E;;AAEA,uD;AACA,6D;AACA,4B;AACA,kD;AACA,0C;AACA,0D;AACA,iB;AACA,iB;AACA,+B;AACA,oB;AACA,oB;AACA,sC;AACA,+D;AACA,yB;AACA,M;AACA,iD;AACA,G;AACA,C;;AAEA,6C;AACA,yB;AACA,C;;;;;;;;;;;;;;;;;;;ACvSA,6B;AACA,gB;;AAEA,+C;AACA,0C;AACA,sB;AACA,Y;AACA,sC;AACA,gE;AACA,oE;AACA,K;AACA,I;;AAEA,2E;AACA,mC;AACA,kB;AACA,K;;AAEA,e;AACA,Y;AACA,kC;AACA,oE;AACA,oE;AACA,K;AACA,I;;AAEA,+E;AACA,uC;AACA,kC;AACA,mC;AACA,uB;AACA,kD;AACA,K;;AAEA,oB;AACA,Y;AACA,+B;AACA,mE;AACA,oE;AACA,K;AACA,G;;AAEA,c;AACA,E;;AAEA,+C;AACA,0C;AACA,kE;AACA,sB;AACA,Y;AACA,sC;AACA,gE;AACA,oE;AACA,K;AACA,I;;AAEA,c;AACA,E;;;AAGA,6B;AACA,oC;AACA,Y;AACA,qB;AACA,yE;AACA,kF;AACA,K;AACA,U;AACA,gB;AACA,G;AACA,E;;AAEA,uD;AACA,+C;AACA,Y;AACA,4B;AACA,0F;AACA,M;AACA,U;AACA,gB;AACA,G;AACA,E;;AAEA,wE;AACA,oC;AACA,2D;AACA,yB;AACA,S;AACA,sE;AACA,kB;AACA,iB;AACA,c;AACA,wC;AACA,8E;AACA,kE;AACA,Q;AACA,K;AACA,U;AACA,oE;AACA,gB;AACA,G;AACA,E;;AAEA,0D;AACA,kE;AACA,0D;AACA,S;AACA,wC;AACA,uC;AACA,4B;AACA,Q;AACA,kB;AACA,iB;AACA,c;AACA,uC;AACA,gF;AACA,0E;AACA,O;AACA,K;AACA,U;AACA,gB;AACA,G;AACA,E;;AAEA,iD;AACA,0C;AACA,sB;AACA,S;AACA,gE;AACA,kB;AACA,iB;AACA,wC;AACA,gB;AACA,uC;AACA,8E;AACA,uD;AACA,U;AACA,c;AACA,gB;AACA,O;AACA,K;AACA,G;AACA,c;AACA,E;;AAEA,+C;AACA,sC;AACA,Y;AACA,iC;AACA,kD;AACA,0F;AACA,M;AACA,G;;AAEA,c;AACA,E;;AAEA,gD;AACA,kE;AACA,0B;AACA,Y;AACA,kC;AACA,6D;AACA,6E;AACA,K;AACA,I;;AAEA,c;AACA,E;;AAEA,8C;AACA,kE;;AAEA,6B;AACA,Y;AACA,gC;AACA,4E;AACA,kF;AACA,K;AACA,I;;AAEA,c;AACA,E;;AAEA,yD;AACA,0C;;AAEA,wC;AACA,Y;AACA,4B;AACA,6F;AACA,8C;AACA,K;AACA,I;;AAEA,c;AACA,E;;AAEA,+D;AACA,qD;AACA,Y;AACA,4B;AACA,iE;AACA,oE;AACA,M;AACA,G;AACA,c;AACA,E;;AAEA,8D;AACA,uB;AACA,Y;AACA,2B;AACA,iH;AACA,qD;AACA,M;AACA,G;AACA,c;AACA,E;;AAEA,0B;AACA,iB;AACA,0B;AACA,6B;AACA,E;;AAEA,sB;AACA,oB;AACA,kB;AACA,mB;AACA,iB;AACA,4B;AACA,6B;AACA,0B;AACA,wB;AACA,E;;AAEA,uB;AACA,gC;AACA,gC;AACA,E;;AAEA,sE;AACA,uC;AACA,Y;AACA,4B;AACA,4F;AACA,8C;AACA,K;AACA,G;;AAEA,kF;AACA,uB;AACA,kB;AACA,G;;AAEA,qC;AACA,kD;AACA,0C;AACA,4C;AACA,sE;AACA,4B;AACA,uB;AACA,O;AACA,K;AACA,G;;AAEA,0E;AACA,uB;AACA,kB;AACA,G;;AAEA,U;AACA,4B;AACA,uE;AACA,gE;AACA,I;AACA,E;;AAEA,sE;AACA,8C;AACA,kC;AACA,6D;AACA,0B;AACA,qB;AACA,K;AACA,G;AACA,c;AACA,C;;;;;;;;;;;;;;;;;;;AChSA,mC;AACA,wD;AACA,+F;;AAEA,mB;;AAEA,E;;AAEA,gE;AACA,iD;AACA,qD;AACA,iD;AACA,mB;AACA,oC;AACA,wB;AACA,2B;AACA,e;AACA,c;AACA,I;;AAEA,2B;AACA,8B;AACA,gC;AACA,+B;AACA,2B;AACA,8B;AACA,U;AACA,gB;AACA,G;;AAEA,mB;AACA,E;;AAEA,0D;AACA,6D;AACA,+C;AACA,uE;AACA,iB;AACA,G;;AAEA,yB;AACA,qB;;AAEA,0D;AACA,+B;AACA,oC;AACA,gC;AACA,mB;AACA,K;AACA,6D;AACA,G;;AAEA,2C;AACA,Y;AACA,sB;AACA,G;;AAEA,+B;;AAEA,4C;AACA,iB;AACA,E;;AAEA,gE;AACA,mE;AACA,iD;AACA,sC;AACA,6C;AACA,c;AACA,wB;AACA,K;AACA,iC;AACA,8C;;AAEA,kC;AACA,gB;AACA,U;AACA,iB;AACA,G;AACA,E;;AAEA,qD;AACA,qD;AACA,E;;AAEA,qD;AACA,+C;AACA,iD;AACA,2B;AACA,mC;AACA,oB;AACA,O;AACA,gB;AACA,G;AACA,e;AACA,E;;AAEA,mD;AACA,uC;AACA,gE;AACA,2B;;AAEA,kC;AACA,qD;AACA,gB;AACA,wE;AACA,2C;AACA,kE;AACA,gB;AACA,U;AACA,uB;AACA,kD;AACA,iC;;AAEA,mB;AACA,0C;AACA,M;;AAEA,4B;;AAEA,8B;AACA,2E;AACA,qC;;AAEA,8D;AACA,gD;AACA,4C;AACA,4C;AACA,wD;AACA,yE;AACA,qB;AACA,0E;AACA,oB;AACA,2D;AACA,qH;AACA,oB;AACA,c;AACA,6D;AACA,kE;AACA,wE;AACA,2C;AACA,iE;AACA,wD;AACA,+C;AACA,O;AACA,K;;AAEA,+E;AACA,uE;;AAEA,4C;AACA,0D;AACA,wC;;AAEA,sD;AACA,gC;AACA,uC;AACA,uC;AACA,qB;AACA,G;AACA,E;;AAEA,6B;;;;;;;;;;;;;;;;;;;AClKA,+C;;AAEA,6C;AACA,0B;;AAEA,qD;AACA,gD;AACA,sE;;AAEA,6D;AACA,sB;AACA,+C;AACA,4B;AACA,0B;AACA,yB;;AAEA,yB;;AAEA,gD;AACA,qB;AACA,E;;AAEA,kD;AACA,iD;AACA,mC;AACA,oD;AACA,6E;AACA,oD;AACA,4B;AACA,8B;AACA,G;AACA,E;;AAEA,kD;AACA,iC;AACA,yB;;AAEA,qD;AACA,kC;AACA,oD;AACA,K;AACA,gB;AACA,E;;AAEA,0C;AACA,mF;AACA,E;;AAEA,yC;AACA,4B;AACA,wC;AACA,G;AACA,E;;AAEA,uD;AACA,oC;AACA,uD;AACA,iC;AACA,mC;;AAEA,0D;AACA,sE;AACA,kC;AACA,4C;AACA,6C;;AAEA,2C;AACA,K;AACA,U;AACA,0E;AACA,G;AACA,E;;AAEA,kD;AACA,kB;AACA,sB;AACA,2B;AACA,gC;AACA,I;;AAEA,gC;AACA,2D;AACA,qD;AACA,6E;;AAEA,sD;AACA,8B;AACA,+C;AACA,4E;AACA,6B;AACA,sD;AACA,K;;AAEA,4E;AACA,8B;;AAEA,mC;AACA,qD;;AAEA,uC;AACA,8C;AACA,K;;AAEA,2B;AACA,sC;AACA,K;;AAEA,sB;AACA,qB;AACA,E;;AAEA,+D;AACA,a;AACA,uC;AACA,4D;AACA,U;AACA,iB;AACA,G;AACA,E;;AAEA,E;AACA,uC;AACA,E;AACA,0E;AACA,wC;AACA,gD;AACA,gE;;AAEA,wB;AACA,E;;AAEA,sD;AACA,4D;AACA,e;AACA,K;AACA,8C;AACA,E;;AAEA,8D;AACA,6C;AACA,oB;AACA,2B;AACA,U;AACA,0B;AACA,6C;AACA,G;AACA,E;;AAEA,iE;AACA,2E;AACA,8C;;AAEA,a;AACA,E;;AAEA,+D;AACA,sB;AACA,gC;AACA,I;AACA,E;;AAEA,uD;AACA,6B;AACA,kB;AACA,wC;AACA,qB;AACA,O;AACA,mC;AACA,U;AACA,a;AACA,G;AACA,E;;;;;;;;;;;;;;;;;;;AC3KA,kC;;AAEA,oC;AACA,wD;AACA,sD;AACA,kD;AACA,0B;AACA,6E;AACA,K;AACA,I;AACA,E;;;;;;;;;;;;;;;;;;;ACVA,sC;AACA,2D;AACA,+C;AACA,0B;AACA,wB;AACA,yB;AACA,2B;AACA,Q;;AAEA,mD;AACA,0D;AACA,sD;;AAEA,4C;AACA,oF;AACA,kE;AACA,wF;AACA,uC;AACA,sC;;AAEA,8B;AACA,uE;AACA,8B;AACA,oD;AACA,S;AACA,O;;AAEA,wC;AACA,4D;AACA,K;;AAEA,kD;AACA,I;;AAEA,kD;AACA,oE;AACA,kE;AACA,oB;AACA,iB;AACA,sC;AACA,gC;;AAEA,qB;AACA,8D;AACA,mF;;AAEA,uE;AACA,4E;AACA,4D;AACA,O;AACA,c;AACA,oB;AACA,I;;AAEA,+C;AACA,6D;AACA,+D;AACA,oB;AACA,iB;AACA,sC;AACA,gC;;AAEA,qB;AACA,8D;AACA,mF;;AAEA,uE;AACA,4E;AACA,wD;AACA,O;AACA,c;AACA,oB;AACA,I;;AAEA,+C;AACA,iE;AACA,iE;AACA,uE;AACA,gE;AACA,c;AACA,oB;AACA,I;;AAEA,oD;AACA,uC;AACA,qC;AACA,6B;AACA,yC;AACA,qB;AACA,4D;;AAEA,yD;AACA,mD;AACA,qE;AACA,oC;AACA,wE;AACA,S;;AAEA,qD;AACA,uE;AACA,c;AACA,oE;AACA,uB;AACA,mG;AACA,U;AACA,0D;AACA,O;;AAEA,sB;AACA,gC;AACA,+D;AACA,mD;;AAEA,wE;AACA,yD;AACA,0D;AACA,0D;AACA,8D;AACA,8D;AACA,S;;AAEA,6C;AACA,+D;AACA,8B;AACA,O;AACA,K;;AAEA,wC;AACA,I;;AAEA,2C;AACA,0E;AACA,8C;AACA,mE;AACA,sB;AACA,wE;AACA,0D;AACA,+C;;AAEA,wB;AACA,oE;AACA,yD;AACA,+D;AACA,kD;AACA,8B;AACA,8C;AACA,sC;AACA,iD;AACA,U;;AAEA,sE;AACA,uH;;AAEA,0C;AACA,8C;AACA,mB;AACA,c;AACA,mE;AACA,O;AACA,M;AACA,K;AACA,E;;AAEA,qD;AACA,uE;AACA,kF;AACA,G;;AAEA,mD;AACA,2C;AACA,sC;AACA,6C;AACA,wD;AACA,K;AACA,mC;AACA,E;;;AAGA,sE;AACA,gC;AACA,Q;AACA,oD;AACA,iB;AACA,6B;AACA,4C;;AAEA,sC;AACA,sB;AACA,O;AACA,e;AACA,K;AACA,G;AACA,C;;AAEA,0B;AACA,mC;AACA,2D;AACA,U;AACA,0C;AACA,G;;AAEA,wD;AACA,kB;AACA,C;;;;;;;;;;;;;;;;;;;AC3MA,kC;;AAEA,gD;AACA,+E;AACA,iF;AACA,yD;AACA,8C;AACA,uC;AACA,qB;AACA,qC;AACA,M;AACA,kC;AACA,G;;AAEA,8C;AACA,wC;AACA,2D;AACA,0C;AACA,gC;AACA,8D;AACA,+B;AACA,kE;AACA,mE;AACA,gC;AACA,qE;AACA,oE;AACA,uB;AACA,mG;AACA,U;AACA,0D;AACA,+D;AACA,O;;AAEA,mE;AACA,mC;AACA,K;;AAEA,+D;AACA,uD;AACA,6B;AACA,I;;AAEA,8C;AACA,2C;AACA,uC;;AAEA,mE;AACA,mD;;AAEA,wD;AACA,2E;AACA,6D;AACA,M;AACA,mE;;AAEA,+D;AACA,6D;AACA,0D;AACA,uD;AACA,mD;AACA,O;AACA,K;;AAEA,mE;AACA,2D;AACA,kC;AACA,I;;AAEA,yD;AACA,8C;AACA,0D;AACA,kC;AACA,I;;AAEA,qC;AACA,8D;AACA,mD;AACA,wE;AACA,sB;;AAEA,mE;AACA,8E;AACA,mC;AACA,oE;AACA,mC;AACA,M;AACA,iB;AACA,M;AACA,K;AACA,E;;;;;;;;;;;;;;;;;;;ACzFA,0C;AACA,yC;AACA,gC;AACA,2B;AACA,gC;AACA,4C;AACA,I;;AAEA,gC;AACA,2B;AACA,2D;AACA,iE;AACA,K;;AAEA,mC;AACA,I;AACA,E;;AAEA,4C;AACA,2C;AACA,iC;AACA,2B;AACA,iC;AACA,4C;AACA,I;;AAEA,gC;AACA,2B;AACA,2D;AACA,iE;AACA,K;;AAEA,mC;AACA,I;AACA,E;;AAEA,mC;AACA,4D;AACA,yD;AACA,oC;AACA,6C;AACA,K;;AAEA,gD;AACA,0D;;AAEA,sC;AACA,0E;AACA,K;AACA,gD;AACA,I;AACA,E;;AAEA,qB;AACA,6D;AACA,kE;AACA,wF;AACA,qF;AACA,6D;AACA,+C;;AAEA,sC;AACA,2C;AACA,wB;AACA,8C;AACA,yE;AACA,0C;AACA,yB;AACA,sC;AACA,sC;AACA,U;;AAEA,6D;AACA,8C;AACA,6D;AACA,O;AACA,Y;AACA,wE;AACA,K;AACA,G;;AAEA,a;AACA,C;;;;;;;;;;;;;;;;;;AClFA,2D;;AAEA,iD;AACA,yB;AACA,uC;AACA,yC;AACA,mD;;AAEA,gC;AACA,+D;AACA,G;;AAEA,kC;AACA,mE;AACA,G;;AAEA,2B;AACA,mD;AACA,G;;AAEA,c;AACA,a;AACA,E;;;;;;;;;;;;;;;;;;;ACtBA,6D;;AAEA,qD;AACA,6B;AACA,6F;AACA,gD;AACA,2E;AACA,4B;AACA,mB;AACA,qB;AACA,iB;AACA,M;;AAEA,0B;AACA,uC;AACA,+D;AACA,iB;AACA,+C;AACA,mD;AACA,8B;AACA,kD;AACA,Y;AACA,8C;AACA,kD;AACA,K;;AAEA,uC;AACA,oB;AACA,yE;AACA,K;;AAEA,mF;AACA,qF;AACA,mB;AACA,Q;AACA,oD;AACA,uE;AACA,0B;;AAEA,wC;AACA,gC;AACA,O;;AAEA,4B;AACA,sE;AACA,kD;AACA,sD;AACA,sD;AACA,iD;AACA,gB;AACA,uC;AACA,S;AACA,mC;AACA,qC;AACA,O;;AAEA,mB;AACA,sE;AACA,O;AACA,iB;AACA,mB;AACA,6E;AACA,O;AACA,e;AACA,K;;AAEA,e;AACA,I;AACA,G;;AAEA,gD;AACA,oG;AACA,uC;AACA,kC;AACA,oD;AACA,mB;AACA,6C;AACA,2D;AACA,iB;AACA,kB;AACA,M;;AAEA,mC;AACA,mF;AACA,iC;AACA,kC;AACA,sC;AACA,wC;AACA,S;AACA,+B;AACA,O;AACA,M;;AAEA,uC;AACA,oB;AACA,yE;AACA,K;;AAEA,Q;AACA,oD;;AAEA,uB;AACA,yD;AACA,2B;AACA,8B;AACA,8C;AACA,+D;AACA,+C;AACA,6D;;AAEA,8B;AACA,8E;;AAEA,sE;AACA,2D;AACA,8B;AACA,6D;AACA,iE;AACA,qF;AACA,sC;AACA,yB;AACA,sE;AACA,0C;;AAEA,uF;AACA,2C;AACA,wE;AACA,a;AACA,W;AACA,S;;AAEA,4B;AACA,yC;AACA,qF;AACA,gD;AACA,oD;AACA,wD;AACA,S;AACA,kD;AACA,oC;AACA,yC;AACA,O;;AAEA,mB;AACA,mE;AACA,O;AACA,iB;AACA,iB;AACA,mB;AACA,6E;AACA,O;AACA,e;AACA,K;AACA,I;AACA,G;;;;;;;;;;;;;;;;;;;AC1JA,6B;;AAEA,mC;AACA,qC;AACA,kB;AACA,4F;AACA,G;;AAEA,O;AACA,uD;;AAEA,yG;AACA,yD;AACA,oG;AACA,iB;AACA,oE;AACA,K;AACA,oB;AACA,e;AACA,iB;AACA,2E;AACA,K;AACA,a;AACA,G;AACA,E;;;;;;;;;;;;;;;;;;ACxBA,8B;;AAEA,gC;AACA,qC;AACA,kB;AACA,iE;AACA,G;AACA,O;AACA,+C;AACA,iB;AACA,wD;AACA,K;AACA,e;AACA,e;AACA,iB;AACA,2E;AACA,K;AACA,a;AACA,G;AACA,E;;;;;;;;;;;;;;;;;;ACnBA,mC;;AAEA,iC;AACA,2B;AACA,qC;AACA,kB;AACA,kE;AACA,iB;AACA,2C;AACA,K;AACA,G;;AAEA,kB;AACA,E;;AAEA,uC;AACA,sC;AACA,wB;AACA,2C;AACA,+D;AACA,4B;AACA,G;AACA,8B;AACA,E;;;;;;;;;;;;;;;;;;;ACvBA,uC;AACA,kD;AACA,0C;AACA,yB;AACA,a;AACA,K;;AAEA,kE;AACA,6C;AACA,gB;AACA,K;;AAEA,oE;AACA,qD;AACA,2C;AACA,gB;AACA,K;;AAEA,mE;AACA,+C;AACA,qC;AACA,0B;AACA,sB;AACA,O;;AAEA,wC;AACA,sB;AACA,gB;;AAEA,8B;AACA,gD;AACA,uD;AACA,sD;AACA,mC;AACA,mE;AACA,4B;AACA,kB;AACA,S;AACA,K;AACA,K;AACA,C;;AAEA,gC;AACA,0C;AACA,6C;AACA,6C;AACA,4D;AACA,K;;AAEA,gF;AACA,+E;AACA,8B;AACA,yB;AACA,Y;AACA,6D;AACA,4B;AACA,uC;AACA,4B;AACA,wE;AACA,qD;AACA,O;AACA,K;;AAEA,sD;AACA,G;AACA,C;;AAEA,uC;AACA,U;AACA,e;AACA,qB;AACA,sB;AACA,kB;AACA,oC;AACA,a;AACA,uB;AACA,qE;AACA,M;AACA,c;AACA,c;AACA,K;AACA,I;AACA,C;;;;;;;;;;;;;;;;;;;AClFA,2B;;AAEA,gB;AACA,mD;AACA,kC;AACA,mB;AACA,0B;AACA,0C;AACA,Y;AACA,yC;AACA,K;AACA,G;AACA,G;;AAEA,oD;AACA,gC;AACA,yB;;AAEA,Y;AACA,0E;AACA,qC;AACA,+E;AACA,G;;AAEA,O;AACA,uF;AACA,sD;AACA,yC;AACA,sD;;AAEA,2B;AACA,yD;AACA,0D;AACA,2C;AACA,I;AACA,+C;AACA,wF;AACA,uC;;AAEA,4E;AACA,e;AACA,sE;AACA,a;AACA,G;AACA,E;;AAEA,+D;AACA,2C;AACA,8G;AACA,G;;AAEA,yB;AACA,uB;AACA,oD;AACA,G;AACA,0E;AACA,uD;;AAEA,kE;AACA,uD;AACA,4C;;AAEA,4D;AACA,E;;AAEA,+E;AACA,wD;AACA,kC;AACA,yB;AACA,iD;AACA,4B;AACA,+B;AACA,G;;AAEA,8C;;AAEA,uC;AACA,wC;AACA,iB;AACA,uC;AACA,gD;AACA,I;AACA,6D;AACA,C;;;;;;;;;;;;;;;;;;ACnFA,yB;AACA,gC;AACA,oD;AACA,uE;AACA,wC;AACA,G;;AAEA,8C;AACA,yC;AACA,uE;AACA,0D;AACA,qE;AACA,uD;AACA,8C;AACA,K;AACA,G;;AAEA,kC;AACA,iE;AACA,2F;AACA,+C;AACA,G;;AAEA,gC;AACA,sE;AACA,sG;AACA,yD;AACA,G;;AAEA,gC;AACA,sE;AACA,yH;AACA,4E;AACA,G;;AAEA,gC;AACA,sE;AACA,2G;AACA,8D;AACA,G;;AAEA,sB;AACA,gE;AACA,8F;AACA,4D;AACA,G;;AAEA,wB;AACA,oE;AACA,kG;AACA,8D;AACA,G;;AAEA,wB;AACA,oE;AACA,0F;AACA,sD;AACA,G;;AAEA,6B;AACA,oE;AACA,6E;AACA,wD;AACA,G;;AAEA,yB;AACA,4D;AACA,qE;AACA,oD;AACA,G;;AAEA,2B;AACA,gE;AACA,yE;AACA,sD;AACA,G;;AAEA,2B;AACA,gE;AACA,yE;AACA,sD;AACA,G;;AAEA,oC;AACA,kF;AACA,2F;AACA,+D;AACA,G;;AAEA,6B;AACA,oE;AACA,6E;AACA,wD;AACA,G;;AAEA,4B;AACA,kE;AACA,2E;AACA,uD;AACA,G;;AAEA,yB;AACA,oE;AACA,8F;AACA,gE;AACA,G;;AAEA,uB;AACA,gE;AACA,qF;AACA,yD;AACA,G;AACA,C;;;;;;;;;;;;;;;;;;;AChHA,0C;AACA,gE;AACA,iB;AACA,8B;AACA,iC;AACA,I;;AAEA,+B;AACA,sG;AACA,I;AACA,E;;AAEA,oC;AACA,G;AACA,2B;AACA,iC;AACA,kC;AACA,G;AACA,iB;AACA,kC;AACA,qC;AACA,wC;AACA,I;;AAEA,+B;AACA,gG;AACA,I;AACA,C;;;;;;;;;;;;;;;;;;AC3BA,wB;AACA,sD;AACA,uB;AACA,E;;AAEA,uB;AACA,wD;AACA,4C;AACA,mB;AACA,Y;AACA,kB;AACA,K;AACA,I;;AAEA,qD;AACA,qD;AACA,wC;AACA,gC;AACA,qB;AACA,O;AACA,K;AACA,gB;AACA,G;AACA,E;;;;;;;;;;;;;;;;;;ACvBA,kD;AACA,0B;AACA,uF;AACA,G;;AAEA,uD;AACA,gD;AACA,qB;AACA,yB;AACA,gB;AACA,kB;AACA,wB;AACA,wB;AACA,K;;AAEA,+C;AACA,c;;AAEA,2B;AACA,wB;AACA,2C;AACA,Y;AACA,kE;AACA,iC;AACA,K;AACA,G;;AAEA,mB;AACA,wE;AACA,e;AACA,uB;AACA,mC;AACA,6C;AACA,c;AACA,qE;AACA,O;AACA,O;AACA,G;AACA,E;;AAEA,sC;AACA,oE;AACA,E;;AAEA,6D;AACA,U;AACA,iB;AACA,kB;AACA,oC;AACA,kC;AACA,0B;AACA,oB;AACA,M;AACA,6B;AACA,gC;AACA,K;AACA,M;AACA,C;;AAEA,6D;AACA,uC;AACA,oC;AACA,wB;AACA,uB;AACA,oB;AACA,yC;AACA,M;;AAEA,iE;AACA,e;AACA,sE;AACA,gD;AACA,c;AACA,sB;AACA,S;AACA,O;AACA,W;AACA,C","sourcesContent":["Kadira = {};\nKadira.options = {};\n\nif(Meteor.wrapAsync) {\n  Kadira._wrapAsync = Meteor.wrapAsync;\n} else {\n  Kadira._wrapAsync = Meteor._wrapAsync;\n}\n\nKadira._binaryRequire = function(moduleName) {\n  if(typeof KadiraBinaryDeps != 'undefined') {\n    return KadiraBinaryDeps.require(moduleName);\n  } else {\n    return Npm.require(moduleName);\n  }\n};","BaseErrorModel = function(options) {\n  this._filters = [];\n};\n\nBaseErrorModel.prototype.addFilter = function(filter) {\n  if(typeof filter === 'function') {\n    this._filters.push(filter);\n  } else {\n    throw new Error(\"Error filter must be a function\");\n  }\n};\n\nBaseErrorModel.prototype.removeFilter = function(filter) {\n  var index = this._filters.indexOf(filter);\n  if(index >= 0) {\n    this._filters.splice(index, 1);\n  }\n};\n\nBaseErrorModel.prototype.applyFilters = function(type, message, error, subType) {\n  for(var lc=0; lc<this._filters.length; lc++) {\n    var filter = this._filters[lc];\n    try {\n      var validated = filter(type, message, error, subType);\n      if(!validated) return false;\n    } catch (ex) {\n      // we need to remove this filter\n      // we may ended up in a error cycle\n      this._filters.splice(lc, 1);\n      throw new Error(\"an error thrown from a filter you've suplied\", ex.message);\n    }\n  }\n\n  return true;\n};","Jobs = {};\nJobs.getAsync = function(id, callback) {\n  var payload = {\n    action: 'get',\n    params: {\n      id: id\n    }\n  };\n\n  Kadira.send(payload, '/jobs', callback);\n};\n\nJobs.setAsync = function(id, changes, callback) {\n  var payload = {\n    action: 'set',\n    params: {\n      id: id\n    }\n  };\n  _.extend(payload.params, changes);\n\n  Kadira.send(payload, '/jobs', callback);\n};\n\n\nJobs.get = Kadira._wrapAsync(Jobs.getAsync);\nJobs.set = Kadira._wrapAsync(Jobs.setAsync);","// Retry logic with an exponential backoff.\n//\n// options:\n//  baseTimeout: time for initial reconnect attempt (ms).\n//  exponent: exponential factor to increase timeout each attempt.\n//  maxTimeout: maximum time between retries (ms).\n//  minCount: how many times to reconnect \"instantly\".\n//  minTimeout: time to wait for the first `minCount` retries (ms).\n//  fuzz: factor to randomize retry times by (to avoid retry storms).\n\n//TODO: remove this class and use Meteor Retry in a later version of meteor.\n\nRetry = function (options) {\n  var self = this;\n  _.extend(self, _.defaults(_.clone(options || {}), {\n    baseTimeout: 1000, // 1 second\n    exponent: 2.2,\n    // The default is high-ish to ensure a server can recover from a\n    // failure caused by load.\n    maxTimeout: 5 * 60000, // 5 minutes\n    minTimeout: 10,\n    minCount: 2,\n    fuzz: 0.5 // +- 25%\n  }));\n  self.retryTimer = null;\n};\n\n_.extend(Retry.prototype, {\n\n  // Reset a pending retry, if any.\n  clear: function () {\n    var self = this;\n    if(self.retryTimer)\n      clearTimeout(self.retryTimer);\n    self.retryTimer = null;\n  },\n\n  // Calculate how long to wait in milliseconds to retry, based on the\n  // `count` of which retry this is.\n  _timeout: function (count) {\n    var self = this;\n\n    if(count < self.minCount)\n      return self.minTimeout;\n\n    var timeout = Math.min(\n      self.maxTimeout,\n      self.baseTimeout * Math.pow(self.exponent, count));\n    // fuzz the timeout randomly, to avoid reconnect storms when a\n    // server goes down.\n    timeout = timeout * ((Random.fraction() * self.fuzz) +\n                         (1 - self.fuzz/2));\n    return Math.ceil(timeout);\n  },\n\n  // Call `fn` after a delay, based on the `count` of which retry this is.\n  retryLater: function (count, fn) {\n    var self = this;\n    var timeout = self._timeout(count);\n    if(self.retryTimer)\n      clearTimeout(self.retryTimer);\n\n    self.retryTimer = setTimeout(fn, timeout);\n    return timeout;\n  }\n\n});\n","var Fiber = Npm.require('fibers');\n\nHaveAsyncCallback = function(args) {\n  var lastArg = args[args.length -1];\n  return (typeof lastArg) == 'function';\n};\n\nUniqueId = function(start) {\n  this.id = 0;\n}\n\nUniqueId.prototype.get = function() {\n  return \"\" + this.id++;\n};\n\nDefaultUniqueId = new UniqueId();\n","var logger = getLogger();\n\nNtp = function (endpoint) {\n  this.setEndpoint(endpoint);\n  this.diff = 0;\n  this.synced = false;\n  this.reSyncCount = 0;\n  this.reSync = new Retry({\n    baseTimeout: 1000*60,\n    maxTimeout: 1000*60*10,\n    minCount: 0\n  });\n}\n\nNtp._now = function() {\n  var now = Date.now();\n  if(typeof now == 'number') {\n    return now;\n  } else if(now instanceof Date) {\n    // some extenal JS libraries override Date.now and returns a Date object\n    // which directly affect us. So we need to prepare for that\n    return now.getTime();\n  } else {\n    // trust me. I've seen now === undefined\n    return (new Date()).getTime();\n  }\n};\n\nNtp.prototype.setEndpoint = function(endpoint) {\n  this.endpoint = endpoint + '/simplentp/sync';\n};\n\nNtp.prototype.getTime = function() {\n  return Ntp._now() + Math.round(this.diff);\n};\n\nNtp.prototype.syncTime = function(localTime) {\n  return localTime + Math.ceil(this.diff);\n};\n\nNtp.prototype.sync = function() {\n  logger('init sync');\n  var self = this;\n  var retryCount = 0;\n  var retry = new Retry({\n    baseTimeout: 1000*20,\n    maxTimeout: 1000*60,\n    minCount: 1,\n    minTimeout: 0\n  });\n  syncTime();\n\n  function syncTime () {\n    if(retryCount<5) {\n      logger('attempt time sync with server', retryCount);\n      // if we send 0 to the retryLater, cacheDns will run immediately\n      retry.retryLater(retryCount++, cacheDns);\n    } else {\n      logger('maximum retries reached');\n      self.reSync.retryLater(self.reSyncCount++, function () {\n        var args = [].slice.call(arguments);\n        self.sync.apply(self, args);\n      });\n    }\n  }\n\n  // first attempt is to cache dns. So, calculation does not\n  // include DNS resolution time\n  function cacheDns () {\n    self.getServerTime(function(err) {\n      if(!err) {\n        calculateTimeDiff();\n      } else {\n        syncTime();\n      }\n    });\n  }\n\n  function calculateTimeDiff () {\n    var startTime = (new Date()).getTime();\n    self.getServerTime(function(err, serverTime) {\n      if(!err && serverTime) {\n        // (Date.now() + startTime)/2 : Midpoint between req and res\n        self.diff = serverTime - ((new Date()).getTime() + startTime)/2;\n        self.synced = true;\n        // we need to send 1 into retryLater.\n        self.reSync.retryLater(self.reSyncCount++, function () {\n          var args = [].slice.call(arguments);\n          self.sync.apply(self, args);\n        });\n        logger('successfully updated diff value', self.diff);\n      } else {\n        syncTime();\n      }\n    });\n  }\n}\n\nNtp.prototype.getServerTime = function(callback) {\n  var self = this;\n\n  if(Meteor.isServer) {\n    var Fiber = Npm.require('fibers');\n    new Fiber(function() {\n      HTTP.get(self.endpoint, function (err, res) {\n        if(err) {\n          callback(err);\n        } else {\n          var serverTime = parseInt(res.content)\n          callback(null, serverTime);\n        }\n      });\n    }).run();\n  } else {\n    $.ajax({\n      type: 'GET',\n      url: self.endpoint,\n      success: function(serverTime) {\n        callback(null, parseInt(serverTime));\n      },\n      error: function(err) {\n        callback(err);\n      }\n    });\n  }\n};\n\nfunction getLogger() {\n  if(Meteor.isServer) {\n    return Npm.require('debug')(\"kadira:ntp\");\n  } else {\n    return function(message) {\n      var canLogKadira =\n        Meteor._localStorage.getItem('LOG_KADIRA') !== null\n        && typeof console !== 'undefined';\n\n      if(canLogKadira) {\n        if(message) {\n          message = \"kadira:ntp \" + message;\n          arguments[0] = message;\n        }\n        console.log.apply(console, arguments);\n      }\n    }\n  }\n}\n","var WAITON_MESSAGE_FIELDS = ['msg', 'id', 'method', 'name', 'waitTime'];\n\n// This is way how we can build waitTime and it's breakdown\nWaitTimeBuilder = function() {\n  this._waitListStore = {};\n  this._currentProcessingMessages = {};\n  this._messageCache = {};\n};\n\nWaitTimeBuilder.prototype.register = function(session, msgId) {\n  var self = this;\n  var mainKey = self._getMessageKey(session.id, msgId);\n\n  var waitList = session.inQueue.map(function(msg) {\n    var key = self._getMessageKey(session.id, msg.id);\n    return self._getCacheMessage(key, msg);\n  });\n\n  //add currently processing ddp message if exists\n  var currentlyProcessingMessage = this._currentProcessingMessages[session.id];\n  if(currentlyProcessingMessage) {\n    var key = self._getMessageKey(session.id, currentlyProcessingMessage.id);\n    waitList.unshift(this._getCacheMessage(key, currentlyProcessingMessage));\n  }\n\n  this._waitListStore[mainKey] = waitList;\n};\n\nWaitTimeBuilder.prototype.build = function(session, msgId) {\n  var mainKey = this._getMessageKey(session.id, msgId);\n  var waitList = this._waitListStore[mainKey] || [];\n  delete this._waitListStore[mainKey];\n\n  var filteredWaitList =  waitList.map(this._cleanCacheMessage.bind(this));\n  return filteredWaitList;\n};\n\nWaitTimeBuilder.prototype._getMessageKey = function(sessionId, msgId) {\n  return sessionId + \"::\" + msgId;\n};\n\nWaitTimeBuilder.prototype._getCacheMessage = function(key, msg) {\n  var self = this;\n  var cachedMessage = self._messageCache[key];\n  if(!cachedMessage) {\n    self._messageCache[key] = cachedMessage = _.pick(msg, WAITON_MESSAGE_FIELDS);\n    cachedMessage._key = key;\n    cachedMessage._registered = 1;\n  } else {\n    cachedMessage._registered++;\n  }\n\n  return cachedMessage;\n};\n\nWaitTimeBuilder.prototype._cleanCacheMessage = function(msg) {\n  msg._registered--;\n  if(msg._registered == 0) {\n    delete this._messageCache[msg._key];\n  }\n\n  // need to send a clean set of objects\n  // otherwise register can go with this\n  return _.pick(msg, WAITON_MESSAGE_FIELDS);\n};\n\nWaitTimeBuilder.prototype.trackWaitTime = function(session, msg, unblock) {\n  var self = this;\n  var started = Date.now();\n  self._currentProcessingMessages[session.id] = msg;\n\n  var unblocked = false;\n  var wrappedUnblock = function() {\n    if(!unblocked) {\n      var waitTime = Date.now() - started;\n      var key = self._getMessageKey(session.id, msg.id);\n      var cachedMessage = self._messageCache[key];\n      if(cachedMessage) {\n        cachedMessage.waitTime = waitTime;\n      }\n      delete self._currentProcessingMessages[session.id];\n      unblocked = true;\n      unblock();\n    }\n  };\n\n  return wrappedUnblock;\n};","KadiraModel = function() {\n\n};\n\nKadiraModel.prototype._getDateId = function(timestamp) {\n  var remainder = timestamp % (1000 * 60);\n  var dateId = timestamp - remainder;\n  return dateId;\n};","var METHOD_METRICS_FIELDS = ['wait', 'db', 'http', 'email', 'async', 'compute', 'total'];\n\nMethodsModel = function (metricsThreshold) {\n  var self = this;\n\n  this.methodMetricsByMinute = {};\n  this.errorMap = {};\n\n  this._metricsThreshold = _.extend({\n    \"wait\": 100,\n    \"db\": 100,\n    \"http\": 1000,\n    \"email\": 100,\n    \"async\": 100,\n    \"compute\": 100,\n    \"total\": 200\n  }, metricsThreshold || {});\n\n  //store max time elapsed methods for each method, event(metrics-field)\n  this.maxEventTimesForMethods = {};\n\n  this.tracerStore = new TracerStore({\n    interval: 1000 * 60, //process traces every minute\n    maxTotalPoints: 30, //for 30 minutes\n    archiveEvery: 5 //always trace for every 5 minutes,\n  });\n\n  this.tracerStore.start();\n};\n\n_.extend(MethodsModel.prototype, KadiraModel.prototype);\n\nMethodsModel.prototype.processMethod = function(methodTrace) {\n  var dateId = this._getDateId(methodTrace.at);\n\n  //append metrics to previous values\n  this._appendMetrics(dateId, methodTrace);\n  if(methodTrace.errored) {\n    this.methodMetricsByMinute[dateId].methods[methodTrace.name].errors ++\n  }\n\n  this.tracerStore.addTrace(methodTrace);\n};\n\nMethodsModel.prototype._appendMetrics = function(id, methodTrace) {\n  //initialize meteric for this time interval\n  if(!this.methodMetricsByMinute[id]) {\n    this.methodMetricsByMinute[id] = {\n      // startTime needs to be converted into serverTime before sending\n      startTime: methodTrace.at,\n      methods: {}\n    };\n  }\n\n  var methods = this.methodMetricsByMinute[id].methods;\n\n  //initialize method\n  if(!methods[methodTrace.name]) {\n    methods[methodTrace.name] = {\n      count: 0,\n      errors: 0\n    };\n\n    METHOD_METRICS_FIELDS.forEach(function(field) {\n      methods[methodTrace.name][field] = 0;\n    });\n  }\n\n  //merge\n  METHOD_METRICS_FIELDS.forEach(function(field) {\n    var value = methodTrace.metrics[field];\n    if(value > 0) {\n      methods[methodTrace.name][field] += value;\n    }\n  });\n\n  methods[methodTrace.name].count++;\n  this.methodMetricsByMinute[id].endTime = methodTrace.metrics.at;\n};\n\n/*\n  There are two types of data\n\n  1. methodMetrics - metrics about the methods (for every 10 secs)\n  2. methodRequests - raw method request. normally max, min for every 1 min and errors always\n*/\nMethodsModel.prototype.buildPayload = function(buildDetailedInfo) {\n  var payload = {\n    methodMetrics: [],\n    methodRequests: []\n  };\n\n  //handling metrics\n  var methodMetricsByMinute = this.methodMetricsByMinute;\n  this.methodMetricsByMinute = {};\n\n  //create final paylod for methodMetrics\n  for(var key in methodMetricsByMinute) {\n    var methodMetrics = methodMetricsByMinute[key];\n    // converting startTime into the actual serverTime\n    var startTime = methodMetrics.startTime;\n    methodMetrics.startTime = Kadira.syncedDate.syncTime(startTime);\n\n    for(var methodName in methodMetrics.methods) {\n      METHOD_METRICS_FIELDS.forEach(function(field) {\n        methodMetrics.methods[methodName][field] /=\n          methodMetrics.methods[methodName].count;\n      });\n    }\n\n    payload.methodMetrics.push(methodMetricsByMinute[key]);\n  }\n\n  //collect traces and send them with the payload\n  payload.methodRequests = this.tracerStore.collectTraces();\n\n  return payload;\n};\n","var logger = Npm.require('debug')('kadira:pubsub');\n\nPubsubModel = function() {\n  this.metricsByMinute = {};\n  this.subscriptions = {};\n\n  this.tracerStore = new TracerStore({\n    interval: 1000 * 60, //process traces every minute\n    maxTotalPoints: 30, //for 30 minutes\n    archiveEvery: 5 //always trace for every 5 minutes,\n  });\n\n  this.tracerStore.start();\n}\n\nPubsubModel.prototype._trackSub = function(session, msg) {\n  logger('SUB:', session.id, msg.id, msg.name, msg.params);\n  var publication = this._getPublicationName(msg.name);\n  var subscriptionId = msg.id;\n  var timestamp = Ntp._now();\n  var metrics = this._getMetrics(timestamp, publication);\n\n  metrics.subs++;\n  this.subscriptions[msg.id] = {\n    // We use localTime here, because when we used synedTime we might get\n    // minus or more than we've expected\n    //   (before serverTime diff changed overtime)\n    startTime: timestamp,\n    publication: publication,\n    params: msg.params,\n    id: msg.id\n  };\n\n  //set session startedTime\n  session._startTime = session._startTime || timestamp;\n};\n\n_.extend(PubsubModel.prototype, KadiraModel.prototype);\n\nPubsubModel.prototype._trackUnsub = function(session, sub) {\n  logger('UNSUB:', session.id, sub._subscriptionId);\n  var publication = this._getPublicationName(sub._name);\n  var subscriptionId = sub._subscriptionId;\n  var subscriptionState = this.subscriptions[subscriptionId];\n\n  var startTime = null;\n  //sometime, we don't have these states\n  if(subscriptionState) {\n    startTime = subscriptionState.startTime;\n  } else {\n    //if this is null subscription, which is started automatically\n    //hence, we don't have a state\n    startTime = session._startTime;\n  }\n\n  //in case, we can't get the startTime\n  if(startTime) {\n    var timestamp = Ntp._now();\n    var metrics = this._getMetrics(timestamp, publication);\n    //track the count\n    if(sub._name != null) {\n      // we can't track subs for `null` publications.\n      // so we should not track unsubs too\n      metrics.unsubs++;\n    }\n    //use the current date to get the lifeTime of the subscription\n    metrics.lifeTime += timestamp - startTime;\n    //this is place we can clean the subscriptionState if exists\n    delete this.subscriptions[subscriptionId];\n  }\n};\n\nPubsubModel.prototype._trackReady = function(session, sub, trace) {\n  logger('READY:', session.id, sub._subscriptionId);\n  //use the current time to track the response time\n  var publication = this._getPublicationName(sub._name);\n  var subscriptionId = sub._subscriptionId;\n  var timestamp = Ntp._now();\n  var metrics = this._getMetrics(timestamp, publication);\n\n  var subscriptionState = this.subscriptions[subscriptionId];\n  if(subscriptionState && !subscriptionState.readyTracked) {\n    metrics.resTime += timestamp - subscriptionState.startTime;\n    subscriptionState.readyTracked = true;\n  }\n\n  if(trace) {\n    this.tracerStore.addTrace(trace);\n  }\n};\n\nPubsubModel.prototype._trackError = function(session, sub, trace) {\n  logger('ERROR:', session.id, sub._subscriptionId);\n  //use the current time to track the response time\n  var publication = this._getPublicationName(sub._name);\n  var subscriptionId = sub._subscriptionId;\n  var timestamp = Ntp._now();\n  var metrics = this._getMetrics(timestamp, publication);\n\n  metrics.errors++;\n\n  if(trace) {\n    this.tracerStore.addTrace(trace);\n  }\n};\n\nPubsubModel.prototype._trackNetworkImpact = function(session, sub, event, collection, id, stringifiedFields) {\n  logger('DI:' + event, session.id, sub._subscriptionId, collection, id);\n  if(event != 'removed' && stringifiedFields) {\n    var subscriptionId = sub._subscriptionId;\n    var subscriptionState = this.subscriptions[subscriptionId];\n\n    var publication = this._getPublicationName(sub._name);\n    var timestamp = Ntp._now();\n    var metrics = this._getMetrics(timestamp, publication);\n\n    if(subscriptionState) {\n      var sendingDataSize = Buffer.byteLength(stringifiedFields);\n      sub._totalDocsSent = sub._totalDocsSent || 0;\n      sub._totalDocsSent++;\n      sub._totalDataSent = sub._totalDataSent || 0;\n      sub._totalDataSent += sendingDataSize;\n      if(subscriptionState.readyTracked) {\n        //using JSON instead of EJSON to save the CPU usage\n        if(event == 'added') {\n          metrics.bytesAddedAfterReady += sendingDataSize;\n        } else if(event == 'changed') {\n          metrics.bytesChangedAfterReady += sendingDataSize;\n        };\n      } else {\n        metrics.bytesBeforeReady += sendingDataSize;\n      }\n    }\n  }\n};\n\nPubsubModel.prototype._getMetrics = function(timestamp, publication) {\n  var dateId = this._getDateId(timestamp);\n\n  if(!this.metricsByMinute[dateId]) {\n    this.metricsByMinute[dateId] = {\n      // startTime needs to be convert to serverTime before sending to the server\n      startTime: timestamp,\n      pubs: {}\n    };\n  }\n\n  if(!this.metricsByMinute[dateId].pubs[publication]) {\n    this.metricsByMinute[dateId].pubs[publication] = {\n      subs: 0,\n      unsubs: 0,\n      resTime: 0,\n      bytesBeforeReady: 0,\n      bytesAddedAfterReady: 0,\n      bytesChangedAfterReady: 0,\n      activeSubs: 0,\n      activeDocs: 0,\n      lifeTime: 0,\n      totalObservers: 0,\n      cachedObservers: 0,\n      createdObservers: 0,\n      deletedObservers: 0,\n      avgDocSize: 0,\n      errors: 0\n    };\n  }\n\n  return this.metricsByMinute[dateId].pubs[publication];\n};\n\nPubsubModel.prototype._getPublicationName = function(name) {\n  return name || \"null(autopublish)\";\n};\n\nPubsubModel.prototype._getSubscriptionInfo = function() {\n  var self = this;\n  var activeSubs = {};\n  var activeDocs = {};\n  var totalDocsSent = {};\n  var totalDataSent = {};\n  var totalObservers = {};\n  var cachedObservers = {};\n\n  for(var sessionId in Meteor.default_server.sessions) {\n    var session = Meteor.default_server.sessions[sessionId];\n    _.each(session._namedSubs, countSubData);\n    _.each(session._universalSubs, countSubData);\n  }\n\n  var avgDocSize = {};\n  _.each(totalDataSent, function(value, publication) {\n    avgDocSize[publication] = totalDataSent[publication] / totalDocsSent[publication];\n  });\n\n  var avgObserverReuse = {};\n  _.each(totalObservers, function(value, publication) {\n    avgObserverReuse[publication] = cachedObservers[publication] / totalObservers[publication];\n  });\n\n  return {\n    activeSubs: activeSubs,\n    activeDocs: activeDocs,\n    avgDocSize: avgDocSize,\n    avgObserverReuse: avgObserverReuse\n  };\n\n  function countSubData (sub) {\n    var publication = self._getPublicationName(sub._name);\n    countSubscriptions(sub, publication);\n    countDocuments(sub, publication);\n    countTotalDocsSent(sub, publication);\n    countTotalDataSent(sub, publication);\n    countObservers(sub, publication);\n  }\n\n  function countSubscriptions (sub, publication) {\n    activeSubs[publication] = activeSubs[publication] || 0;\n    activeSubs[publication]++;\n  }\n\n  function countDocuments (sub, publication) {\n    activeDocs[publication] = activeDocs[publication] || 0;\n    for(collectionName in sub._documents) {\n      activeDocs[publication] += _.keys(sub._documents[collectionName]).length;\n    }\n  }\n\n  function countTotalDocsSent (sub, publication) {\n    totalDocsSent[publication] = totalDocsSent[publication] || 0;\n    totalDocsSent[publication] += sub._totalDocsSent;\n  }\n\n  function countTotalDataSent (sub, publication) {\n    totalDataSent[publication] = totalDataSent[publication] || 0;\n    totalDataSent[publication] += sub._totalDataSent;\n  }\n\n  function countObservers(sub, publication) {\n    totalObservers[publication] = totalObservers[publication] || 0;\n    cachedObservers[publication] = cachedObservers[publication] || 0;\n\n    totalObservers[publication] += sub._totalObservers;\n    cachedObservers[publication] += sub._cachedObservers;\n  }\n}\n\nPubsubModel.prototype.buildPayload = function(buildDetailInfo) {\n  var metricsByMinute = this.metricsByMinute;\n  this.metricsByMinute = {};\n\n  var payload = {\n    pubMetrics: []\n  };\n\n  var subscriptionData = this._getSubscriptionInfo();\n  var activeSubs = subscriptionData.activeSubs;\n  var activeDocs = subscriptionData.activeDocs;\n  var avgDocSize = subscriptionData.avgDocSize;\n  var avgObserverReuse = subscriptionData.avgObserverReuse;\n\n  //to the averaging\n  for(var dateId in metricsByMinute) {\n    var dateMetrics = metricsByMinute[dateId];\n    // We need to convert startTime into actual serverTime\n    dateMetrics.startTime = Kadira.syncedDate.syncTime(dateMetrics.startTime);\n\n    for(var publication in metricsByMinute[dateId].pubs) {\n      var singlePubMetrics = metricsByMinute[dateId].pubs[publication];\n      // We only calculate resTime for new subscriptions\n      singlePubMetrics.resTime /= singlePubMetrics.subs;\n      singlePubMetrics.resTime = singlePubMetrics.resTime || 0;\n      // We only track lifeTime in the unsubs\n      singlePubMetrics.lifeTime /= singlePubMetrics.unsubs;\n      singlePubMetrics.lifeTime = singlePubMetrics.lifeTime || 0;\n\n      // This is a very efficient solution. We can come up with another solution\n      // which maintains the count inside the API.\n      // But for now, this is the most reliable method.\n\n      // If there are two ore more dateIds, we will be using the currentCount for all of them.\n      // We can come up with a better solution later on.\n      singlePubMetrics.activeSubs = activeSubs[publication] || 0;\n      singlePubMetrics.activeDocs = activeDocs[publication] || 0;\n      singlePubMetrics.avgDocSize = avgDocSize[publication] || 0;\n      singlePubMetrics.avgObserverReuse = avgObserverReuse[publication] || 0;\n    }\n    payload.pubMetrics.push(metricsByMinute[dateId]);\n  }\n\n  //collect traces and send them with the payload\n  payload.pubRequests = this.tracerStore.collectTraces();\n\n  return payload;\n};\n\nPubsubModel.prototype.incrementHandleCount = function(trace, isCached) {\n  var publicationName = trace.name;\n  var timestamp = Ntp._now();\n  var publication = this._getMetrics(timestamp, publicationName);\n\n  var session = Meteor.default_server.sessions[trace.session];\n  if(session) {\n    var sub = session._namedSubs[trace.id];\n    if(sub) {\n      sub._totalObservers = sub._totalObservers || 0;\n      sub._cachedObservers = sub._cachedObservers || 0;\n    }\n  }\n  // not sure, we need to do this? But I don't need to break the however\n  sub = sub || {_totalObservers:0 , _cachedObservers: 0};\n\n  publication.totalObservers++;\n  sub._totalObservers++;\n  if(isCached) {\n    publication.cachedObservers++;\n    sub._cachedObservers++;\n  }\n}\n\nPubsubModel.prototype.trackCreatedObserver = function(info) {\n  var timestamp = Ntp._now();\n  var publication = this._getMetrics(timestamp, info.name);\n  publication.createdObservers++;\n}\n\nPubsubModel.prototype.trackDeletedObserver = function(info) {\n  var timestamp = Ntp._now();\n  var publication = this._getMetrics(timestamp, info.name);\n  publication.deletedObservers++;\n}\n","var os = Npm.require('os');\n\nSystemModel = function () {\n  var self = this;\n  this.startTime = Ntp._now();\n  this.newSessions = 0;\n  this.sessionTimeout = 1000 * 60 * 30; //30 min\n\n  try {\n    var usage = Kadira._binaryRequire('usage');\n    this.usageLookup = Kadira._wrapAsync(usage.lookup.bind(usage));\n  } catch(ex) {\n    console.error('Kadira: usage npm module loading failed - ', ex.message);\n  }\n}\n\n_.extend(SystemModel.prototype, KadiraModel.prototype);\n\nSystemModel.prototype.buildPayload = function() {\n  var metrics = {};\n  var now = Ntp._now();\n  metrics.startTime = Kadira.syncedDate.syncTime(this.startTime);\n  metrics.endTime = Kadira.syncedDate.syncTime(now);\n\n  metrics.sessions = _.keys(Meteor.default_server.sessions).length;\n  metrics.memory = process.memoryUsage().rss / (1024*1024);\n  metrics.newSessions = this.newSessions;\n  this.newSessions = 0;\n\n  var usage = this.getUsage() || {};\n  metrics.pcpu = usage.cpu;\n  if(usage.cpuInfo) {\n    metrics.cputime = usage.cpuInfo.cpuTime;\n    metrics.pcpuUser = usage.cpuInfo.pcpuUser;\n    metrics.pcpuSystem = usage.cpuInfo.pcpuSystem;\n  }\n\n  this.startTime = now;\n  return {systemMetrics: [metrics]};\n};\n\nSystemModel.prototype.getUsage = function() {\n  if(this.usageLookup && !this._dontTrackUsage) {\n    try {\n      return this.usageLookup(process.pid, {keepHistory: true});\n    } catch(ex) {\n      if(/Unsupported OS/.test(ex.message)) {\n        this._dontTrackUsage = true;\n        var message =\n          \"kadira: we can't track CPU usage in this OS. \" +\n          \"But it will work when you deploy your app!\"\n        console.warn(message);\n      } else {\n        throw ex;\n      }\n    }\n  }\n};\n\nSystemModel.prototype.handleSessionActivity = function(msg, session) {\n  if(msg.msg === 'connect' && !msg.session) {\n    this.countNewSession(session);\n  } else if(['sub', 'method'].indexOf(msg.msg) != -1) {\n    if(!this.isSessionActive(session)) {\n      this.countNewSession(session);\n    }\n  }\n  session._activeAt = Date.now();\n}\n\nSystemModel.prototype.countNewSession = function(session) {\n  if(!isLocalAddress(session.socket)) {\n    this.newSessions++;\n  }\n}\n\nSystemModel.prototype.isSessionActive = function(session) {\n  var inactiveTime = Date.now() - session._activeAt;\n  return inactiveTime < this.sessionTimeout;\n}\n\n// ------------------------------------------------------------------------- //\n\n// http://regex101.com/r/iF3yR3/2\nvar isLocalHostRegex = /^(?:.*\\.local|localhost)(?:\\:\\d+)?|127(?:\\.\\d{1,3}){3}|192\\.168(?:\\.\\d{1,3}){2}|10(?:\\.\\d{1,3}){3}|172\\.(?:1[6-9]|2\\d|3[0-1])(?:\\.\\d{1,3}){2}$/;\n\n// http://regex101.com/r/hM5gD8/1\nvar isLocalAddressRegex = /^127(?:\\.\\d{1,3}){3}|192\\.168(?:\\.\\d{1,3}){2}|10(?:\\.\\d{1,3}){3}|172\\.(?:1[6-9]|2\\d|3[0-1])(?:\\.\\d{1,3}){2}$/;\n\nfunction isLocalAddress (socket) {\n  var host = socket.headers['host'];\n  if(host) return isLocalHostRegex.test(host);\n  var address = socket.headers['x-forwarded-for'] || socket.remoteAddress;\n  if(address) return isLocalAddressRegex.test(address);\n}\n","ErrorModel = function (appId) {\n  BaseErrorModel.call(this);\n  var self = this;\n  this.appId = appId;\n  this.errors = {};\n  this.startTime = Date.now();\n  this.maxErrors = 10;\n}\n\n_.extend(ErrorModel.prototype, KadiraModel.prototype);\n_.extend(ErrorModel.prototype, BaseErrorModel.prototype);\n\nErrorModel.prototype.buildPayload = function() {\n  var metrics = _.values(this.errors);\n  this.startTime = Date.now();\n  this.errors = {};\n  return {errors: metrics};\n};\n\nErrorModel.prototype.errorCount = function () {\n  return _.values(this.errors).length;\n};\n\nErrorModel.prototype.trackError = function(ex, trace) {\n  var key = trace.type + ':' + ex.message;\n  if(this.errors[key]) {\n    this.errors[key].count++;\n  } else if (this.errorCount() < this.maxErrors) {\n    var errorDef = this._formatError(ex, trace);\n    if(this.applyFilters(errorDef.type, errorDef.name, ex, errorDef.subType)) {\n      this.errors[key] = this._formatError(ex, trace);\n    }\n  }\n};\n\nErrorModel.prototype._formatError = function(ex, trace) {\n  var time = Date.now();\n  return {\n    appId: this.appId,\n    name: ex.message,\n    type: trace.type,\n    startTime: time,\n    subType: trace.subType || trace.name,\n    trace: trace,\n    stacks: [{stack: ex.stack}],\n    count: 1,\n  }\n};\n","var http = Npm.require('http');\nvar hostname = Npm.require('os').hostname();\nvar logger = Npm.require('debug')('kadira:apm');\nvar Fibers = Npm.require('fibers');\n\nKadira.models = {};\nKadira.options = {};\nKadira.env = {\n  currentSub: null, // keep current subscription inside ddp\n  kadiraInfo: new Meteor.EnvironmentVariable(),\n};\nKadira.waitTimeBuilder = new WaitTimeBuilder();\nKadira.errors = [];\nKadira.errors.addFilter = Kadira.errors.push.bind(Kadira.errors);\n\nKadira.connect = function(appId, appSecret, options) {\n  options = options || {};\n  options.appId = appId;\n  options.appSecret = appSecret;\n  options.payloadTimeout = options.payloadTimeout || 1000 * 20;\n  options.endpoint = options.endpoint || \"https://engine.kadira.io\";\n  options.thresholds = options.thresholds || {};\n  options.hostname = options.hostname || hostname;\n\n  // remove trailing slash from endpoint url (if any)\n  if(_.last(options.endpoint) === '/') {\n    options.endpoint = options.endpoint.substr(0, options.endpoint.length - 1);\n  }\n\n  // error tracking is enabled by default\n  if(options.enableErrorTracking === undefined) {\n    options.enableErrorTracking = true;\n  }\n\n  Kadira.options = options;\n  Kadira.options.authHeaders = {\n    'KADIRA-APP-ID': Kadira.options.appId,\n    'KADIRA-APP-SECRET': Kadira.options.appSecret\n  };\n\n  Kadira.syncedDate = new Ntp(options.endpoint);\n  Kadira.syncedDate.sync();\n  Kadira.models.methods = new MethodsModel(options.thresholds.methods);\n  Kadira.models.pubsub = new PubsubModel();\n  Kadira.models.system = new SystemModel();\n  Kadira.models.error = new ErrorModel(appId);\n\n  // handle pre-added filters\n  var addFilterFn = Kadira.models.error.addFilter.bind(Kadira.models.error);\n  Kadira.errors.forEach(addFilterFn);\n  Kadira.errors = Kadira.models.error;\n\n  // setting runtime info, which will be sent to kadira\n  __meteor_runtime_config__.kadira = {\n    appId: appId,\n    endpoint: options.endpoint\n  };\n\n  if(options.enableErrorTracking) {\n    Kadira.enableErrorTracking();\n  } else {\n    Kadira.disableErrorTracking();\n  }\n\n  if(appId && appSecret) {\n    options.appId = options.appId.trim();\n    options.appSecret = options.appSecret.trim();\n    Kadira._pingToCheckAuth(function(){\n      // it takes time to calculate version 'sha' values\n      // it'll be ready when Meteor.startup is called\n      Meteor.startup(Kadira._sendAppStats);\n      Kadira._schedulePayloadSend();\n    });\n    logger('connected to app: ', appId);\n  } else {\n    throw new Error('Kadira: required appId and appSecret');\n  }\n\n  // start tracking errors\n  Meteor.startup(function () {\n    TrackUncaughtExceptions();\n    TrackMeteorDebug();\n  })\n\n  //start wrapping Meteor's internal methods\n  Kadira._startInstrumenting(function() {\n    console.log('Kadira: completed instrumenting the app')\n    Kadira.connected = true;\n  });\n\n  Meteor.publish(null, function () {\n    var options = __meteor_runtime_config__.kadira;\n    this.added('kadira_settings', Random.id(), options);\n    this.ready();\n  });\n};\n\n//track how many times we've sent the data (once per minute)\nKadira._buildPayload = function () {\n  var payload = {host: Kadira.options.hostname};\n  var buildDetailedInfo = Kadira._isDetailedInfo();\n  _.extend(payload, Kadira.models.methods.buildPayload(buildDetailedInfo));\n  _.extend(payload, Kadira.models.pubsub.buildPayload(buildDetailedInfo));\n  _.extend(payload, Kadira.models.system.buildPayload());\n  if(Kadira.options.enableErrorTracking) {\n    _.extend(payload, Kadira.models.error.buildPayload());\n  }\n\n  return payload;\n}\n\nKadira._countDataSent = 0;\nKadira._detailInfoSentInterval = Math.ceil((1000*60) / Kadira.options.payloadTimeout);\nKadira._isDetailedInfo = function () {\n  return (Kadira._countDataSent++ % Kadira._detailInfoSentInterval) == 0;\n}\n\nKadira.authCheckFailures = 0;\nKadira._pingToCheckAuth = function (callback) {\n  var httpOptions = {headers: Kadira.options.authHeaders, data: {}};\n  var endpoint = Kadira.options.endpoint + '/ping';\n  var authRetry = new Retry({\n    minCount: 0, // don't do any immediate retries\n    baseTimeout: 5 * 1000\n  });\n\n  new Fibers(function() {\n    HTTP.call('POST', endpoint, httpOptions, function(err, response){\n      if(response) {\n        if(response.statusCode == 200) {\n          console.log('Kadira: successfully authenticated');\n          authRetry.clear();\n          callback();\n        } else if(response.statusCode == 401) {\n          console.error('Kadira: authentication failed - check your appId & appSecret')\n        } else {\n          retryPingToCheckAuth();\n        }\n      } else {\n        retryPingToCheckAuth();\n      }\n    });\n  }).run();\n\n  function retryPingToCheckAuth(){\n    console.log('Kadira: retrying to authenticate');\n    authRetry.retryLater(Kadira.authCheckFailures, function(){\n      Kadira._pingToCheckAuth(callback);\n    });\n  }\n}\n\nKadira._sendAppStats = function () {\n  var appStats = {};\n  appStats.release = Meteor.release;\n  appStats.packageVersions = [];\n  appStats.appVersions = {\n    webapp: __meteor_runtime_config__['autoupdateVersion'],\n    refreshable: __meteor_runtime_config__['autoupdateVersionRefreshable'],\n    cordova: __meteor_runtime_config__['autoupdateVersionCordova']\n  }\n\n  // TODO get version number for installed packages\n  _.each(Package, function (v, name) {\n    appStats.packageVersions.push({name: name, version: null});\n  });\n\n  Kadira._send({\n    host: Kadira.options.hostname,\n    startTime: new Date(),\n    appStats: appStats\n  });\n}\n\nKadira._schedulePayloadSend = function () {\n  setTimeout(function () {\n    Kadira._sendPayload(Kadira._schedulePayloadSend);\n  }, Kadira.options.payloadTimeout);\n}\n\nKadira._sendPayload = function (callback) {\n  new Fibers(function() {\n    var payload = Kadira._buildPayload();\n    Kadira._send(payload, function (err) {\n      if(err) {\n        console.error('Kadira: Error sending payload (dropped after 5 tries)', err.message);\n      }\n\n      callback && callback();\n    });\n  }).run();\n}\n\nKadira._send = function (payload, callback) {\n  var endpoint = Kadira.options.endpoint;\n  var httpOptions = {headers: Kadira.options.authHeaders, data: payload};\n  var payloadRetries = 0;\n  var payloadRetry = new Retry({\n    minCount: 0, // don't do any immediate payloadRetries\n    baseTimeout: 5*1000,\n    maxTimeout: 60000\n  });\n\n  callHTTP();\n\n  function callHTTP() {\n    new Fibers(function() {\n      HTTP.call('POST', endpoint, httpOptions, function(err, response){\n        if(response && response.statusCode === 401) {\n          // do not retry if authentication fails\n          throw new Error('Kadira: AppId, AppSecret combination is invalid');\n        }\n\n        if(response && response.statusCode == 200) {\n          if(payloadRetries > 0) {\n            logger('connected again and payload sent.')\n          }\n          cleaPayloadRetry();\n          callback && callback();\n        } else {\n          tryAgain(err);\n        }\n      });\n    }).run();\n  }\n\n  function tryAgain(err) {\n    err = err || {};\n    logger('retrying to send payload to server')\n    if(++payloadRetries < 5) {\n      payloadRetry.retryLater(payloadRetries, callHTTP);\n    } else {\n      cleaPayloadRetry();\n      callback && callback(err);\n    }\n  }\n\n  function cleaPayloadRetry() {\n    payloadRetries = 0;\n    payloadRetry.clear();\n  }\n}\n\n// this return the __kadiraInfo from the current Fiber by default\n// if called with 2nd argument as true, it will get the kadira info from\n// Meteor.EnvironmentVariable\n//\n// WARNNING: returned info object is the reference object.\n//  Changing it might cause issues when building traces. So use with care\nKadira._getInfo = function(currentFiber, useEnvironmentVariable) {\n  currentFiber = currentFiber || Fibers.current;\n  if(currentFiber) {\n    if(useEnvironmentVariable) {\n      return Kadira.env.kadiraInfo.get();\n    }\n    return currentFiber.__kadiraInfo;\n  }\n};\n\n// this does not clone the info object. So, use with care\nKadira._setInfo = function(info) {\n  Fibers.current.__kadiraInfo = info;\n};\n\nKadira.enableErrorTracking = function () {\n  __meteor_runtime_config__.kadira.enableErrorTracking = true;\n  Kadira.options.enableErrorTracking = true;\n};\n\nKadira.disableErrorTracking = function () {\n  __meteor_runtime_config__.kadira.enableErrorTracking = false;\n  Kadira.options.enableErrorTracking = false;\n};\n\nKadira.trackError = function (type, message, options) {\n  if(Kadira.options.enableErrorTracking && type && message) {\n    options = options || {};\n    options.subType = options.subType || 'server';\n    options.stacks = options.stacks || '';\n    var error = {message: message, stack: options.stacks};\n    var trace = {\n      type: type,\n      subType: options.subType,\n      name: message,\n      errored: true,\n      at: Kadira.syncedDate.getTime(),\n      events: [['start', 0, {}], ['error', 0, {error: error}]],\n      metrics: {total: 0}\n    };\n    Kadira.models.error.trackError(error, trace);\n  }\n}\n\nKadira.ignoreErrorTracking = function (err) {\n  err._skipKadira = true;\n}\n","// expose for testing purpose\nOplogCheck = {};\n\nOplogCheck._070 = function(cursorDescription) {\n  var options = cursorDescription.options;\n  if (options.limit) {\n    return {\n      code: \"070_LIMIT_NOT_SUPPORTED\",\n      reason: \"Meteor 0.7.0 does not support limit with oplog.\",\n      solution: \"Upgrade your app to Meteor version 0.7.2 or later.\"\n    }\n  };\n\n  var exists$ = _.any(cursorDescription.selector, function (value, field) {\n    if (field.substr(0, 1) === '$')\n      return true;\n  });\n\n  if(exists$) {\n    return {\n      code: \"070_$_NOT_SUPPORTED\",\n      reason: \"Meteor 0.7.0 supports only equal checks with oplog.\",\n      solution: \"Upgrade your app to Meteor version 0.7.2 or later.\"\n    }\n  };\n\n  var onlyScalers = _.all(cursorDescription.selector, function (value, field) {\n    return typeof value === \"string\" ||\n      typeof value === \"number\" ||\n      typeof value === \"boolean\" ||\n      value === null ||\n      value instanceof Meteor.Collection.ObjectID;\n  });\n\n  if(!onlyScalers) {\n    return {\n      code: \"070_ONLY_SCALERS\",\n      reason: \"Meteor 0.7.0 only supports scalers as comparators.\",\n      solution: \"Upgrade your app to Meteor version 0.7.2 or later.\"\n    }\n  }\n\n  return true;\n};\n\nOplogCheck._071 = function(cursorDescription) {\n  var options = cursorDescription.options;\n  var matcher = new Minimongo.Matcher(cursorDescription.selector);\n  if (options.limit) {\n    return {\n      code: \"071_LIMIT_NOT_SUPPORTED\",\n      reason: \"Meteor 0.7.1 does not support limit with oplog.\",\n      solution: \"Upgrade your app to Meteor version 0.7.2 or later.\"\n    }\n  };\n\n  return true;\n};\n\n\nOplogCheck.env = function() {\n  if(!process.env.MONGO_OPLOG_URL) {\n    return {\n      code: \"NO_ENV\",\n      reason: \"You haven't added oplog support for your the Meteor app.\",\n      solution: \"Add oplog support for your Meteor app. see: http://goo.gl/Co1jJc\"\n    }\n  } else {\n    return true;\n  }\n};\n\nOplogCheck.disableOplog = function(cursorDescription) {\n  if(cursorDescription.options._disableOplog) {\n    return {\n      code: \"DISABLE_OPLOG\",\n      reason: \"You've disable oplog for this cursor explicitly with _disableOplog option.\"\n    };\n  } else {\n    return true;\n  }\n};\n\n// when creating Minimongo.Matcher object, if that's throws an exception\n// meteor won't do the oplog support\nOplogCheck.miniMongoMatcher = function(cursorDescription) {\n  if(Minimongo.Matcher) {\n    try {\n      var matcher = new Minimongo.Matcher(cursorDescription.selector);\n      return true;\n    } catch(ex) {\n      return {\n        code: \"MINIMONGO_MATCHER_ERROR\",\n        reason: \"There's something wrong in your mongo query: \" +  ex.message,\n        solution: \"Check your selector and change it accordingly.\"\n      };\n    }\n  } else {\n    // If there is no Minimongo.Matcher, we don't need to check this\n    return true;\n  }\n};\n\nOplogCheck.miniMongoSorter = function(cursorDescription) {\n  var matcher = new Minimongo.Matcher(cursorDescription.selector);\n  if(Minimongo.Sorter && cursorDescription.options.sort) {\n    try {\n      var sorter = new Minimongo.Sorter(\n        cursorDescription.options.sort,\n        { matcher: matcher }\n      );\n      return true;\n    } catch(ex) {\n      return {\n        code: \"MINIMONGO_SORTER_ERROR\",\n        reason: \"Some of your sort specifiers are not supported: \" + ex.message,\n        solution: \"Check your sort specifiers and chage them accordingly.\"\n      }\n    }\n  } else {\n    return true;\n  }\n};\n\nOplogCheck.fields = function(cursorDescription) {\n  var options = cursorDescription.options;\n  if(options.fields) {\n    try {\n      LocalCollection._checkSupportedProjection(options.fields);\n      return true;\n    } catch (e) {\n      if (e.name === \"MinimongoError\") {\n        return {\n          code: \"NOT_SUPPORTED_FIELDS\",\n          reason: \"Some of the field filters are not supported: \" + e.message,\n          solution: \"Try removing those field filters.\"\n        };\n      } else {\n        throw e;\n      }\n    }\n  }\n  return true;\n};\n\nOplogCheck.skip = function(cursorDescription) {\n  if(cursorDescription.options.skip) {\n    return {\n      code: \"SKIP_NOT_SUPPORTED\",\n      reason: \"Skip does not support with oplog.\",\n      solution: \"Try to avoid using skip. Use range queries instead: http://goo.gl/b522Av\"\n    };\n  }\n\n  return true;\n};\n\nOplogCheck.where = function(cursorDescription) {\n  var matcher = new Minimongo.Matcher(cursorDescription.selector);\n  if(matcher.hasWhere()) {\n    return {\n      code: \"WHERE_NOT_SUPPORTED\",\n      reason: \"Meteor does not support queries with $where.\",\n      solution: \"Try to remove $where from your query. Use some alternative.\"\n    }\n  };\n\n  return true;\n};\n\nOplogCheck.geo = function(cursorDescription) {\n  var matcher = new Minimongo.Matcher(cursorDescription.selector);\n\n  if(matcher.hasGeoQuery()) {\n    return {\n      code: \"GEO_NOT_SUPPORTED\",\n      reason: \"Meteor does not support queries with geo partial operators.\",\n      solution: \"Try to remove geo partial operators from your query if possible.\"\n    }\n  };\n\n  return true;\n};\n\nOplogCheck.limitButNoSort = function(cursorDescription) {\n  var options = cursorDescription.options;\n\n  if((options.limit && !options.sort)) {\n    return {\n      code: \"LIMIT_NO_SORT\",\n      reason: \"Meteor oplog implementation does not support limit without a sort specifier.\",\n      solution: \"Try adding a sort specifier.\"\n    }\n  };\n\n  return true;\n};\n\nOplogCheck.olderVersion = function(cursorDescription, driver) {\n  if(driver && !driver.constructor.cursorSupported) {\n    return {\n      code: \"OLDER_VERSION\",\n      reason: \"Your Meteor version does not have oplog support.\",\n      solution: \"Upgrade your app to Meteor version 0.7.2 or later.\"\n    };\n  }\n  return true;\n};\n\nOplogCheck.gitCheckout = function(cursorDescription, driver) {\n  if(!Meteor.release) {\n    return {\n      code: \"GIT_CHECKOUT\",\n      reason: \"Seems like your Meteor version is based on a Git checkout and it doesn't have the oplog support.\",\n      solution: \"Try to upgrade your Meteor version.\"\n    };\n  }\n  return true;\n};\n\nvar preRunningMatchers = [\n  OplogCheck.env,\n  OplogCheck.disableOplog,\n  OplogCheck.miniMongoMatcher\n];\n\nvar globalMatchers = [\n  OplogCheck.fields,\n  OplogCheck.skip,\n  OplogCheck.where,\n  OplogCheck.geo,\n  OplogCheck.limitButNoSort,\n  OplogCheck.miniMongoSorter,\n  OplogCheck.olderVersion,\n  OplogCheck.gitCheckout\n];\n\nvar versionMatchers = [\n  [/^0\\.7\\.1/, OplogCheck._071],\n  [/^0\\.7\\.0/, OplogCheck._070],\n];\n\nKadira.checkWhyNoOplog = function(cursorDescription, observerDriver) {\n  if(typeof Minimongo == 'undefined') {\n    return {\n      code: \"CANNOT_DETECT\",\n      reason: \"You are running an older Meteor version and Kadira can't check oplog state.\",\n      solution: \"Try updating your Meteor app\"\n    }\n  }\n\n  var result = runMatchers(preRunningMatchers, cursorDescription, observerDriver);\n  if(result !== true) {\n    return result;\n  }\n\n  var meteorVersion = Meteor.release;\n  for(var lc=0; lc<versionMatchers.length; lc++) {\n    var matcherInfo = versionMatchers[lc];\n    if(matcherInfo[0].test(meteorVersion)) {\n      var matched = matcherInfo[1](cursorDescription, observerDriver);\n      if(matched !== true) {\n        return matched;\n      }\n    }\n  }\n\n  result = runMatchers(globalMatchers, cursorDescription, observerDriver);\n  if(result !== true) {\n    return result;\n  }\n\n  return {\n    code: \"OPLOG_SUPPORTED\",\n    reason: \"This query should support oplog. It's weird if it's not.\",\n    solution: \"Please contact Kadira support and let's discuss.\"\n  };\n};\n\nfunction runMatchers(matcherList, cursorDescription, observerDriver) {\n  for(var lc=0; lc<matcherList.length; lc++) {\n    var matcher = matcherList[lc];\n    var matched = matcher(cursorDescription, observerDriver);\n    if(matched !== true) {\n      return matched;\n    }\n  }\n  return true;\n}\n","var Fibers = Npm.require('fibers');\nvar eventLogger = Npm.require('debug')('kadira:tracer');\nvar REPITITIVE_EVENTS = {'db': true, 'http': true, 'email': true, 'wait': true, 'async': true};\n\nfunction Tracer() {\n\n};\n\n//In the future, we might wan't to track inner fiber events too.\n//Then we can't serialize the object with methods\n//That's why we use this method of returning the data\nTracer.prototype.start = function(session, msg) {\n  var traceInfo = {\n    _id: session.id + \"::\" + msg.id,\n    session: session.id,\n    userId: session.userId,\n    id: msg.id,\n    events: []\n  };\n\n  if(msg.msg == 'method') {\n    traceInfo.type = 'method';\n    traceInfo.name = msg.method;\n  } else if(msg.msg == 'sub') {\n    traceInfo.type = 'sub';\n    traceInfo.name = msg.name;\n  } else {\n    return null;\n  }\n\n  return traceInfo;\n};\n\nTracer.prototype.event = function(traceInfo, type, data) {\n  // do not allow to proceed, if already completed or errored\n  var lastEvent = this.getLastEvent(traceInfo);\n  if(lastEvent && ['complete', 'error'].indexOf(lastEvent.type) >= 0) {\n    return false;\n  }\n\n  //expecting a end event\n  var eventId = true;\n\n  //specially handling for repitivive events like db, http\n  if(REPITITIVE_EVENTS[type]) {\n    //can't accept a new start event\n    if(traceInfo._lastEventId) {\n      return false;\n    }\n    eventId = traceInfo._lastEventId = DefaultUniqueId.get();\n  }\n\n  var event = {type: type, at: Ntp._now()};\n  if(data) {\n    event.data = data;\n  }\n\n  traceInfo.events.push(event);\n\n  eventLogger(\"%s %s\", type, traceInfo._id);\n  return eventId;\n};\n\nTracer.prototype.eventEnd = function(traceInfo, eventId, data) {\n  if(traceInfo._lastEventId && traceInfo._lastEventId == eventId) {\n    var lastEvent = this.getLastEvent(traceInfo);\n    var type = lastEvent.type + 'end';\n    var event = {type: type, at: Ntp._now()};\n    if(data) {\n      event.data = data;\n    }\n    traceInfo.events.push(event);\n    eventLogger(\"%s %s\", type, traceInfo._id);\n\n    traceInfo._lastEventId = null;\n    return true;\n  } else {\n    return false;\n  }\n};\n\nTracer.prototype.getLastEvent = function(traceInfo) {\n  return traceInfo.events[traceInfo.events.length -1]\n};\n\nTracer.prototype.endLastEvent = function(traceInfo) {\n  var lastEvent = this.getLastEvent(traceInfo);\n  if(lastEvent && !/end$/.test(lastEvent.type)) {\n    traceInfo.events.push({\n      type: lastEvent.type + 'end',\n      at: Ntp._now()\n    });\n    return true;\n  }\n  return false;\n};\n\nTracer.prototype.buildTrace = function(traceInfo) {\n  var firstEvent = traceInfo.events[0];\n  var lastEvent = traceInfo.events[traceInfo.events.length - 1];\n  var processedEvents = [];\n\n  if(firstEvent.type != 'start') {\n    console.warn('Kadira: trace is not started yet');\n    return null;\n  } else if(lastEvent.type != 'complete' && lastEvent.type != 'error') {\n    //trace is not completed or errored yet\n    console.warn('Kadira: trace is not completed or errored yet');\n    return null;\n  } else {\n    //build the metrics\n    traceInfo.errored = lastEvent.type == 'error';\n    traceInfo.at = firstEvent.at;\n\n    var metrics = {\n      total: lastEvent.at - firstEvent.at,\n    };\n\n    var totalNonCompute = 0;\n\n    firstEvent = ['start', 0];\n    if(traceInfo.events[0].data) firstEvent.push(traceInfo.events[0].data);\n    processedEvents.push(firstEvent);\n\n    for(var lc=1; lc < traceInfo.events.length - 1; lc += 2) {\n      var prevEventEnd = traceInfo.events[lc-1];\n      var startEvent = traceInfo.events[lc];\n      var endEvent = traceInfo.events[lc+1];\n      var computeTime = startEvent.at - prevEventEnd.at;\n      if(computeTime > 0) processedEvents.push(['compute', computeTime]);\n      if(!endEvent) {\n        console.error('Kadira: no end event for type: ', startEvent.type);\n        return null;\n      } else if(endEvent.type != startEvent.type + 'end') {\n        console.error('Kadira: endevent type mismatch: ', startEvent.type, endEvent.type, JSON.stringify(traceInfo));\n        return null;\n      } else {\n        var elapsedTimeForEvent = endEvent.at - startEvent.at\n        var currentEvent = [startEvent.type, elapsedTimeForEvent];\n        currentEvent.push(_.extend({}, startEvent.data, endEvent.data));\n        processedEvents.push(currentEvent);\n        metrics[startEvent.type] = metrics[startEvent.type] || 0;\n        metrics[startEvent.type] += elapsedTimeForEvent;\n        totalNonCompute += elapsedTimeForEvent;\n      }\n    }\n\n    computeTime = lastEvent.at - traceInfo.events[traceInfo.events.length - 2];\n    if(computeTime > 0) processedEvents.push(['compute', computeTime]);\n\n    var lastEventData = [lastEvent.type, 0];\n    if(lastEvent.data) lastEventData.push(lastEvent.data);\n    processedEvents.push(lastEventData);\n\n    metrics.compute = metrics.total - totalNonCompute;\n    traceInfo.metrics = metrics;\n    traceInfo.events = processedEvents;\n    traceInfo.isEventsProcessed = true;\n    return traceInfo;\n  }\n};\n\nKadira.tracer = new Tracer();\n","var logger = Npm.require('debug')('kadira:ts');\n\nTracerStore = function TracerStore(options) {\n  options = options || {};\n\n  this.maxTotalPoints = options.maxTotalPoints || 30;\n  this.interval = options.interval || 1000 * 60;\n  this.archiveEvery = options.archiveEvery || this.maxTotalPoints / 6;\n\n  //store max total on the past 30 minutes (or past 30 items)\n  this.maxTotals = {};\n  //store the max trace of the current interval\n  this.currentMaxTrace = {};\n  //archive for the traces\n  this.traceArchive = [];\n\n  this.processedCnt = {};\n\n  //group errors by messages between an interval\n  this.errorMap = {};\n};\n\nTracerStore.prototype.addTrace = function(trace) {\n  var kind = [trace.type, trace.name].join('::');\n  if(!this.currentMaxTrace[kind]) {\n    this.currentMaxTrace[kind] = EJSON.clone(trace);\n  } else if(this.currentMaxTrace[kind].metrics.total < trace.metrics.total) {\n    this.currentMaxTrace[kind] = EJSON.clone(trace);\n  } else if(trace.errored) {\n    this._handleErrors(trace);\n  }\n};\n\nTracerStore.prototype.collectTraces = function() {\n  var traces = this.traceArchive;\n  this.traceArchive = [];\n\n  // convert at(timestamp) into the actual serverTime\n  traces.forEach(function(trace) {\n    trace.at = Kadira.syncedDate.syncTime(trace.at);\n  });\n  return traces;\n};\n\nTracerStore.prototype.start = function() {\n  this._timeoutHandler = setInterval(this.processTraces.bind(this), this.interval);\n};\n\nTracerStore.prototype.stop = function() {\n  if(this._timeoutHandler) {\n    clearInterval(this._timeoutHandler);\n  }\n};\n\nTracerStore.prototype._handleErrors = function(trace) {\n  // sending error requests as it is\n  var lastEvent = trace.events[trace.events.length -1];\n  if(lastEvent && lastEvent[2]) {\n    var error = lastEvent[2].error;\n\n    // grouping errors occured (reset after processTraces)\n    var errorKey = [trace.type, trace.name, error.message].join(\"::\");\n    if(!this.errorMap[errorKey]) {\n      var erroredTrace = EJSON.clone(trace);\n      this.errorMap[errorKey] = erroredTrace;\n\n      this.traceArchive.push(erroredTrace);\n    }\n  } else {\n    logger('last events is not an error: ', JSON.stringify(trace.events));\n  }\n};\n\nTracerStore.prototype.processTraces = function() {\n  var self = this;\n  var kinds = _.union(\n    _.keys(this.maxTotals),\n    _.keys(this.currentMaxTrace)\n  );\n\n  kinds.forEach(function(kind) {\n    self.processedCnt[kind] = self.processedCnt[kind] || 0;\n    var currentMaxTrace = self.currentMaxTrace[kind];\n    var currentMaxTotal = currentMaxTrace? currentMaxTrace.metrics.total : 0;\n\n    self.maxTotals[kind] = self.maxTotals[kind] || [];\n    //add the current maxPoint\n    self.maxTotals[kind].push(currentMaxTotal);\n    var exceedingPoints = self.maxTotals[kind].length - self.maxTotalPoints;\n    if(exceedingPoints > 0) {\n      self.maxTotals[kind].splice(0, exceedingPoints);\n    }\n\n    var archiveDefault = (self.processedCnt[kind] % self.archiveEvery) == 0;\n    self.processedCnt[kind]++;\n\n    var canArchive = archiveDefault\n      || self._isTraceOutlier(kind, currentMaxTrace);\n\n    if(canArchive && currentMaxTrace) {\n      self.traceArchive.push(currentMaxTrace);\n    }\n\n    //reset currentMaxTrace\n    self.currentMaxTrace[kind] = null;\n  });\n\n  //reset the errorMap\n  self.errorMap = {};\n};\n\nTracerStore.prototype._isTraceOutlier = function(kind, trace) {\n  if(trace) {\n    var dataSet = this.maxTotals[kind];\n    return this._isOutlier(dataSet, trace.metrics.total, 3);\n  } else {\n    return false;\n  }\n};\n\n/*\n  Data point must exists in the dataSet\n*/\nTracerStore.prototype._isOutlier = function(dataSet, dataPoint, maxMadZ) {\n  var median = this._getMedian(dataSet);\n  var mad = this._calculateMad(dataSet, median);\n  var madZ = this._funcMedianDeviation(median)(dataPoint) / mad;\n\n  return madZ > maxMadZ;\n};\n\nTracerStore.prototype._getMedian = function(dataSet) {\n  var sortedDataSet = _.clone(dataSet).sort(function(a, b) {\n    return a-b;\n  });\n  return this._pickQuartile(sortedDataSet, 2);\n};\n\nTracerStore.prototype._pickQuartile = function(dataSet, num) {\n  var pos = ((dataSet.length + 1) * num) / 4;\n  if(pos % 1 == 0) {\n    return dataSet[pos -1];\n  } else {\n    pos = pos - (pos % 1);\n    return (dataSet[pos -1] + dataSet[pos])/2\n  }\n};\n\nTracerStore.prototype._calculateMad = function(dataSet, median) {\n  var medianDeviations = _.map(dataSet, this._funcMedianDeviation(median));\n  var mad = this._getMedian(medianDeviations);\n\n  return mad;\n};\n\nTracerStore.prototype._funcMedianDeviation = function(median) {\n  return function(x) {\n    return Math.abs(median - x);\n  };\n};\n\nTracerStore.prototype._getMean = function(dataPoints) {\n  if(dataPoints.length > 0) {\n    var total = 0;\n    dataPoints.forEach(function(point) {\n      total += point;\n    });\n    return total/dataPoints.length;\n  } else {\n    return 0;\n  }\n};\n","var Fiber = Npm.require('fibers');\n\nwrapServer = function(serverProto) {\n  var originalHandleConnect = serverProto._handleConnect\n  serverProto._handleConnect = function(socket, msg) {\n    originalHandleConnect.call(this, socket, msg);\n    if(Kadira.connected) {\n      Kadira.models.system.handleSessionActivity(msg, socket._meteorSession);\n    }\n  };\n};\n","wrapSession = function(sessionProto) {\n  var originalProcessMessage = sessionProto.processMessage;\n  sessionProto.processMessage = function(msg) {\n    if(Kadira.connected) {\n      var kadiraInfo = {\n        session: this.id,\n        userId: this.userId\n      };\n\n      if(msg.msg == 'method' || msg.msg == 'sub') {\n        kadiraInfo.trace = Kadira.tracer.start(this, msg);\n        Kadira.waitTimeBuilder.register(this, msg.id);\n\n        //use JSON stringify to save the CPU\n        var startData = { userId: this.userId, params: JSON.stringify(msg.params) };\n        Kadira.tracer.event(kadiraInfo.trace, 'start', startData);\n        var waitEventId = Kadira.tracer.event(kadiraInfo.trace, 'wait', {}, kadiraInfo);\n        msg._waitEventId = waitEventId;\n        msg.__kadiraInfo = kadiraInfo;\n\n        if(msg.msg == 'sub') {\n          // start tracking inside processMessage allows us to indicate\n          // wait time as well\n          Kadira.models.pubsub._trackSub(this, msg);\n        }\n      }\n\n      // Update session last active time\n      Kadira.models.system.handleSessionActivity(msg, this);\n    }\n\n    return originalProcessMessage.call(this, msg);\n  };\n\n  //adding the method context to the current fiber\n  var originalMethodHandler = sessionProto.protocol_handlers.method;\n  sessionProto.protocol_handlers.method = function(msg, unblock) {\n    var self = this;\n    //add context\n    var kadiraInfo = msg.__kadiraInfo;\n    Kadira._setInfo(kadiraInfo);\n\n    // end wait event\n    var waitList = Kadira.waitTimeBuilder.build(this, msg.id);\n    Kadira.tracer.eventEnd(kadiraInfo.trace, msg._waitEventId, {waitOn: waitList});\n\n    unblock = Kadira.waitTimeBuilder.trackWaitTime(this, msg, unblock);\n    var response = Kadira.env.kadiraInfo.withValue(kadiraInfo, function () {\n      return originalMethodHandler.call(self, msg, unblock);\n    });\n    unblock();\n    return response;\n  };\n\n  //to capture the currently processing message\n  var orginalSubHandler = sessionProto.protocol_handlers.sub;\n  sessionProto.protocol_handlers.sub = function(msg, unblock) {\n    var self = this;\n    //add context\n    var kadiraInfo = msg.__kadiraInfo;\n    Kadira._setInfo(kadiraInfo);\n\n    // end wait event\n    var waitList = Kadira.waitTimeBuilder.build(this, msg.id);\n    Kadira.tracer.eventEnd(kadiraInfo.trace, msg._waitEventId, {waitOn: waitList});\n\n    unblock = Kadira.waitTimeBuilder.trackWaitTime(this, msg, unblock);\n    var response = Kadira.env.kadiraInfo.withValue(kadiraInfo, function () {\n      return orginalSubHandler.call(self, msg, unblock);\n    });\n    unblock();\n    return response;\n  };\n\n  //to capture the currently processing message\n  var orginalUnSubHandler = sessionProto.protocol_handlers.unsub;\n  sessionProto.protocol_handlers.unsub = function(msg, unblock) {\n    unblock = Kadira.waitTimeBuilder.trackWaitTime(this, msg, unblock);\n    var response = orginalUnSubHandler.call(this, msg, unblock);\n    unblock();\n    return response;\n  };\n\n  //track method ending (to get the result of error)\n  var originalSend = sessionProto.send;\n  sessionProto.send = function(msg) {\n    if(msg.msg == 'result') {\n      var kadiraInfo = Kadira._getInfo();\n      if(msg.error) {\n        var error = _.pick(msg.error, ['message', 'stack']);\n\n        // pick the error from the wrapped method handler\n        if(kadiraInfo && kadiraInfo.currentError) {\n          // the error stack is wrapped so Meteor._debug can identify\n          // this as a method error.\n          error = _.pick(kadiraInfo.currentError, ['message', 'stack']);\n        }\n\n        Kadira.tracer.endLastEvent(kadiraInfo.trace);\n        Kadira.tracer.event(kadiraInfo.trace, 'error', {error: error});\n      } else {\n        var isForced = Kadira.tracer.endLastEvent(kadiraInfo.trace);\n        if (isForced) {\n          console.warn('Kadira endevent forced complete', JSON.stringify(kadiraInfo.trace.events));\n        };\n        Kadira.tracer.event(kadiraInfo.trace, 'complete');\n      }\n\n      if(kadiraInfo) {\n        //processing the message\n        var trace = Kadira.tracer.buildTrace(kadiraInfo.trace);\n        Kadira.models.methods.processMethod(trace);\n\n        // error may or may not exist and error tracking can be disabled\n        if(error && Kadira.options.enableErrorTracking) {\n          // if we have currentError, we should track that\n          // otherwise, try to get  error from DDP message\n          var errorToTrack = kadiraInfo.currentError || error;\n          Kadira.models.error.trackError(errorToTrack, trace);\n        }\n\n        //clean and make sure, fiber is clean\n        //not sure we need to do this, but a preventive measure\n        Kadira._setInfo(null);\n      }\n    }\n\n    return originalSend.call(this, msg);\n  };\n\n  //for the pub/sub data-impact calculation\n  ['sendAdded', 'sendChanged', 'sendRemoved'].forEach(function(funcName) {\n    var originalFunc = sessionProto[funcName];\n    sessionProto[funcName] = function(collectionName, id, fields) {\n      var self = this;\n      //fields is not relevant for `sendRemoved`, but does make any harm\n      var eventName = funcName.substring(4).toLowerCase();\n      var subscription = Kadira.env.currentSub;\n\n      if(subscription) {\n        // we need to pick the actual DDP message send by the meteor\n        // otherwise that'll add a huge performance issue\n        // that's why we do this nasty hack, but it works great\n        var originalSocketSend = self.socket.send;\n        var stringifiedFields;\n        self.socket.send = function(rawData) {\n          stringifiedFields = rawData;\n          originalSocketSend.call(self, rawData);\n        };\n\n        var res = originalFunc.call(self, collectionName, id, fields);\n        Kadira.models.pubsub._trackNetworkImpact(self, subscription, eventName, collectionName, id, stringifiedFields);\n\n        // revert to the original function\n        self.socket.send = originalSocketSend;\n        return res;\n      } else {\n        return originalFunc.call(self, collectionName, id, fields);\n      }\n    };\n  });\n};\n\n// wrap existing method handlers for capturing errors\n_.each(Meteor.default_server.method_handlers, function(handler, name) {\n  wrapMethodHanderForErrors(name, handler, Meteor.default_server.method_handlers);\n});\n\n// wrap future method handlers for capturing errors\nvar originalMeteorMethods = Meteor.methods;\nMeteor.methods = function(methodMap) {\n  _.each(methodMap, function(handler, name) {\n    wrapMethodHanderForErrors(name, handler, methodMap);\n  });\n  originalMeteorMethods(methodMap);\n};\n\n\nfunction wrapMethodHanderForErrors(name, originalHandler, methodMap) {\n  methodMap[name] = function() {\n    try{\n      return originalHandler.apply(this, arguments);\n    } catch(ex) {\n      if(Kadira._getInfo()) {\n        Kadira._getInfo().currentError = ex;\n\n        var newError = cloneError(ex);\n        ex = newError;\n      }\n      throw ex;\n    }\n  }\n}\n\nfunction cloneError(err) {\n  if(err instanceof Meteor.Error) {\n    var newError = new Meteor.Error(err.error, err.reason);\n  } else {\n    var newError = new Error(err.message);\n  }\n\n  newError.stack = {stack: err.stack, source: 'method'};\n  return newError;\n}\n","var Fiber = Npm.require('fibers');\n\nwrapSubscription = function(subscriptionProto) {\n  // If the ready event runs outside the Fiber, Kadira._getInfo() doesn't work.\n  // we need some other way to store kadiraInfo so we can use it at ready hijack.\n  var originalRunHandler = subscriptionProto._runHandler;\n  subscriptionProto._runHandler = function() {\n    var kadiraInfo = Kadira._getInfo();\n    if (kadiraInfo) {\n      this.__kadiraInfo = kadiraInfo;\n    };\n    originalRunHandler.call(this);\n  }\n\n  var originalReady = subscriptionProto.ready;\n  subscriptionProto.ready = function() {\n    // meteor has a field called `_ready` which tracks this\n    // but we need to make it future proof\n    if(!this._apmReadyTracked) {\n      var kadiraInfo = Kadira._getInfo() || this.__kadiraInfo;\n      delete this.__kadiraInfo;\n      //sometime .ready can be called in the context of the method\n      //then we have some problems, that's why we are checking this\n      //eg:- Accounts.createUser\n      if(kadiraInfo && this._subscriptionId == kadiraInfo.trace.id) {\n        var isForced = Kadira.tracer.endLastEvent(kadiraInfo.trace);\n        if (isForced) {\n          console.warn('Kadira endevent forced complete', JSON.stringify(kadiraInfo.trace.events));\n        };\n        Kadira.tracer.event(kadiraInfo.trace, 'complete');\n        var trace = Kadira.tracer.buildTrace(kadiraInfo.trace);\n      }\n\n      Kadira.models.pubsub._trackReady(this._session, this, trace);\n      this._apmReadyTracked = true;\n    }\n\n    // we still pass the control to the original implementation\n    // since multiple ready calls are handled by itself\n    originalReady.call(this);\n  };\n\n  var originalError = subscriptionProto.error;\n  subscriptionProto.error = function(err) {\n    var kadiraInfo = Kadira._getInfo();\n\n    if(kadiraInfo && this._subscriptionId == kadiraInfo.trace.id) {\n      Kadira.tracer.endLastEvent(kadiraInfo.trace);\n\n      var errorForApm = _.pick(err, 'message', 'stack');\n      Kadira.tracer.event(kadiraInfo.trace, 'error', {error: errorForApm});\n      var trace = Kadira.tracer.buildTrace(kadiraInfo.trace);\n      \n      Kadira.models.pubsub._trackError(this._session, this, trace);\n\n      // error tracking can be disabled and if there is a trace\n      // trace should be avaialble all the time, but it won't\n      // if something wrong happened on the trace building\n      if(Kadira.options.enableErrorTracking && trace) {\n        Kadira.models.error.trackError(err, trace);\n      }\n    }\n\n    // wrap error stack so Meteor._debug can identify and ignore it\n    err.stack = {stack: err.stack, source: 'subscription'};\n    originalError.call(this, err);\n  };\n\n  var originalDeactivate = subscriptionProto._deactivate;\n  subscriptionProto._deactivate = function() {\n    Kadira.models.pubsub._trackUnsub(this._session, this);\n    originalDeactivate.call(this);\n  };\n\n  //adding the currenSub env variable\n  ['added', 'changed', 'removed'].forEach(function(funcName) {\n    var originalFunc = subscriptionProto[funcName];\n    subscriptionProto[funcName] = function(collectionName, id, fields) {\n      var self = this;\n\n      //we need to run this code in a fiber and that's how we track\n      //subscription info. May be we can figure out, some other way to do this\n      Kadira.env.currentSub = self;\n      var res = originalFunc.call(self, collectionName, id, fields);\n      Kadira.env.currentSub = null;\n      \n      return res;\n    };\n  });\n};\n","wrapOplogObserveDriver = function(proto) {\n  var originalRunQuery = proto._runQuery;\n  proto._runQuery = function() {\n    var start = Date.now();\n    originalRunQuery.call(this);\n    this._lastPollTime = Date.now() - start;\n  };\n\n  var originalStop = proto.stop;\n  proto.stop = function() {\n    if(this._ownerInfo && this._ownerInfo.type === 'sub') {\n      Kadira.models.pubsub.trackDeletedObserver(this._ownerInfo);\n    }\n\n    return originalStop.call(this);\n  };\n};\n\nwrapPollingObserveDriver = function(proto) {\n  var originalPollMongo = proto._pollMongo;\n  proto._pollMongo = function() {\n    var start = Date.now();\n    originalPollMongo.call(this);\n    this._lastPollTime = Date.now() - start;\n  };\n\n  var originalStop = proto.stop;\n  proto.stop = function() {\n    if(this._ownerInfo && this._ownerInfo.type === 'sub') {\n      Kadira.models.pubsub.trackDeletedObserver(this._ownerInfo);\n    }\n\n    return originalStop.call(this);\n  };\n};\n\nwrapMultiplexer = function(proto) {\n  var originalInitalAdd = proto.addHandleAndSendInitialAdds;\n   proto.addHandleAndSendInitialAdds = function(handle) {\n    if(!this._firstInitialAddTime) {\n      this._firstInitialAddTime = Date.now();\n    }\n\n    handle._wasMultiplexerReady = this._ready();\n    handle._queueLength = this._queue._taskHandles.length;\n\n    if(!handle._wasMultiplexerReady) {\n      handle._elapsedPollingTime = Date.now() - this._firstInitialAddTime;\n    }\n    return originalInitalAdd.call(this, handle);\n  };\n};\n\n// to count observers\nvar mongoConnectionProto = MeteorX.MongoConnection.prototype;\nvar originalObserveChanges = mongoConnectionProto._observeChanges;\nmongoConnectionProto._observeChanges = function(cursorDescription, ordered, callbacks) {\n  var ret = originalObserveChanges.call(this, cursorDescription, ordered, callbacks);\n  // get the Kadira Info via the Meteor.EnvironmentalVariable\n  var kadiraInfo = Kadira._getInfo(null, true);\n\n  if(kadiraInfo && ret._multiplexer) {\n    if(!ret._multiplexer.__kadiraTracked) {\n      // new multiplexer\n      ret._multiplexer.__kadiraTracked = true;\n      Kadira.models.pubsub.incrementHandleCount(kadiraInfo.trace, false);\n      if(kadiraInfo.trace.type == 'sub') {\n        var ownerInfo = {\n          type: kadiraInfo.trace.type,\n          name: kadiraInfo.trace.name,\n        };\n\n        var observerDriver = ret._multiplexer._observeDriver;\n        observerDriver._ownerInfo = ownerInfo;\n        Kadira.models.pubsub.trackCreatedObserver(ownerInfo);\n      }\n    } else {\n      Kadira.models.pubsub.incrementHandleCount(kadiraInfo.trace, true);\n    }\n  }\n\n  return ret;\n}","var logger = Npm.require('debug')('kadira:hijack:session');\n\nKadira._startInstrumenting = function(callback) {\n  //instrumenting session\n  wrapServer(MeteorX.Server.prototype);\n  wrapSession(MeteorX.Session.prototype);\n  wrapSubscription(MeteorX.Subscription.prototype);\n\n  if(MeteorX.MongoOplogDriver) {\n    wrapOplogObserveDriver(MeteorX.MongoOplogDriver.prototype);\n  }\n\n  if(MeteorX.MongoPollingDriver) {\n    wrapPollingObserveDriver(MeteorX.MongoPollingDriver.prototype);\n  }\n\n  if(MeteorX.Multiplexer) {\n    wrapMultiplexer(MeteorX.Multiplexer.prototype);\n  }\n\n  setLabels();\n  callback();\n};\n","var mongoConnectionProto = MeteorX.MongoConnection.prototype;\n\n//findOne is handled by find - so no need to track it\n//upsert is handles by update\n['find', 'update', 'remove', 'insert', '_ensureIndex', '_dropIndex'].forEach(function(func) {\n  var originalFunc = mongoConnectionProto[func];\n  mongoConnectionProto[func] = function(collName, selector, mod, options) {\n    options = options || {};\n    var payload = {\n      coll: collName,\n      func: func,\n    };\n\n    if(func == 'insert') {\n      //add nothing more to the payload\n    } else if(func == '_ensureIndex' || func == '_dropIndex') {\n      //add index\n      payload.index = JSON.stringify(selector);\n    } else if(func == 'update' && options.upsert) {\n      payload.func = 'upsert';\n      payload.selector = JSON.stringify(selector);\n    } else {\n      //all the other functions have selectors\n      payload.selector = JSON.stringify(selector);\n    }\n\n    var kadiraInfo = Kadira._getInfo();\n    if(kadiraInfo) {\n      var eventId = Kadira.tracer.event(kadiraInfo.trace, 'db', payload);\n    }\n\n    //this cause V8 to avoid any performance optimizations, but this is must to use\n    //otherwise, if the error adds try catch block our logs get messy and didn't work\n    //see: issue #6\n    try{\n      var ret = originalFunc.apply(this, arguments);\n      //handling functions which can be triggered with an asyncCallback\n      var endOptions = {};\n\n      if(HaveAsyncCallback(arguments)) {\n        endOptions.async = true;\n      }\n\n      if(func == 'update') {\n        // upsert only returns an object when called `upsert` directly\n        // otherwise it only act an update command\n        if(options.upsert && typeof ret == 'object') {\n          endOptions.updatedDocs = ret.numberAffected;\n          endOptions.insertedId = ret.insertedId;\n        } else {\n          endOptions.updatedDocs = ret;\n        }\n      } else if(func == 'remove') {\n        endOptions.removedDocs = ret;\n      }\n\n      if(eventId) {\n        Kadira.tracer.eventEnd(kadiraInfo.trace, eventId, endOptions);\n      }\n    } catch(ex) {\n      if(eventId) {\n        Kadira.tracer.eventEnd(kadiraInfo.trace, eventId, {err: ex.message});\n      }\n      throw ex;\n    }\n\n    return ret;\n  };\n});\n\nvar cursorProto = MeteorX.MongoCursor.prototype;\n['forEach', 'map', 'fetch', 'count', 'observeChanges', 'observe', 'rewind'].forEach(function(type) {\n  var originalFunc = cursorProto[type];\n  cursorProto[type] = function() {\n    var cursorDescription = this._cursorDescription;\n    var payload = {\n      coll: cursorDescription.collectionName,\n      selector: JSON.stringify(cursorDescription.selector),\n      func: type,\n      cursor: true\n    };\n\n    if(cursorDescription.options) {\n      var options = _.pick(cursorDescription.options, ['fields', 'sort', 'limit']);\n      for(var field in options) {\n        var value = options[field]\n        if(typeof value == 'object') {\n          value = JSON.stringify(value);\n        }\n        payload[field] = value;\n      }\n    };\n\n    var kadiraInfo = Kadira._getInfo();\n    if(kadiraInfo) {\n      var eventId = Kadira.tracer.event(kadiraInfo.trace, 'db', payload);\n    }\n\n    try{\n      var ret = originalFunc.apply(this, arguments);\n\n      var endData = {};\n      if(type == 'observeChanges' || type == 'observe') {\n        var observerDriver;\n        endData.oplog = false;\n        // get data written by the multiplexer\n        endData.wasMultiplexerReady = ret._wasMultiplexerReady;\n        endData.queueLength = ret._queueLength;\n        endData.elapsedPollingTime = ret._elapsedPollingTime;\n\n        if(ret._multiplexer) {\n          endData.noOfHandles = Object.keys(ret._multiplexer._handles).length;\n\n          // older meteor versions done not have an _multiplexer value\n          observerDriver = ret._multiplexer._observeDriver;\n          if(observerDriver) {\n            observerDriver = ret._multiplexer._observeDriver;\n            var observerDriverClass = observerDriver.constructor;\n            var usesOplog = typeof observerDriverClass.cursorSupported == 'function';\n            endData.oplog = usesOplog;\n            var size = 0;\n            ret._multiplexer._cache.docs.forEach(function() {size++});\n            endData.noOfCachedDocs = size;\n\n            // if multiplexerWasNotReady, we need to get the time spend for the polling\n            if(!ret._wasMultiplexerReady) {\n              endData.initialPollingTime = observerDriver._lastPollTime;\n            }\n          }\n        }\n\n        if(!endData.oplog) {\n          // let's try to find the reason\n          var reasonInfo = Kadira.checkWhyNoOplog(cursorDescription, observerDriver);\n          endData.noOplogCode = reasonInfo.code;\n          endData.noOplogReason = reasonInfo.reason;\n          endData.noOplogSolution = reasonInfo.solution;\n        }\n      } else if(type == 'fetch' || type == 'map'){\n        //for other cursor operation\n        endData.docsFetched = ret.length;\n      }\n\n      if(eventId) {\n        Kadira.tracer.eventEnd(kadiraInfo.trace, eventId, endData);\n      }\n      return ret;\n    } catch(ex) {\n      if(eventId) {\n        Kadira.tracer.eventEnd(kadiraInfo.trace, eventId, {err: ex.message});\n      }\n      throw ex;\n    }\n  };\n});\n","var originalCall = HTTP.call;\n\nHTTP.call = function(method, url) {\n  var kadiraInfo = Kadira._getInfo();\n  if(kadiraInfo) {\n    var eventId = Kadira.tracer.event(kadiraInfo.trace, 'http', {method: method, url: url});\n  }\n\n  try {\n    var response = originalCall.apply(this, arguments);\n\n    //if the user supplied an asynCallback, we don't have a response object and it handled asynchronously\n    //we need to track it down to prevent issues like: #3\n    var endOptions = HaveAsyncCallback(arguments)? {async: true}: {statusCode: response.statusCode};\n    if(eventId) {\n      Kadira.tracer.eventEnd(kadiraInfo.trace, eventId, endOptions);\n    }\n    return response;\n  } catch(ex) {\n    if(eventId) {\n      Kadira.tracer.eventEnd(kadiraInfo.trace, eventId, {err: ex.message});\n    }\n    throw ex;\n  }\n};","var originalSend = Email.send;\n\nEmail.send = function(options) {\n  var kadiraInfo = Kadira._getInfo();\n  if(kadiraInfo) {\n    var eventId = Kadira.tracer.event(kadiraInfo.trace, 'email');\n  }\n  try {\n    var ret = originalSend.call(this, options);\n    if(eventId) {\n      Kadira.tracer.eventEnd(kadiraInfo.trace, eventId);\n    }\n    return ret;\n  } catch(ex) {\n    if(eventId) {\n      Kadira.tracer.eventEnd(kadiraInfo.trace, eventId, {err: ex.message});\n    }\n    throw ex;\n  }\n};","var Fibers = Npm.require('fibers');\n\nvar originalYield = Fibers.yield;\nFibers.yield = function() {\n  var kadiraInfo = Kadira._getInfo();\n  if(kadiraInfo) {\n    var eventId = Kadira.tracer.event(kadiraInfo.trace, 'async');;\n    if(eventId) {\n      Fibers.current._apmEventId = eventId;\n    }\n  }\n\n  originalYield();\n};\n\nvar originalRun = Fibers.prototype.run;\nFibers.prototype.run = function(val) {\n  if(this._apmEventId) {\n    var kadiraInfo = Kadira._getInfo(this);\n    Kadira.tracer.eventEnd(kadiraInfo.trace, this._apmEventId);\n    this._apmEventId = null;\n  }\n  originalRun.call(this, val);\n};\n","TrackUncaughtExceptions = function () {\n  process.on('uncaughtException', function (err) {\n    // skip errors with `_skipKadira` flag\n    if(err._skipKadira) {\n      return;\n    }\n\n    // let the server crash normally if error tracking is disabled\n    if(!Kadira.options.enableErrorTracking) {\n      throw err;\n    }\n\n    // looking for already tracked errors and throw them immediately\n    // throw error immediately if kadira is not ready\n    if(err._tracked || !Kadira.connected) {\n      throw err;\n    }\n\n    var trace = getTrace(err, 'server-crash', 'uncaughtException');\n    Kadira.models.error.trackError(err, trace);\n    Kadira._sendPayload(function () {\n      clearTimeout(timer);\n      throwError(err);\n    });\n\n    var timer = setTimeout(function () {\n      throwError(err);\n    }, 1000*10);\n\n    function throwError(err) {\n      // sometimes error came back from a fiber.\n      // But we don't fibers to track that error for us\n      // That's why we throw the error on the nextTick\n      process.nextTick(function() {\n        // we need to mark this error where we really need to throw\n        err._tracked = true;\n        throw err;\n      });\n    }\n  });\n}\n\nTrackMeteorDebug = function () {\n  var originalMeteorDebug = Meteor._debug;\n  Meteor._debug = function (message, stack) {\n    if(!Kadira.options.enableErrorTracking) {\n      return originalMeteorDebug.call(this, message, stack);\n    }\n\n    // We've changed `stack` into an object at method and sub handlers so we can\n    // ignore them here. These errors are already tracked so don't track again.\n    if(stack && stack.stack) {\n      stack = stack.stack\n    } else {\n      // only send to the server, if only connected to kadira\n      if(Kadira.connected) {\n        var error = new Error(message);\n        error.stack = stack;\n        var trace = getTrace(error, 'server-internal', 'Meteor._debug');\n        Kadira.models.error.trackError(error, trace);\n      }\n    }\n\n    return originalMeteorDebug.apply(this, arguments);\n  }\n}\n\nfunction getTrace(err, type, subType) {\n  return {\n    type: type,\n    subType: subType,\n    name: err.message,\n    errored: true,\n    at: Kadira.syncedDate.getTime(),\n    events: [\n      ['start', 0, {}],\n      ['error', 0, {error: {message: err.message, stack: err.stack}}]\n    ],\n    metrics: {\n      total: 0\n    }\n  };\n}\n","var fs = Npm.require('fs');\n\nMeteor.methods({\n  \"kadira.profileCpu\": function(arg1, arg2, type) {\n    check(arguments, [Match.Any]);\n    this.unblock();\n    if(type == 'remote') {\n      return remoteProfileCPU(arg1, arg2);\n    } else {\n      return localProfileCPU(arg1, arg2);\n    }\n  }\n});\n\nremoteProfileCPU = function(timeToProfileSecs, id) {\n  // get the job and validate it\n  var job = Jobs.get(id);\n\n  if(!job) {\n    throw new Meteor.Error(403, \"There is no such cpuProfile job: \" + id);\n  } else if(job.state != 'created') {\n    throw new Meteor.Error(403, \"CPU profile job has been already performed!\");\n  }\n\n  try {\n    console.log(\"Kadira: remote CPU profiling started for %s secs\", timeToProfileSecs);\n    var usage = Kadira.models.system.getUsage() || {};\n    var jobData = {beforeCpu: usage.cpu};\n    Jobs.set(id, {state: 'initiated', data: jobData});\n\n    var name = Random.id();\n    var profile = getCpuProfile(name, timeToProfileSecs);\n    console.log(\"Kadira: uploding the taken CPU profile\");\n    Jobs.set(id, {state: 'profile-taken'});\n    \n    uploadProfile(profile, job.data.uploadUrl);\n    console.log(\"Kadira: profiling has been completed! Visit Kadira UI to analyze it.\");\n    Jobs.set(id, {state: 'completed'});\n\n    return \"CPU Profile has been completed. Check Kadira UI to analyze it.\";\n  } catch(ex) {\n    Jobs.set(id, {state: 'errored', data:{errorMessage: ex.message}});\n    throw ex;\n  }\n};\n\nlocalProfileCPU = function(timeToProfileSecs, outputLocation) {\n  if(!process.env.KADIRA_PROFILE_LOCALLY) {\n    throw new Meteor.Error(403, \"run your app with `KADIRA_PROFILE_LOCALLY` env vairable to profile locally.\")\n  }\n\n  var name = Random.id();\n  if(!outputLocation) {\n    outputLocation = '/tmp/' + name + '.cpuprofile';\n  }\n  console.log('Kadira: started profiling for %s secs', timeToProfileSecs);\n  var profile = getCpuProfile(name, timeToProfileSecs);\n\n  console.log('Kadira: saving CPU profile to: ' + outputLocation);\n  writeToDisk(outputLocation, JSON.stringify(profile));\n  console.log('Kadira: CPU profile saved.');\n\n  return \"cpu profile has been saved to: \" + outputLocation;\n};\n\ngetCpuProfile = Kadira._wrapAsync(function(name, timeToProfileSecs, callback) {\n  var v8Profiler = Kadira._binaryRequire('v8-profiler');\n  v8Profiler.startProfiling(name);\n  setTimeout(function() {\n    var profile = v8Profiler.stopProfiling(name);\n    callback(null, profile);\n  }, timeToProfileSecs * 1000);\n});\n\nwriteToDisk = Kadira._wrapAsync(fs.writeFile);\n\nfunction uploadProfile (profile, url) {\n  var content = JSON.stringify(profile);\n  var headers = {\n    'Content-Type': 'application/json',\n    'Content-Length': Buffer.byteLength(content)\n  };\n  return HTTP.put(url, {content: content, headers: headers});\n}","setLabels = function () {\n  // name Session.prototype.send\n  var originalSend = MeteorX.Session.prototype.send;\n  MeteorX.Session.prototype.send = function kadira_Session_send (msg) {\n    return originalSend.call(this, msg);\n  }\n\n  // name mongodb.Connection.createDataHandler\n  var mongodb = MongoInternals.NpmModule;\n  var originalCreateDataHandler = mongodb.Connection.createDataHandler;\n  mongodb.Connection.createDataHandler = function (self) {\n    var originalHandler = originalCreateDataHandler.call(this, self);\n    return function kadira_MongoDB_dataHandler (data) {\n      return originalHandler.call(this, data);\n    }\n  }\n\n  // name Multiplexer initial adds\n  var originalSendAdds = MeteorX.Multiplexer.prototype._sendAdds;\n  MeteorX.Multiplexer.prototype._sendAdds = function kadira_Multiplexer_sendAdds (handle) {\n    return originalSendAdds.call(this, handle);\n  }\n\n  // name MongoConnection insert\n  var originalMongoInsert = MeteorX.MongoConnection.prototype._insert;\n  MeteorX.MongoConnection.prototype._insert = function kadira_MongoConnection_insert (coll, doc, cb) {\n    return originalMongoInsert.call(this, coll, doc, cb);\n  }\n\n  // name MongoConnection update\n  var originalMongoUpdate = MeteorX.MongoConnection.prototype._update;\n  MeteorX.MongoConnection.prototype._update = function kadira_MongoConnection_update (coll, selector, mod, options, cb) {\n    return originalMongoUpdate.call(this, coll, selector, mod, options, cb);\n  }\n\n  // name MongoConnection remove\n  var originalMongoRemove = MeteorX.MongoConnection.prototype._remove;\n  MeteorX.MongoConnection.prototype._remove = function kadira_MongoConnection_remove (coll, selector, cb) {\n    return originalMongoRemove.call(this, coll, selector, cb);\n  }\n\n  // name Pubsub added\n  var originalPubsubAdded = MeteorX.Session.prototype.sendAdded;\n  MeteorX.Session.prototype.sendAdded = function kadira_Session_sendAdded (coll, id, fields) {\n    return originalPubsubAdded.call(this, coll, id, fields);\n  }\n\n  // name Pubsub changed\n  var originalPubsubChanged = MeteorX.Session.prototype.sendChanged;\n  MeteorX.Session.prototype.sendChanged = function kadira_Session_sendChanged (coll, id, fields) {\n    return originalPubsubChanged.call(this, coll, id, fields);\n  }\n\n  // name Pubsub removed\n  var originalPubsubRemoved = MeteorX.Session.prototype.sendRemoved;\n  MeteorX.Session.prototype.sendRemoved = function kadira_Session_sendRemoved (coll, id) {\n    return originalPubsubRemoved.call(this, coll, id);\n  }\n\n  // name MongoCursor forEach\n  var originalCursorForEach = MeteorX.MongoCursor.prototype.forEach;\n  MeteorX.MongoCursor.prototype.forEach = function kadira_Cursor_forEach () {\n    return originalCursorForEach.apply(this, arguments);\n  }\n\n  // name MongoCursor map\n  var originalCursorMap = MeteorX.MongoCursor.prototype.map;\n  MeteorX.MongoCursor.prototype.map = function kadira_Cursor_map () {\n    return originalCursorMap.apply(this, arguments);\n  }\n\n  // name MongoCursor fetch\n  var originalCursorFetch = MeteorX.MongoCursor.prototype.fetch;\n  MeteorX.MongoCursor.prototype.fetch = function kadira_Cursor_fetch () {\n    return originalCursorFetch.apply(this, arguments);\n  }\n\n  // name MongoCursor count\n  var originalCursorCount = MeteorX.MongoCursor.prototype.count;\n  MeteorX.MongoCursor.prototype.count = function kadira_Cursor_count () {\n    return originalCursorCount.apply(this, arguments);\n  }\n\n  // name MongoCursor observeChanges\n  var originalCursorObserveChanges = MeteorX.MongoCursor.prototype.observeChanges;\n  MeteorX.MongoCursor.prototype.observeChanges = function kadira_Cursor_observeChanges () {\n    return originalCursorObserveChanges.apply(this, arguments);\n  }\n\n  // name MongoCursor observe\n  var originalCursorObserve = MeteorX.MongoCursor.prototype.observe;\n  MeteorX.MongoCursor.prototype.observe = function kadira_Cursor_observe () {\n    return originalCursorObserve.apply(this, arguments);\n  }\n\n  // name MongoCursor rewind\n  var originalCursorRewind = MeteorX.MongoCursor.prototype.rewind;\n  MeteorX.MongoCursor.prototype.rewind = function kadira_Cursor_rewind () {\n    return originalCursorRewind.apply(this, arguments);\n  }\n\n  // name CrossBar listen\n  var originalCrossbarListen = DDPServer._Crossbar.prototype.listen;\n  DDPServer._Crossbar.prototype.listen = function kadira_Crossbar_listen (trigger, callback) {\n    return originalCrossbarListen.call(this, trigger, callback);\n  }\n\n  // name CrossBar fire\n  var originalCrossbarFire = DDPServer._Crossbar.prototype.fire;\n  DDPServer._Crossbar.prototype.fire = function kadira_Crossbar_fire (notification) {\n    return originalCrossbarFire.call(this, notification);\n  }\n}\n","// AutoConnect using Environment Variables\nif(process.env.KADIRA_APP_ID && process.env.KADIRA_APP_SECRET) {\n  Kadira.connect(\n    process.env.KADIRA_APP_ID,\n    process.env.KADIRA_APP_SECRET\n  );\n\n  Kadira.connect = function() {\n    throw new Error('Kadira has been already connected using credentials from Environment Variables');\n  };\n} \n\n// AutoConnect using Meteor.settings\nif(\n  Meteor.settings.kadira &&\n  Meteor.settings.kadira.appId &&\n  Meteor.settings.kadira.appSecret\n) {\n  Kadira.connect(\n    Meteor.settings.kadira.appId, \n    Meteor.settings.kadira.appSecret,\n    Meteor.settings.kadira.options || {}\n  );\n\n  Kadira.connect = function() {\n    throw new Error('Kadira has been already connected using credentials from Meteor.settings');\n  };\n}","var commonErrRegExps = [\n  /connection timeout\\. no (\\w*) heartbeat received/i,\n  /INVALID_STATE_ERR/i,\n];\n\nKadira.errorFilters = {\n  filterValidationErrors: function(type, message, err) {\n    if(err && err instanceof Meteor.Error) {\n      return false;\n    } else {\n      return true;\n    }\n  },\n\n  filterCommonMeteorErrors: function(type, message) {\n    for(var lc=0; lc<commonErrRegExps.length; lc++) {\n      var regExp = commonErrRegExps[lc];\n      if(regExp.test(message)) {\n        return false;\n      }\n    }\n    return true;\n  }\n};","Kadira.send = function (payload, path, callback) {\n  if(!Kadira.connected)  {\n    throw new Error(\"You need to connect with Kadira first, before sending messages!\");\n  }\n\n  path = (path.substr(0, 1) != '/')? \"/\" + path : path;\n  var endpoint = Kadira.options.endpoint + path;\n  var retryCount = 0;\n  var retry = new Retry({\n    minCount: 1,\n    minTimeout: 0,\n    baseTimeout: 1000*5,\n    maxTimeout: 1000*60,\n  });\n\n  var sendFunction = Kadira._getSendFunction();\n  tryToSend();\n\n  function tryToSend(err) {\n    if(retryCount < 5) {\n      retry.retryLater(retryCount++, send);\n    } else {\n      console.warn('Error sending error traces to kadira server');\n      if(callback) callback(err);\n    }\n  }\n\n  function send() {\n    sendFunction(endpoint, payload, function(err, content, statusCode) {\n      if(err) {\n        tryToSend(err);\n      } else if(statusCode == 200){\n        if(callback) callback(null, content);\n      } else {\n        if(callback) callback(new Meteor.Error(statusCode, content));\n      }\n    });\n  }\n};\n\nKadira._getSendFunction = function() {\n  return (Meteor.isServer)? Kadira._serverSend : Kadira._clientSend;\n};\n\nKadira._clientSend = function (endpoint, payload, callback) {\n  $.ajax({\n    type: 'POST',\n    url: endpoint,\n    contentType: 'application/json',\n    data: JSON.stringify(payload),\n    error: function(err) {\n      callback(err);\n    },\n    success: function(data) {\n      callback(null, data, 200);\n    }\n  }); \n}\n\nKadira._serverSend = function (endpoint, payload, callback) {\n  callback = callback || function() {};\n  var Fiber = Npm.require('fibers');\n  new Fiber(function() {\n    var httpOptions = {\n      data: payload,\n      headers: Kadira.options.authHeaders\n    };\n\n    HTTP.call('POST', endpoint, httpOptions, function(err, res) {\n      if(res) {\n        var content = (res.statusCode == 200)? res.data : res.content;\n        callback(null, content, res.statusCode);\n      } else {\n        callback(err);\n      }  \n    });\n  }).run();\n}"]}