{"version":3,"sources":["oauth/oauth_server.js","oauth/pending_credentials.js","oauth/oauth_common.js","oauth/deprecated.js"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;AAAA,kC;AACA,6B;;AAEA,W;AACA,e;;AAEA,2C;;AAEA,4B;;AAEA,+D;AACA,sE;AACA,iB;AACA,4B;;;AAGA,sE;AACA,sE;AACA,mE;AACA,c;AACA,E;AACA,iD;AACA,iD;AACA,4D;AACA,2D;AACA,uF;AACA,yE;AACA,uB;AACA,yE;AACA,8C;AACA,wD;AACA,E;AACA,4E;AACA,+B;AACA,yE;;AAEA,8B;AACA,sB;AACA,qB;AACA,e;AACA,0C;AACA,I;AACA,E;;AAEA,oB;AACA,+C;AACA,kC;AACA,E;;;AAGA,wE;AACA,6E;AACA,E;;;AAGA,gE;AACA,mE;AACA,E;AACA,4E;AACA,oC;AACA,2B;AACA,qC;AACA,mD;AACA,E;;AAEA,0C;AACA,a;AACA,O;AACA,kE;AACA,e;AACA,+E;AACA,Y;AACA,G;;AAEA,O;AACA,8B;AACA,e;AACA,kE;AACA,Y;AACA,G;AACA,E;;AAEA,+C;AACA,Y;AACA,oE;AACA,wE;AACA,yC;AACA,O;AACA,oD;AACA,iB;AACA,oB;AACA,G;AACA,kD;AACA,0D;AACA,G;AACA,e;AACA,E;;AAEA,oD;AACA,Y;AACA,oE;AACA,wE;AACA,wE;AACA,qC;AACA,O;AACA,yC;AACA,iB;AACA,uB;AACA,G;AACA,+B;AACA,E;;AAEA,8C;AACA,O;AACA,qD;AACA,iB;AACA,sE;AACA,sE;AACA,uE;AACA,kB;AACA,iB;AACA,G;AACA,E;;AAEA,oD;AACA,+D;AACA,kE;AACA,uB;AACA,wD;AACA,qC;AACA,gE;AACA,0B;AACA,K;AACA,U;AACA,wD;AACA,uF;AACA,I;AACA,E;;;AAGA,yC;AACA,qD;AACA,gF;AACA,mD;AACA,qB;AACA,+B;AACA,W;AACA,G;;AAEA,4C;AACA,mE;AACA,e;AACA,O;AACA,4C;AACA,uB;AACA,uD;AACA,a;AACA,a;AACA,K;;AAEA,kD;;AAEA,wE;AACA,iB;AACA,iE;;AAEA,iC;AACA,kC;;AAEA,0D;AACA,iB;AACA,qE;AACA,qC;AACA,iB;AACA,oE;AACA,8D;AACA,M;AACA,oE;AACA,sE;AACA,iE;AACA,iD;AACA,kD;AACA,4D;AACA,uF;AACA,qB;AACA,uE;AACA,qE;AACA,gF;AACA,2C;AACA,O;AACA,K;;AAEA,8D;AACA,+D;AACA,4C;AACA,qE;AACA,S;AACA,sC;AACA,yB;AACA,0D;AACA,kB;AACA,S;AACA,mB;AACA,2D;AACA,oD;AACA,K;AACA,G;AACA,E;;AAEA,kC;;AAEA,uD;AACA,E;AACA,mE;AACA,gB;AACA,uC;AACA,wE;AACA,+B;AACA,e;AACA,e;AACA,uB;AACA,M;AACA,uC;AACA,sC;;AAEA,yD;AACA,iB;AACA,gC;AACA,gB;;AAEA,8B;AACA,iC;AACA,qB;AACA,E;;AAEA,6B;AACA,8C;AACA,6E;AACA,iD;AACA,G;AACA,E;;AAEA,+B;AACA,0D;AACA,iB;AACA,qC;AACA,oC;AACA,E;;AAEA,mD;AACA,oE;AACA,gE;AACA,oE;AACA,oE;AACA,kC;AACA,I;AACA,kE;AACA,wE;AACA,uD;;AAEA,8C;AACA,sD;AACA,uC;AACA,U;AACA,mB;AACA,mB;AACA,mD;AACA,M;AACA,sB;AACA,kC;AACA,Y;AACA,yD;AACA,oC;AACA,4B;AACA,4C;AACA,8D;AACA,c;AACA,6D;AACA,O;AACA,K;;AAEA,4C;AACA,G;AACA,E;;AAEA,oE;AACA,sE;AACA,gD;AACA,mD;AACA,gC;;AAEA,sD;AACA,mC;;AAEA,2E;AACA,mE;AACA,E;AACA,e;AACA,yC;AACA,mC;AACA,sB;AACA,uB;AACA,kB;AACA,0B;AACA,E;AACA,mD;AACA,iE;AACA,oE;AACA,sE;AACA,8C;;AAEA,6B;AACA,Y;AACA,sC;AACA,8B;AACA,8B;AACA,iC;AACA,iC;AACA,iC;AACA,Y;AACA,e;AACA,K;AACA,I;;AAEA,uE;AACA,uD;AACA,gB;AACA,sD;AACA,qD;AACA,uD;AACA,qD;AACA,6C;AACA,mC;AACA,I;;AAEA,e;AACA,uC;AACA,iD;AACA,iD;AACA,oD;AACA,U;AACA,iE;AACA,G;;AAEA,sE;;AAEA,sC;AACA,E;;AAEA,qE;AACA,wE;AACA,kE;AACA,oE;AACA,qE;AACA,sE;AACA,uC;AACA,E;AACA,+D;AACA,sE;AACA,mE;AACA,wE;AACA,uE;AACA,qE;AACA,qE;AACA,2D;AACA,E;AACA,a;AACA,oC;AACA,e;AACA,qD;AACA,sE;AACA,sE;AACA,gE;AACA,iE;AACA,wD;AACA,uE;AACA,sE;AACA,uE;AACA,uE;AACA,yC;AACA,qD;AACA,oD;;AAEA,kB;AACA,0C;AACA,mE;AACA,uC;AACA,qD;AACA,qD;AACA,iE;AACA,4B;AACA,K;AACA,G;;AAEA,2D;;AAEA,sB;AACA,wC;AACA,8C;AACA,sD;AACA,sC;AACA,qC;AACA,gC;AACA,+B;AACA,0B;AACA,iB;AACA,W;AACA,G;;AAEA,gE;AACA,sE;AACA,sE;AACA,oC;AACA,mC;AACA,6B;AACA,+C;AACA,iD;AACA,6B;AACA,wB;AACA,e;AACA,E;;;AAGA,iG;;AAEA,wC;AACA,0D;AACA,E;;AAEA,8D;AACA,oE;AACA,gE;AACA,E;AACA,mE;AACA,mE;AACA,qE;AACA,sE;AACA,uC;AACA,E;AACA,yC;AACA,6B;AACA,2C;AACA,M;AACA,qB;AACA,C;;AAEA,4D;AACA,gD;AACA,E;AACA,sE;AACA,sE;AACA,E;AACA,mD;AACA,6E;AACA,uB;;AAEA,mD;AACA,E;;AAEA,+C;AACA,E;AACA,oD;AACA,kB;AACA,8C;AACA,6D;AACA,K;AACA,gB;AACA,E;;;;;;;;;;;;;;;;;;;ACndA,E;AACA,mE;AACA,+D;AACA,6D;AACA,oC;AACA,E;AACA,iE;AACA,gC;AACA,E;;;AAGA,yE;AACA,6C;AACA,iD;AACA,sC;AACA,6B;AACA,K;;AAEA,2D;AACA,2D;AACA,oD;;;;AAIA,2D;AACA,qC;AACA,2C;AACA,8B;AACA,qD;AACA,uE;AACA,E;AACA,uE;;;AAGA,uE;AACA,oD;AACA,E;AACA,sB;AACA,uD;AACA,sE;AACA,qD;AACA,E;AACA,8E;AACA,qB;AACA,kD;;AAEA,oC;AACA,2C;AACA,U;AACA,8C;AACA,G;;AAEA,uE;AACA,qE;AACA,gD;AACA,oC;AACA,Y;AACA,M;AACA,a;AACA,2B;AACA,+C;AACA,yB;AACA,K;AACA,E;;;AAGA,6E;AACA,E;AACA,sB;AACA,mC;AACA,E;AACA,qE;AACA,qB;;AAEA,6D;AACA,a;AACA,8C;AACA,K;AACA,0B;AACA,qE;AACA,2C;AACA,+D;AACA,Q;AACA,4D;AACA,U;AACA,qB;AACA,G;AACA,E;;;AAGA,8D;AACA,0D;AACA,8D;AACA,qC;AACA,uB;AACA,2D;AACA,kC;AACA,K;;AAEA,8C;AACA,qC;AACA,sC;AACA,G;;AAEA,gC;AACA,E;;AAEA,wD;AACA,wC;AACA,Y;;AAEA,6B;AACA,+B;AACA,gC;AACA,U;AACA,wB;AACA,G;;AAEA,8D;AACA,+B;AACA,K;;AAEA,e;AACA,E;;;;;;;;;;;;;;;;;;;AC3HA,6D;;AAEA,iF;AACA,0B;AACA,iE;AACA,sE;AACA,oE;AACA,0C;AACA,iD;;AAEA,oE;AACA,mE;AACA,wE;AACA,wB;AACA,wB;AACA,e;AACA,6B;AACA,+B;AACA,+B;AACA,0B;AACA,0B;AACA,4B;AACA,yB;AACA,K;AACA,G;;AAEA,qC;AACA,gD;AACA,6C;;AAEA,oB;AACA,4D;AACA,yC;AACA,wE;AACA,iE;AACA,yD;AACA,mC;AACA,6C;AACA,mD;AACA,4C;AACA,kC;AACA,O;AACA,0C;AACA,K;;AAEA,2D;AACA,sE;AACA,iD;AACA,sB;AACA,O;AACA,G;;AAEA,2B;AACA,oE;AACA,U;AACA,Y;AACA,E;;;;;;;;;;;;;;;;;;;ACxDA,wB;;AAEA,c","file":"/packages/oauth.js","sourcesContent":["var Fiber = Npm.require('fibers');\nvar url = Npm.require('url');\n\nOAuth = {};\nOAuthTest = {};\n\nRoutePolicy.declare('/_oauth/', 'network');\n\nvar registeredServices = {};\n\n// Internal: Maps from service version to handler function. The\n// 'oauth1' and 'oauth2' packages manipulate this directly to register\n// for callbacks.\nOAuth._requestHandlers = {};\n\n\n// Register a handler for an OAuth service. The handler will be called\n// when we get an incoming http request on /_oauth/{serviceName}. This\n// handler should use that information to fetch data about the user\n// logging in.\n//\n// @param name {String} e.g. \"google\", \"facebook\"\n// @param version {Number} OAuth version (1 or 2)\n// @param urls   For OAuth1 only, specify the service's urls\n// @param handleOauthRequest {Function(oauthBinding|query)}\n//   - (For OAuth1 only) oauthBinding {OAuth1Binding} bound to the appropriate provider\n//   - (For OAuth2 only) query {Object} parameters passed in query string\n//   - return value is:\n//     - {serviceData:, (optional options:)} where serviceData should end\n//       up in the user's services[name] field\n//     - `null` if the user declined to give permissions\n//\nOAuth.registerService = function (name, version, urls, handleOauthRequest) {\n  if (registeredServices[name])\n    throw new Error(\"Already registered the \" + name + \" OAuth service\");\n\n  registeredServices[name] = {\n    serviceName: name,\n    version: version,\n    urls: urls,\n    handleOauthRequest: handleOauthRequest\n  };\n};\n\n// For test cleanup.\nOAuthTest.unregisterService = function (name) {\n  delete registeredServices[name];\n};\n\n\nOAuth.retrieveCredential = function(credentialToken, credentialSecret) {\n  return OAuth._retrievePendingCredential(credentialToken, credentialSecret);\n};\n\n\n// The state parameter is normally generated on the client using\n// `btoa`, but for tests we need a version that runs on the server.\n//\nOAuth._generateState = function (loginStyle, credentialToken, redirectUrl) {\n  return new Buffer(JSON.stringify({\n    loginStyle: loginStyle,\n    credentialToken: credentialToken,\n    redirectUrl: redirectUrl})).toString('base64');\n};\n\nOAuth._stateFromQuery = function (query) {\n  var string;\n  try {\n    string = new Buffer(query.state, 'base64').toString('binary');\n  } catch (e) {\n    Log.warn('Unable to base64 decode state from OAuth query: ' + query.state);\n    throw e;\n  }\n\n  try {\n    return JSON.parse(string);\n  } catch (e) {\n    Log.warn('Unable to parse state from OAuth query: ' + string);\n    throw e;\n  }\n};\n\nOAuth._loginStyleFromQuery = function (query) {\n  var style;\n  // For backwards-compatibility for older clients, catch any errors\n  // that result from parsing the state parameter. If we can't parse it,\n  // set login style to popup by default.\n  try {\n    style = OAuth._stateFromQuery(query).loginStyle;\n  } catch (err) {\n    style = \"popup\";\n  }\n  if (style !== \"popup\" && style !== \"redirect\") {\n    throw new Error(\"Unrecognized login style: \" + style);\n  }\n  return style;\n};\n\nOAuth._credentialTokenFromQuery = function (query) {\n  var state;\n  // For backwards-compatibility for older clients, catch any errors\n  // that result from parsing the state parameter. If we can't parse it,\n  // assume that the state parameter's value is the credential token, as\n  // it used to be for older clients.\n  try {\n    state = OAuth._stateFromQuery(query);\n  } catch (err) {\n    return query.state;\n  }\n  return state.credentialToken;\n};\n\nOAuth._isCordovaFromQuery = function (query) {\n  try {\n    return !! OAuth._stateFromQuery(query).isCordova;\n  } catch (err) {\n    // For backwards-compatibility for older clients, catch any errors\n    // that result from parsing the state parameter. If we can't parse\n    // it, assume that we are not on Cordova, since older Meteor didn't\n    // do Cordova.\n    return false;\n  }\n};\n\n// Checks if the `redirectUrl` matches the app host.\n// We export this function so that developers can override this\n// behavior to allow apps from external domains to login using the\n// redirect OAuth flow.\nOAuth._checkRedirectUrlOrigin = function (redirectUrl) {\n  var appHost = Meteor.absoluteUrl();\n  var appHostReplacedLocalhost = Meteor.absoluteUrl(undefined, {\n    replaceLocalhost: true\n  });\n  return (\n    redirectUrl.substr(0, appHost.length) !== appHost &&\n    redirectUrl.substr(0, appHostReplacedLocalhost.length) !== appHostReplacedLocalhost\n  );\n};\n\n\n// Listen to incoming OAuth http requests\nWebApp.connectHandlers.use(function(req, res, next) {\n  // Need to create a Fiber since we're using synchronous http calls and nothing\n  // else is wrapping this in a fiber automatically\n  Fiber(function () {\n    middleware(req, res, next);\n  }).run();\n});\n\nvar middleware = function (req, res, next) {\n  // Make sure to catch any exceptions because otherwise we'd crash\n  // the runner\n  try {\n    var serviceName = oauthServiceName(req);\n    if (!serviceName) {\n      // not an oauth request. pass to next middleware.\n      next();\n      return;\n    }\n\n    var service = registeredServices[serviceName];\n\n    // Skip everything if there's no service set by the oauth middleware\n    if (!service)\n      throw new Error(\"Unexpected OAuth service \" + serviceName);\n\n    // Make sure we're configured\n    ensureConfigured(serviceName);\n\n    var handler = OAuth._requestHandlers[service.version];\n    if (!handler)\n      throw new Error(\"Unexpected OAuth version \" + service.version);\n    handler(service, req.query, res);\n  } catch (err) {\n    // if we got thrown an error, save it off, it will get passed to\n    // the appropriate login call (if any) and reported there.\n    //\n    // The other option would be to display it in the popup tab that\n    // is still open at this point, ignoring the 'close' or 'redirect'\n    // we were passed. But then the developer wouldn't be able to\n    // style the error or react to it in any way.\n    if (req.query.state && err instanceof Error) {\n      try { // catch any exceptions to avoid crashing runner\n        OAuth._storePendingCredential(OAuth._credentialTokenFromQuery(req.query), err);\n      } catch (err) {\n        // Ignore the error and just give up. If we failed to store the\n        // error, then the login will just fail with a generic error.\n        Log.warn(\"Error in OAuth Server while storing pending login result.\\n\" +\n                 err.stack || err.message);\n      }\n    }\n\n    // close the popup. because nobody likes them just hanging\n    // there.  when someone sees this multiple times they might\n    // think to check server logs (we hope?)\n    // Catch errors because any exception here will crash the runner.\n    try {\n      OAuth._endOfLoginResponse(res, {\n        query: req.query,\n        loginStyle: OAuth._loginStyleFromQuery(req.query),\n        error: err\n      });\n    } catch (err) {\n      Log.warn(\"Error generating end of login response\\n\" +\n               (err && (err.stack || err.message)));\n    }\n  }\n};\n\nOAuthTest.middleware = middleware;\n\n// Handle /_oauth/* paths and extract the service name.\n//\n// @returns {String|null} e.g. \"facebook\", or null if this isn't an\n// oauth request\nvar oauthServiceName = function (req) {\n  // req.url will be \"/_oauth/<service name>\" with an optional \"?close\".\n  var i = req.url.indexOf('?');\n  var barePath;\n  if (i === -1)\n    barePath = req.url;\n  else\n    barePath = req.url.substring(0, i);\n  var splitPath = barePath.split('/');\n\n  // Any non-oauth request will continue down the default\n  // middlewares.\n  if (splitPath[1] !== '_oauth')\n    return null;\n\n  // Find service based on url\n  var serviceName = splitPath[2];\n  return serviceName;\n};\n\n// Make sure we're configured\nvar ensureConfigured = function(serviceName) {\n  if (!ServiceConfiguration.configurations.findOne({service: serviceName})) {\n    throw new ServiceConfiguration.ConfigError();\n  }\n};\n\nvar isSafe = function (value) {\n  // This matches strings generated by `Random.secret` and\n  // `Random.id`.\n  return typeof value === \"string\" &&\n    /^[a-zA-Z0-9\\-_]+$/.test(value);\n};\n\n// Internal: used by the oauth1 and oauth2 packages\nOAuth._renderOauthResults = function(res, query, credentialSecret) {\n  // For tests, we support the `only_credential_secret_for_test`\n  // parameter, which just returns the credential secret without any\n  // surrounding HTML. (The test needs to be able to easily grab the\n  // secret and use it to log in.)\n  //\n  // XXX only_credential_secret_for_test could be useful for other\n  // things beside tests, like command-line clients. We should give it a\n  // real name and serve the credential secret in JSON.\n\n  if (query.only_credential_secret_for_test) {\n    res.writeHead(200, {'Content-Type': 'text/html'});\n    res.end(credentialSecret, 'utf-8');\n  } else {\n    var details = {\n      query: query,\n      loginStyle: OAuth._loginStyleFromQuery(query)\n    };\n    if (query.error) {\n      details.error = query.error;\n    } else {\n      var token = OAuth._credentialTokenFromQuery(query);\n      var secret = credentialSecret;\n      if (token && secret &&\n          isSafe(token) && isSafe(secret)) {\n        details.credentials = { token: token, secret: secret};\n      } else {\n        details.error = \"invalid_credential_token_or_secret\";\n      }\n    }\n\n    OAuth._endOfLoginResponse(res, details);\n  }\n};\n\n// This \"template\" (not a real Spacebars template, just an HTML file\n// with some ##PLACEHOLDER##s) communicates the credential secret back\n// to the main window and then closes the popup.\nOAuth._endOfPopupResponseTemplate = Assets.getText(\n  \"end_of_popup_response.html\");\n\nOAuth._endOfRedirectResponseTemplate = Assets.getText(\n  \"end_of_redirect_response.html\");\n\n// Renders the end of login response template into some HTML and JavaScript\n// that closes the popup or redirects at the end of the OAuth flow.\n//\n// options are:\n//   - loginStyle (\"popup\" or \"redirect\")\n//   - setCredentialToken (boolean)\n//   - credentialToken\n//   - credentialSecret\n//   - redirectUrl\n//   - isCordova (boolean)\n//\nvar renderEndOfLoginResponse = function (options) {\n  // It would be nice to use Blaze here, but it's a little tricky\n  // because our mustaches would be inside a <script> tag, and Blaze\n  // would treat the <script> tag contents as text (e.g. encode '&' as\n  // '&amp;'). So we just do a simple replace.\n\n  var escape = function (s) {\n    if (s) {\n      return s.replace(/&/g, \"&amp;\").\n        replace(/</g, \"&lt;\").\n        replace(/>/g, \"&gt;\").\n        replace(/\\\"/g, \"&quot;\").\n        replace(/\\'/g, \"&#x27;\").\n        replace(/\\//g, \"&#x2F;\");\n    } else {\n      return s;\n    }\n  };\n\n  // Escape everything just to be safe (we've already checked that some\n  // of this data -- the token and secret -- are safe).\n  var config = {\n    setCredentialToken: !! options.setCredentialToken,\n    credentialToken: escape(options.credentialToken),\n    credentialSecret: escape(options.credentialSecret),\n    storagePrefix: escape(OAuth._storageTokenPrefix),\n    redirectUrl: escape(options.redirectUrl),\n    isCordova: !! options.isCordova\n  };\n\n  var template;\n  if (options.loginStyle === 'popup') {\n    template = OAuth._endOfPopupResponseTemplate;\n  } else if (options.loginStyle === 'redirect') {\n    template = OAuth._endOfRedirectResponseTemplate;\n  } else {\n    throw new Error('invalid loginStyle: ' + options.loginStyle);\n  }\n\n  var result = template.replace(/##CONFIG##/, JSON.stringify(config));\n\n  return \"<!DOCTYPE html>\\n\" + result;\n};\n\n// Writes an HTTP response to the popup window at the end of an OAuth\n// login flow. At this point, if the user has successfully authenticated\n// to the OAuth server and authorized this app, we communicate the\n// credentialToken and credentialSecret to the main window. The main\n// window must provide both these values to the DDP `login` method to\n// authenticate its DDP connection. After communicating these vaues to\n// the main window, we close the popup.\n//\n// We export this function so that developers can override this\n// behavior, which is particularly useful in, for example, some mobile\n// environments where popups and/or `window.opener` don't work. For\n// example, an app could override `OAuth._endOfPopupResponse` to put the\n// credential token and credential secret in the popup URL for the main\n// window to read them there instead of using `window.opener`. If you\n// override this function, you take responsibility for writing to the\n// request and calling `res.end()` to complete the request.\n//\n// Arguments:\n//   - res: the HTTP response object\n//   - details:\n//      - query: the query string on the HTTP request\n//      - credentials: { token: *, secret: * }. If present, this field\n//        indicates that the login was successful. Return these values\n//        to the client, who can use them to log in over DDP. If\n//        present, the values have been checked against a limited\n//        character set and are safe to include in HTML.\n//      - error: if present, a string or Error indicating an error that\n//        occurred during the login. This can come from the client and\n//        so shouldn't be trusted for security decisions or included in\n//        the response without sanitizing it first. Only one of `error`\n//        or `credentials` should be set.\nOAuth._endOfLoginResponse = function (res, details) {\n  res.writeHead(200, {'Content-Type': 'text/html'});\n\n  var redirectUrl;\n  if (details.loginStyle === 'redirect') {\n    redirectUrl = OAuth._stateFromQuery(details.query).redirectUrl;\n    var appHost = Meteor.absoluteUrl();\n    if (OAuth._checkRedirectUrlOrigin(redirectUrl)) {\n      details.error = \"redirectUrl (\" + redirectUrl +\n        \") is not on the same host as the app (\" + appHost + \")\";\n      redirectUrl = appHost;\n    }\n  }\n\n  var isCordova = OAuth._isCordovaFromQuery(details.query);\n\n  if (details.error) {\n    Log.warn(\"Error in OAuth Server: \" +\n             (details.error instanceof Error ?\n              details.error.message : details.error));\n    res.end(renderEndOfLoginResponse({\n      loginStyle: details.loginStyle,\n      setCredentialToken: false,\n      redirectUrl: redirectUrl,\n      isCordova: isCordova\n    }), \"utf-8\");\n    return;\n  }\n\n  // If we have a credentialSecret, report it back to the parent\n  // window, with the corresponding credentialToken. The parent window\n  // uses the credentialToken and credentialSecret to log in over DDP.\n  res.end(renderEndOfLoginResponse({\n    loginStyle: details.loginStyle,\n    setCredentialToken: true,\n    credentialToken: details.credentials.token,\n    credentialSecret: details.credentials.secret,\n    redirectUrl: redirectUrl,\n    isCordova: isCordova\n  }), \"utf-8\");\n};\n\n\nvar OAuthEncryption = Package[\"oauth-encryption\"] && Package[\"oauth-encryption\"].OAuthEncryption;\n\nvar usingOAuthEncryption = function () {\n  return OAuthEncryption && OAuthEncryption.keyIsLoaded();\n};\n\n// Encrypt sensitive service data such as access tokens if the\n// \"oauth-encryption\" package is loaded and the oauth secret key has\n// been specified.  Returns the unencrypted plaintext otherwise.\n//\n// The user id is not specified because the user isn't known yet at\n// this point in the oauth authentication process.  After the oauth\n// authentication process completes the encrypted service data fields\n// will be re-encrypted with the user id included before inserting the\n// service data into the user document.\n//\nOAuth.sealSecret = function (plaintext) {\n  if (usingOAuthEncryption())\n    return OAuthEncryption.seal(plaintext);\n  else\n    return plaintext;\n}\n\n// Unencrypt a service data field, if the \"oauth-encryption\"\n// package is loaded and the field is encrypted.\n//\n// Throws an error if the \"oauth-encryption\" package is loaded and the\n// field is encrypted, but the oauth secret key hasn't been specified.\n//\nOAuth.openSecret = function (maybeSecret, userId) {\n  if (!Package[\"oauth-encryption\"] || !OAuthEncryption.isSealed(maybeSecret))\n    return maybeSecret;\n\n  return OAuthEncryption.open(maybeSecret, userId);\n};\n\n// Unencrypt fields in the service data object.\n//\nOAuth.openSecrets = function (serviceData, userId) {\n  var result = {};\n  _.each(_.keys(serviceData), function (key) {\n    result[key] = OAuth.openSecret(serviceData[key], userId);\n  });\n  return result;\n};\n","//\n// When an oauth request is made, Meteor receives oauth credentials\n// in one browser tab, and temporarily persists them while that\n// tab is closed, then retrieves them in the browser tab that\n// initiated the credential request.\n//\n// _pendingCredentials is the storage mechanism used to share the\n// credential between the 2 tabs\n//\n\n\n// Collection containing pending credentials of oauth credential requests\n// Has key, credential, and createdAt fields.\nOAuth._pendingCredentials = new Mongo.Collection(\n  \"meteor_oauth_pendingCredentials\", {\n    _preventAutopublish: true\n  });\n\nOAuth._pendingCredentials._ensureIndex('key', {unique: 1});\nOAuth._pendingCredentials._ensureIndex('credentialSecret');\nOAuth._pendingCredentials._ensureIndex('createdAt');\n\n\n\n// Periodically clear old entries that were never retrieved\nvar _cleanStaleResults = function() {\n  // Remove credentials older than 1 minute\n  var timeCutoff = new Date();\n  timeCutoff.setMinutes(timeCutoff.getMinutes() - 1);\n  OAuth._pendingCredentials.remove({ createdAt: { $lt: timeCutoff } });\n};\nvar _cleanupHandle = Meteor.setInterval(_cleanStaleResults, 60 * 1000);\n\n\n// Stores the key and credential in the _pendingCredentials collection.\n// Will throw an exception if `key` is not a string.\n//\n// @param key {string}\n// @param credential {Object}   The credential to store\n// @param credentialSecret {string} A secret that must be presented in\n//   addition to the `key` to retrieve the credential\n//\nOAuth._storePendingCredential = function (key, credential, credentialSecret) {\n  check(key, String);\n  check(credentialSecret, Match.Optional(String));\n\n  if (credential instanceof Error) {\n    credential = storableError(credential);\n  } else {\n    credential = OAuth.sealSecret(credential);\n  }\n\n  // We do an upsert here instead of an insert in case the user happens\n  // to somehow send the same `state` parameter twice during an OAuth\n  // login; we don't want a duplicate key error.\n  OAuth._pendingCredentials.upsert({\n    key: key\n  }, {\n    key: key,\n    credential: credential,\n    credentialSecret: credentialSecret || null,\n    createdAt: new Date()\n  });\n};\n\n\n// Retrieves and removes a credential from the _pendingCredentials collection\n//\n// @param key {string}\n// @param credentialSecret {string}\n//\nOAuth._retrievePendingCredential = function (key, credentialSecret) {\n  check(key, String);\n\n  var pendingCredential = OAuth._pendingCredentials.findOne({\n    key: key,\n    credentialSecret: credentialSecret || null\n  });\n  if (pendingCredential) {\n    OAuth._pendingCredentials.remove({ _id: pendingCredential._id });\n    if (pendingCredential.credential.error)\n      return recreateError(pendingCredential.credential.error);\n    else\n      return OAuth.openSecret(pendingCredential.credential);\n  } else {\n    return undefined;\n  }\n};\n\n\n// Convert an Error into an object that can be stored in mongo\n// Note: A Meteor.Error is reconstructed as a Meteor.Error\n// All other error classes are reconstructed as a plain Error.\nvar storableError = function(error) {\n  var plainObject = {};\n  Object.getOwnPropertyNames(error).forEach(function(key) {\n    plainObject[key] = error[key];\n  });\n\n  // Keep track of whether it's a Meteor.Error\n  if(error instanceof Meteor.Error) {\n    plainObject['meteorError'] = true;\n  }\n\n  return { error: plainObject };\n};\n\n// Create an error from the error format stored in mongo\nvar recreateError = function(errorDoc) {\n  var error;\n\n  if (errorDoc.meteorError) {\n    error = new Meteor.Error();\n    delete errorDoc.meteorError;\n  } else {\n    error = new Error();\n  }\n\n  Object.getOwnPropertyNames(errorDoc).forEach(function(key) {\n    error[key] = errorDoc[key];\n  });\n\n  return error;\n};\n","OAuth._storageTokenPrefix = \"Meteor.oauth.credentialSecret-\";\n\nOAuth._redirectUri = function (serviceName, config, params, absoluteUrlOptions) {\n  // XXX COMPAT WITH 0.9.0\n  // The redirect URI used to have a \"?close\" query argument.  We\n  // detect whether we need to be backwards compatible by checking for\n  // the absence of the `loginStyle` field, which wasn't used in the\n  // code which had the \"?close\" argument.\n  var query = config.loginStyle ? null : \"close\";\n\n  // Clone because we're going to mutate 'params'. The 'cordova' and\n  // 'android' parameters are only used for picking the host of the\n  // redirect URL, and not actually included in the redirect URL itself.\n  var isCordova = false;\n  var isAndroid = false;\n  if (params) {\n    params = _.clone(params);\n    isCordova = params.cordova;\n    isAndroid = params.android;\n    delete params.cordova;\n    delete params.android;\n    if (_.isEmpty(params)) {\n      params = undefined;\n    }\n  }\n\n  if (Meteor.isServer && isCordova) {\n    var rootUrl = process.env.MOBILE_ROOT_URL ||\n          __meteor_runtime_config__.ROOT_URL;\n\n    if (isAndroid) {\n      // Match the replace that we do in cordova boilerplate\n      // (boilerplate-generator package).\n      // XXX Maybe we should put this in a separate package or something\n      // that is used here and by boilerplate-generator? Or maybe\n      // `Meteor.absoluteUrl` should know how to do this?\n      var url = Npm.require(\"url\");\n      var parsedRootUrl = url.parse(rootUrl);\n      if (parsedRootUrl.hostname === \"localhost\") {\n        parsedRootUrl.hostname = \"10.0.2.2\";\n        delete parsedRootUrl.host;\n      }\n      rootUrl = url.format(parsedRootUrl);\n    }\n\n    absoluteUrlOptions = _.extend({}, absoluteUrlOptions, {\n      // For Cordova clients, redirect to the special Cordova root url\n      // (likely a local IP in development mode).\n      rootUrl: rootUrl\n    });\n  }\n\n  return URL._constructUrl(\n    Meteor.absoluteUrl('_oauth/' + serviceName, absoluteUrlOptions),\n    query,\n    params);\n};\n","// XXX COMPAT WITH 0.8.0\n\nOauth = OAuth;\n"]}