{"version":3,"sources":["matb33:collection-hooks/collection-hooks.js","matb33:collection-hooks/insert.js","matb33:collection-hooks/update.js","matb33:collection-hooks/remove.js","matb33:collection-hooks/find.js","matb33:collection-hooks/findone.js","matb33:collection-hooks/users-compat.js"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;AAAA,4B;AACA,kD;AACA,mE;AACA,yB;;AAEA,iB;AACA,8E;AACA,8D;AACA,qD;;AAEA,iD;AACA,gC;AACA,yC;AACA,E;;AAEA,sB;AACA,a;;AAEA,wB;AACA,qC;AACA,gD;AACA,O;AACA,G;;AAEA,wB;AACA,S;AACA,uD;AACA,mD;AACA,gD;AACA,kB;;AAEA,kB;AACA,wD;AACA,mC;AACA,K;AACA,G;;AAEA,gB;AACA,C;;AAEA,mB;AACA,a;AACA,kF;AACA,iF;AACA,8E;AACA,G;AACA,E;;AAEA,4D;AACA,6D;;AAEA,2D;AACA,6C;AACA,mD;AACA,+C;AACA,6C;AACA,mD;;AAEA,+C;AACA,2D;AACA,4D;AACA,yB;AACA,yE;AACA,W;;AAEA,gB;AACA,+C;AACA,oE;AACA,6B;AACA,6E;AACA,e;AACA,Y;AACA,+B;AACA,mE;AACA,W;AACA,U;AACA,Q;AACA,O;AACA,K;;AAEA,mE;AACA,kC;AACA,2E;AACA,2D;;AAEA,iE;AACA,6C;AACA,+E;AACA,oC;;AAEA,2C;AACA,uC;AACA,sC;AACA,mC;AACA,8C;AACA,S;AACA,M;;AAEA,sC;AACA,qC;AACA,mD;AACA,O;;AAEA,8B;AACA,oB;AACA,e;AACA,a;AACA,wC;AACA,wB;AACA,+C;AACA,sE;AACA,sD;AACA,U;AACA,4B;AACA,Q;AACA,M;AACA,K;AACA,E;;AAEA,0D;AACA,2B;AACA,E;;AAEA,oE;AACA,4F;AACA,E;;AAEA,8E;AACA,oD;AACA,oD;AACA,kD;AACA,wD;AACA,iB;AACA,E;;AAEA,oE;AACA,kB;;AAEA,gF;;AAEA,I;AACA,qC;AACA,yC;AACA,4B;AACA,wD;AACA,wC;AACA,O;AACA,G;AACA,I;;AAEA,8E;AACA,gD;AACA,gB;AACA,4E;AACA,wE;AACA,6E;AACA,uC;AACA,yB;AACA,4B;AACA,K;AACA,G;;AAEA,6D;AACA,6B;AACA,gD;AACA,E;;AAEA,iE;AACA,sE;;AAEA,4F;;AAEA,yC;AACA,yE;AACA,0B;AACA,sD;AACA,kC;AACA,0C;AACA,G;AACA,E;;AAEA,oD;AACA,4E;AACA,kF;;AAEA,8C;AACA,sC;;AAEA,+B;AACA,iD;AACA,mD;AACA,e;AACA,I;;AAEA,kC;;AAEA,iC;AACA,2C;AACA,8C;AACA,K;AACA,G;AACA,E;;AAEA,mC;AACA,gD;AACA,+C;AACA,Q;AACA,iD;AACA,C;;AAEA,sB;AACA,gC;AACA,0C;AACA,kD;AACA,2D;AACA,uC;AACA,oE;AACA,qC;AACA,S;AACA,O;AACA,I;;AAEA,4E;AACA,+D;AACA,iD;AACA,6C;AACA,I;AACA,C;;;;;;;;;;;;;;;;;;ACnOA,yG;AACA,kB;AACA,wD;AACA,8B;AACA,qC;AACA,iB;;AAEA,kB;AACA,uB;;AAEA,W;AACA,uC;AACA,8F;AACA,kC;AACA,K;;AAEA,0B;;AAEA,2B;AACA,sB;AACA,a;AACA,iC;AACA,mB;AACA,K;AACA,gF;AACA,wC;AACA,uC;AACA,O;AACA,c;AACA,G;;AAEA,c;AACA,iD;AACA,qD;AACA,6C;AACA,M;AACA,oC;AACA,U;AACA,mC;AACA,qD;AACA,G;AACA,G;;;;;;;;;;;;;;;;;;ACzCA,yG;AACA,kB;AACA,wD;AACA,8B;AACA,qC;AACA,8C;AACA,wE;;AAEA,uB;AACA,sB;AACA,iC;AACA,uB;;AAEA,8B;AACA,uB;AACA,iB;AACA,G;;AAEA,wC;AACA,gC;AACA,oF;AACA,6D;AACA,G;;AAEA,4D;AACA,sB;AACA,4F;AACA,6G;AACA,0C;AACA,0C;AACA,qB;AACA,mC;AACA,8C;AACA,S;AACA,K;AACA,G;;AAEA,W;AACA,uC;AACA,iC;AACA,kH;AACA,oC;AACA,O;AACA,K;;AAEA,0B;;AAEA,iC;AACA,oC;AACA,qG;;AAEA,wC;AACA,mC;AACA,gC;AACA,uC;AACA,oD;AACA,6B;AACA,kB;AACA,kE;AACA,S;AACA,O;AACA,G;;AAEA,c;AACA,sD;AACA,2B;AACA,6C;AACA,M;AACA,oC;AACA,U;AACA,4C;AACA,oB;AACA,oB;AACA,G;AACA,G;;AAEA,qE;AACA,0D;AACA,6E;AACA,0B;AACA,oC;AACA,4B;AACA,kB;AACA,yC;AACA,6C;AACA,2D;AACA,uB;AACA,oC;AACA,uD;;AAEA,iD;AACA,qC;AACA,2B;AACA,O;AACA,K;;AAEA,gB;AACA,E;;AAEA,qE;AACA,kD;AACA,6E;AACA,0B;AACA,oC;AACA,4B;AACA,kB;;AAEA,yC;AACA,4C;AACA,2H;AACA,4C;AACA,+C;AACA,6D;AACA,yB;AACA,sC;AACA,yD;;AAEA,mD;AACA,uC;AACA,6B;AACA,S;AACA,4C;AACA,Y;AACA,sB;AACA,K;AACA,4C;AACA,K;;AAEA,gB;AACA,E;;;;;;;;;;;;;;;;;;ACjIA,yG;AACA,kB;AACA,wD;AACA,8B;AACA,qC;AACA,6B;AACA,wE;;AAEA,uB;AACA,uB;;AAEA,wC;AACA,2E;AACA,G;;AAEA,4D;AACA,sB;AACA,iC;AACA,kC;AACA,O;AACA,G;;AAEA,W;AACA,uC;AACA,iC;AACA,wF;AACA,oC;AACA,O;AACA,K;;AAEA,0B;;AAEA,uB;AACA,wC;AACA,mC;AACA,4F;AACA,S;AACA,O;AACA,G;;AAEA,c;AACA,4C;AACA,iB;AACA,6C;AACA,M;AACA,oC;AACA,U;AACA,0C;AACA,Y;AACA,kB;AACA,G;AACA,G;;;;;;;;;;;;;;;;;;ACnDA,uG;AACA,kB;AACA,wD;AACA,iB;;AAEA,uB;AACA,sB;;AAEA,W;AACA,uC;AACA,yD;AACA,kC;AACA,K;;AAEA,0B;;AAEA,0B;AACA,wC;AACA,2D;AACA,O;AACA,G;;AAEA,iC;AACA,a;;AAEA,a;AACA,G;;;;;;;;;;;;;;;;;;AC1BA,0G;AACA,kB;AACA,wD;AACA,iB;;AAEA,uB;AACA,sB;;AAEA,W;AACA,uC;AACA,yD;AACA,kC;AACA,K;;AAEA,0B;;AAEA,uB;AACA,wC;AACA,wD;AACA,O;AACA,G;;AAEA,iC;AACA,a;;AAEA,a;AACA,G;;;;;;;;;;;;;;;;;;AC1BA,mB;AACA,+E;AACA,kD;;AAEA,oC;AACA,yD;AACA,C","file":"/packages/matb33:collection-hooks.js","sourcesContent":["// Relevant AOP terminology:\n// Aspect: User code that runs before/after (hook)\n// Advice: Wrapper code that knows when to call user code (aspects)\n// Pointcut: before/after\n\nvar advices = {};\nvar Tracker = Package.tracker && Package.tracker.Tracker || Package.deps.Deps;\n// XXX this only used on the server; should it really be here?\nvar publishUserId = new Meteor.EnvironmentVariable();\n\nvar directEnv = new Meteor.EnvironmentVariable();\nvar directOp = function (func) {\n  return directEnv.withValue(true, func);\n};\n\nfunction getUserId() {\n  var userId;\n\n  if (Meteor.isClient) {\n    Tracker.nonreactive(function () {\n      userId = Meteor.userId && Meteor.userId();\n    });\n  }\n\n  if (Meteor.isServer) {\n    try {\n      // Will throw an error unless within method call.\n      // Attempt to recover gracefully by catching:\n      userId = Meteor.userId && Meteor.userId();\n    } catch (e) {}\n\n    if (!userId) {\n      // Get the userId if we are in a publish function.\n      userId = publishUserId.get();\n    }\n  }\n\n  return userId;\n}\n\nCollectionHooks = {\n  defaults: {\n    before: { insert: {}, update: {}, remove: {}, find: {}, findOne: {}, all: {}},\n    after: { insert: {}, update: {}, remove: {}, find: {}, findOne: {}, all: {}},\n    all: { insert: {}, update: {}, remove: {}, find: {}, findOne: {}, all: {}}\n  }\n};\n\nCollectionHooks.extendCollectionInstance = function (self) {\n  var collection = Meteor.isClient ? self : self._collection;\n\n  // Offer a public API to allow the user to define aspects\n  // Example: collection.before.insert(func);\n  _.each([\"before\", \"after\"], function (pointcut) {\n    _.each(advices, function (advice, method) {\n      Meteor._ensure(self, pointcut, method);\n      Meteor._ensure(self, \"_hookAspects\", method);\n\n      self._hookAspects[method][pointcut] = [];\n      self[pointcut][method] = function (aspect, options) {\n        var len = self._hookAspects[method][pointcut].push({\n          aspect: aspect,\n          options: CollectionHooks.initOptions(options, pointcut, method)\n        });\n\n        return {\n          replace: function (aspect, options) {\n            self._hookAspects[method][pointcut].splice(len - 1, 1, {\n              aspect: aspect,\n              options: CollectionHooks.initOptions(options, pointcut, method)\n            });\n          },\n          remove: function () {\n            self._hookAspects[method][pointcut].splice(len - 1, 1);\n          }\n        };\n      };\n    });\n  });\n\n  // Offer a publicly accessible object to allow the user to define\n  // collection-wide hook options.\n  // Example: collection.hookOptions.after.update = {fetchPrevious: false};\n  self.hookOptions = EJSON.clone(CollectionHooks.defaults);\n\n  // Wrap mutator methods, letting the defined advice do the work\n  _.each(advices, function (advice, method) {\n    // Store a reference to the mutator method in a publicly reachable location\n    var _super = collection[method];\n\n    Meteor._ensure(self, \"direct\", method);\n    self.direct[method] = function () {\n      var args = _.toArray(arguments);\n      return directOp(function () {\n        return _super.apply(collection, args);\n      });\n    };\n\n    collection[method] = function () {\n      if (directEnv.get() === true) {\n        return _super.apply(collection, arguments);\n      }\n\n      return advice.call(this,\n        getUserId(),\n        _super,\n        self,\n        self._hookAspects[method] || {},\n        function (doc) {\n          return  _.isFunction(self._transform)\n                  ? function (d) { return self._transform(d || doc); }\n                  : function (d) { return d || doc; };\n        },\n        _.toArray(arguments)\n      );\n    };\n  });\n};\n\nCollectionHooks.defineAdvice = function (method, advice) {\n  advices[method] = advice;\n};\n\nCollectionHooks.initOptions = function (options, pointcut, method) {\n  return CollectionHooks.extendOptions(CollectionHooks.defaults, options, pointcut, method);\n};\n\nCollectionHooks.extendOptions = function (source, options, pointcut, method) {\n  options = _.extend(options || {}, source.all.all);\n  options = _.extend(options, source[pointcut].all);\n  options = _.extend(options, source.all[method]);\n  options = _.extend(options, source[pointcut][method]);\n  return options;\n};\n\nCollectionHooks.getDocs = function (collection, selector, options) {\n  var self = this;\n\n  var findOptions = {transform: null, reactive: false}; // added reactive: false\n\n  /*\n  // No \"fetch\" support at this time.\n  if (!self._validators.fetchAllFields) {\n    findOptions.fields = {};\n    _.each(self._validators.fetch, function(fieldName) {\n      findOptions.fields[fieldName] = 1;\n    });\n  }\n  */\n\n  // Bit of a magic condition here... only \"update\" passes options, so this is\n  // only relevant to when update calls getDocs:\n  if (options) {\n    // This was added because in our case, we are potentially iterating over\n    // multiple docs. If multi isn't enabled, force a limit (almost like\n    // findOne), as the default for update without multi enabled is to affect\n    // only the first matched document:\n    if (!options.multi) {\n      findOptions.limit = 1;\n    }\n  }\n\n  // Unlike validators, we iterate over multiple docs, so use\n  // find instead of findOne:\n  return collection.find(selector, findOptions);\n};\n\nCollectionHooks.reassignPrototype = function (instance, constr) {\n  var hasSetPrototypeOf = typeof Object.setPrototypeOf === \"function\";\n\n  if (!constr) constr = typeof Mongo !== \"undefined\" ? Mongo.Collection : Meteor.Collection;\n\n  // __proto__ is not available in < IE11\n  // Note: Assigning a prototype dynamically has performance implications\n  if (hasSetPrototypeOf) {\n    Object.setPrototypeOf(instance, constr.prototype);\n  } else if (instance.__proto__) {\n    instance.__proto__ = constr.prototype;\n  }\n};\n\nCollectionHooks.wrapCollection = function (ns, as) {\n  if (!as._CollectionConstructor) as._CollectionConstructor = as.Collection;\n  if (!as._CollectionPrototype) as._CollectionPrototype = new as.Collection(null);\n\n  var constructor = as._CollectionConstructor;\n  var proto = as._CollectionPrototype;\n\n  ns.Collection = function () {\n    var ret = constructor.apply(this, arguments);\n    CollectionHooks.extendCollectionInstance(this);\n    return ret;\n  };\n\n  ns.Collection.prototype = proto;\n\n  for (var prop in constructor) {\n    if (constructor.hasOwnProperty(prop)) {\n      ns.Collection[prop] = constructor[prop];\n    }\n  }\n};\n\nif (typeof Mongo !== \"undefined\") {\n  CollectionHooks.wrapCollection(Meteor, Mongo);\n  CollectionHooks.wrapCollection(Mongo, Mongo);\n} else {\n  CollectionHooks.wrapCollection(Meteor, Meteor);\n}\n\nif (Meteor.isServer) {\n  var _publish = Meteor.publish;\n  Meteor.publish = function (name, func) {\n    return _publish.call(this, name, function () {\n      // This function is called repeatedly in publications\n      var ctx = this, args = arguments;\n      return publishUserId.withValue(ctx && ctx.userId, function() {\n        return func.apply(ctx, args);\n      });\n    });\n  };\n\n  // Make the above available for packages with hooks that want to determine\n  // whether they are running inside a publish function or not.\n  CollectionHooks.isWithinPublish = function () {\n    return publishUserId.get() !== undefined;\n  };\n}","CollectionHooks.defineAdvice(\"insert\", function (userId, _super, instance, aspects, getTransform, args) {\n  var self = this;\n  var ctx = {context: self, _super: _super, args: args};\n  var callback = _.last(args);\n  var async = _.isFunction(callback);\n  var abort, ret;\n\n  // args[0] : doc\n  // args[1] : callback\n\n  // before\n  _.each(aspects.before, function (o) {\n    var r = o.aspect.call(_.extend({transform: getTransform(args[0])}, ctx), userId, args[0]);\n    if (r === false) abort = true;\n  });\n\n  if (abort) return false;\n\n  function after(id, err) {\n    var doc = args[0];\n    if (id) {\n      doc = EJSON.clone(args[0]);\n      doc._id = id;\n    }\n    var lctx = _.extend({transform: getTransform(doc), _id: id, err: err}, ctx);\n    _.each(aspects.after, function (o) {\n      o.aspect.call(lctx, userId, doc);\n    });\n    return id;\n  }\n\n  if (async) {\n    args[args.length - 1] = function (err, obj) {\n      after(obj && obj[0] && obj[0]._id || obj, err);\n      return callback.apply(this, arguments);\n    };\n    return _super.apply(self, args);\n  } else {\n    ret = _super.apply(self, args);\n    return after(ret && ret[0] && ret[0]._id || ret);\n  }\n});","CollectionHooks.defineAdvice(\"update\", function (userId, _super, instance, aspects, getTransform, args) {\n  var self = this;\n  var ctx = {context: self, _super: _super, args: args};\n  var callback = _.last(args);\n  var async = _.isFunction(callback);\n  var docs, docsIds, fields, abort, prev = {};\n  var collection = _.has(self, \"_collection\") ? self._collection : self;\n\n  // args[0] : selector\n  // args[1] : mutator\n  // args[2] : options (optional)\n  // args[3] : callback\n\n  if (_.isFunction(args[2])) {\n    callback = args[2];\n    args[2] = {};\n  }\n\n  if (aspects.before || aspects.after) {\n    fields = getFields(args[1]);\n    docs = CollectionHooks.getDocs.call(self, collection, args[0], args[2]).fetch();\n    docIds = _.map(docs, function (doc) { return doc._id; });\n  }\n\n  // copy originals for convenience for the \"after\" pointcut\n  if (aspects.after) {\n    if (_.some(aspects.after, function (o) { return o.options.fetchPrevious !== false; }) &&\n        CollectionHooks.extendOptions(instance.hookOptions, {}, \"after\", \"update\").fetchPrevious !== false) {\n      prev.mutator = EJSON.clone(args[1]);\n      prev.options = EJSON.clone(args[2]);\n      prev.docs = {};\n      _.each(docs, function (doc) {\n        prev.docs[doc._id] = EJSON.clone(doc);\n      });\n    }\n  }\n\n  // before\n  _.each(aspects.before, function (o) {\n    _.each(docs, function (doc) {\n      var r = o.aspect.call(_.extend({transform: getTransform(doc)}, ctx), userId, doc, fields, args[1], args[2]);\n      if (r === false) abort = true;\n    });\n  });\n\n  if (abort) return false;\n\n  function after(affected, err) {\n    var fields = getFields(args[1]);\n    var docs = CollectionHooks.getDocs.call(self, collection, {_id: {$in: docIds}}, args[2]).fetch();\n\n    _.each(aspects.after, function (o) {\n      _.each(docs, function (doc) {\n        o.aspect.call(_.extend({\n          transform: getTransform(doc),\n          previous: prev.docs && prev.docs[doc._id],\n          affected: affected,\n          err: err\n        }, ctx), userId, doc, fields, prev.mutator, prev.options);\n      });\n    });\n  }\n\n  if (async) {\n    args[args.length - 1] = function (err, affected) {\n      after(affected, err);\n      return callback.apply(this, arguments);\n    };\n    return _super.apply(this, args);\n  } else {\n    var affected = _super.apply(self, args);\n    after(affected);\n    return affected;\n  }\n});\n\n// This function contains a snippet of code pulled and modified from:\n// ~/.meteor/packages/mongo-livedata/collection.js:632-668\n// It's contained in these utility functions to make updates easier for us in\n// case this code changes.\nvar getFields = function (mutator) {\n  // compute modified fields\n  var fields = [];\n  _.each(mutator, function (params, op) {\n    _.each(_.keys(params), function (field) {\n      // treat dotted fields as if they are replacing their\n      // top-level part\n      if (field.indexOf('.') !== -1)\n        field = field.substring(0, field.indexOf('.'));\n\n      // record the field we are trying to change\n      if (!_.contains(fields, field))\n        fields.push(field);\n    });\n  });\n\n  return fields;\n};\n\n// This function contains a snippet of code pulled and modified from:\n// ~/.meteor/packages/mongo-livedata/collection.js\n// It's contained in these utility functions to make updates easier for us in\n// case this code changes.\nvar getFields = function (mutator) {\n  // compute modified fields\n  var fields = [];\n\n  _.each(mutator, function (params, op) {\n    //====ADDED START=======================\n    if (_.contains([\"$set\", \"$unset\", \"$inc\", \"$push\", \"$pull\", \"$pop\", \"$rename\", \"$pullAll\", \"$addToSet\", \"$bit\"], op)) {\n    //====ADDED END=========================\n      _.each(_.keys(params), function (field) {\n        // treat dotted fields as if they are replacing their\n        // top-level part\n        if (field.indexOf('.') !== -1)\n          field = field.substring(0, field.indexOf('.'));\n\n        // record the field we are trying to change\n        if (!_.contains(fields, field))\n          fields.push(field);\n      });\n    //====ADDED START=======================\n    } else {\n      fields.push(op);\n    }\n    //====ADDED END=========================\n  });\n\n  return fields;\n};","CollectionHooks.defineAdvice(\"remove\", function (userId, _super, instance, aspects, getTransform, args) {\n  var self = this;\n  var ctx = {context: self, _super: _super, args: args};\n  var callback = _.last(args);\n  var async = _.isFunction(callback);\n  var docs, abort, prev = [];\n  var collection = _.has(self, \"_collection\") ? self._collection : self;\n\n  // args[0] : selector\n  // args[1] : callback\n\n  if (aspects.before || aspects.after) {\n    docs = CollectionHooks.getDocs.call(self, collection, args[0]).fetch();\n  }\n\n  // copy originals for convenience for the \"after\" pointcut\n  if (aspects.after) {\n    _.each(docs, function (doc) {\n      prev.push(EJSON.clone(doc));\n    });\n  }\n\n  // before\n  _.each(aspects.before, function (o) {\n    _.each(docs, function (doc) {\n      var r = o.aspect.call(_.extend({transform: getTransform(doc)}, ctx), userId, doc);\n      if (r === false) abort = true;\n    });\n  });\n\n  if (abort) return false;\n\n  function after(err) {\n    _.each(aspects.after, function (o) {\n      _.each(prev, function (doc) {\n        o.aspect.call(_.extend({transform: getTransform(doc), err: err}, ctx), userId, doc);\n      });\n    });\n  }\n\n  if (async) {\n    args[args.length - 1] = function (err) {\n      after(err);\n      return callback.apply(this, arguments);\n    };\n    return _super.apply(self, args);\n  } else {\n    var result = _super.apply(self, args);\n    after();\n    return result;\n  }\n});","CollectionHooks.defineAdvice(\"find\", function (userId, _super, instance, aspects, getTransform, args) {\n  var self = this;\n  var ctx = {context: self, _super: _super, args: args};\n  var ret, abort;\n\n  // args[0] : selector\n  // args[1] : options\n\n  // before\n  _.each(aspects.before, function (o) {\n    var r = o.aspect.call(ctx, userId, args[0], args[1]);\n    if (r === false) abort = true;\n  });\n\n  if (abort) return false;\n\n  function after(cursor) {\n    _.each(aspects.after, function (o) {\n      o.aspect.call(ctx, userId, args[0], args[1], cursor);\n    });\n  }\n\n  ret = _super.apply(self, args);\n  after(ret);\n\n  return ret;\n});","CollectionHooks.defineAdvice(\"findOne\", function (userId, _super, instance, aspects, getTransform, args) {\n  var self = this;\n  var ctx = {context: self, _super: _super, args: args};\n  var ret, abort;\n\n  // args[0] : selector\n  // args[1] : options\n\n  // before\n  _.each(aspects.before, function (o) {\n    var r = o.aspect.call(ctx, userId, args[0], args[1]);\n    if (r === false) abort = true;\n  });\n\n  if (abort) return false;\n\n  function after(doc) {\n    _.each(aspects.after, function (o) {\n      o.aspect.call(ctx, userId, args[0], args[1], doc);\n    });\n  }\n\n  ret = _super.apply(self, args);\n  after(ret);\n\n  return ret;\n});","if (Meteor.users) {\n  // If Meteor.users has been instantiated, attempt to re-assign its prototype:\n  CollectionHooks.reassignPrototype(Meteor.users);\n\n  // Next, give it the hook aspects:\n  CollectionHooks.extendCollectionInstance(Meteor.users);\n}"]}