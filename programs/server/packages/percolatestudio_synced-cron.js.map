{"version":3,"file":"/packages/percolatestudio:synced-cron.js","sources":["percolatestudio:synced-cron/synced-cron-server.js"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;AAAA,oE;AACA,c;AACA,e;AACA,iB;AACA,Y;AACA,oC;AACA,c;;AAEA,+D;AACA,kC;;AAEA,gC;AACA,e;;AAEA,gE;AACA,uE;AACA,mB;AACA,yB;AACA,G;AACA,C;;AAEA,6B;;AAEA,2B;AACA,mC;;AAEA,0E;AACA,mB;;AAEA,kD;AACA,kB;AACA,qB;AACA,M;AACA,2B;;AAEA,+C;AACA,wE;AACA,gF;;AAEA,8B;AACA,uC;AACA,0D;AACA,wD;AACA,Q;AACA,oF;AACA,G;AACA,G;;AAEA,W;AACA,2B;AACA,+B;AACA,mC;AACA,G;AACA,C;;AAEA,qC;AACA,6C;AACA,iB;AACA,4E;;AAEA,kE;AACA,wC;AACA,C;;AAEA,sB;AACA,mB;AACA,sD;AACA,wE;AACA,qD;AACA,M;AACA,kC;AACA,4B;AACA,kC;AACA,6B;;AAEA,U;AACA,oC;;AAEA,gD;AACA,qB;AACA,yB;AACA,G;AACA,C;;AAEA,8B;AACA,+B;AACA,kB;;AAEA,6B;AACA,sC;AACA,2C;AACA,2B;AACA,O;AACA,wB;AACA,K;AACA,C;;AAEA,0E;AACA,oD;AACA,qC;;AAEA,Y;AACA,+D;AACA,C;;AAEA,kD;AACA,uC;AACA,qC;;AAEA,c;AACA,qB;AACA,2B;;AAEA,kC;AACA,mD;AACA,G;AACA,C;;AAEA,sC;AACA,8B;AACA,+C;AACA,4B;AACA,K;AACA,uB;AACA,C;;AAEA,0E;AACA,qE;AACA,4C;AACA,kB;;AAEA,+B;AACA,sB;AACA,6B;AACA,uB;AACA,2B;AACA,M;;AAEA,4E;AACA,gB;AACA,S;AACA,2D;AACA,gB;AACA,+D;AACA,qC;AACA,wD;AACA,wE;AACA,e;AACA,O;;AAEA,c;AACA,M;;AAEA,6B;AACA,S;AACA,6D;AACA,kE;;AAEA,6D;AACA,sD;AACA,e;AACA,iC;AACA,wB;AACA,S;AACA,S;AACA,gB;AACA,uE;AACA,sD;AACA,e;AACA,iC;AACA,wB;AACA,S;AACA,S;AACA,K;AACA,I;AACA,C;;AAEA,Y;AACA,gC;AACA,qB;AACA,8B;AACA,uB;AACA,C;;AAEA,8E;AACA,4E;AACA,mC;AACA,kD;AACA,kF;AACA,4E;AACA,8D;;AAEA,4E;AACA,oD;;AAEA,8D;AACA,mB;;AAEA,K;AACA,0E;AACA,a;AACA,I;AACA,wC;AACA,e;AACA,qB;AACA,8D;AACA,K;AACA,G;;AAEA,U;;AAEA,O;AACA,yB;AACA,M;AACA,uB;AACA,kB;AACA,gB;AACA,K;;AAEA,I;;AAEA,E;;AAEA,2E;AACA,mD;;AAEA,mC;AACA,oB;;AAEA,K;AACA,8E;AACA,4E;AACA,6C;AACA,I;AACA,8B;AACA,yB;AACA,8B;AACA,uC;AACA,6B;;AAEA,sE;AACA,qB;AACA,qC;AACA,2B;AACA,K;;AAEA,2B;AACA,kE;AACA,K;AACA,U;AACA,yD;AACA,K;AACA,G;;AAEA,U;;AAEA,O;AACA,yB;AACA,M;AACA,uB;AACA,6B;AACA,K;;AAEA,I;;AAEA,E;AACA,8E","sourcesContent":["// A package for running jobs synchronized across multiple processes\nSyncedCron = {\n  _entries: {},\n  running: false,\n  options: {\n    //Log job run details to console\n    log: true,\n\n    //Name of collection to use for synchronisation and logging\n    collectionName: 'cronHistory',\n\n    //Default to using localTime\n    utc: false,\n\n    //TTL in seconds for history records in collection to expire\n    //NOTE: Unset to remove expiry but ensure you remove the index from\n    //mongo by hand\n    collectionTTL: 172800\n  }\n}\n\nLater = Npm.require('later');\n\nMeteor.startup(function() {\n  var options = SyncedCron.options;\n\n  // Don't allow TTL less than 5 minutes so we don't break synchronization\n  var minTTL = 300;\n\n  // Use UTC or localtime for evaluating schedules\n  if (options.utc)\n    Later.date.UTC();\n  else\n    Later.date.localTime();\n\n  // collection holding the job history records\n  SyncedCron._collection = new Mongo.Collection(options.collectionName);\n  SyncedCron._collection._ensureIndex({intendedAt: 1, name: 1}, {unique: true});\n\n  if (options.collectionTTL) {\n    if (options.collectionTTL > minTTL)\n      SyncedCron._collection._ensureIndex({startedAt: 1 },\n        { expireAfterSeconds: options.collectionTTL } );\n    else\n      console.log('Warning: Not going to use a TTL that is shorter than:' + minTTL);\n  }\n});\n\nvar log = {\n  info: function(message) {\n    if (SyncedCron.options.log)\n      Log.info({message: message});\n  }\n}\n\nvar scheduleEntry = function(entry) {\n  var schedule = entry.schedule(Later.parse);\n  entry._timer = \n    SyncedCron._laterSetInterval(SyncedCron._entryWrapper(entry), schedule);\n\n  log.info('SyncedCron: scheduled \"' + entry.name + '\" next run @'\n    + Later.schedule(schedule).next(1));\n}\n\n// add a scheduled job\n// SyncedCron.add({\n//   name: String, //*required* unique name of the job\n//   schedule: function(laterParser) {},//*required* when to run the job\n//   job: function() {}, //*required* the code to run\n// });\nSyncedCron.add = function(entry) {\n  check(entry.name, String);\n  check(entry.schedule, Function);\n  check(entry.job, Function);\n\n  // check\n  this._entries[entry.name] = entry;\n\n  // If cron is already running, start directly.\n  if (this.running) {\n    scheduleEntry(entry);\n  }\n}\n\n// Start processing added jobs\nSyncedCron.start = function() {\n  var self = this;\n\n  Meteor.startup(function() {\n    // Schedule each job with later.js\n    _.each(self._entries, function(entry) {\n      scheduleEntry(entry);\n    });\n    self.running = true;\n  });\n}\n\n// Return the next scheduled date of the first matching entry or undefined\nSyncedCron.nextScheduledAtDate = function(jobName) {\n  var entry = this._entries[jobName];\n\n  if (entry)\n    return Later.schedule(entry.schedule(Later.parse)).next(1);\n}\n\n// Remove and stop the entry referenced by jobName\nSyncedCron.remove = function(jobName) {\n  var entry = this._entries[jobName];\n\n  if (entry) {\n    if (entry._timer)\n      entry._timer.clear();\n\n    delete this._entries[jobName];\n    log.info('SyncedCron: Removed \"' + entry.name);\n  }\n}\n\n// Stop processing and remove ALL jobs\nSyncedCron.stop = function() {\n  _.each(this._entries, function(entry, name) {\n    SyncedCron.remove(name);\n  });\n  this.running = false;\n}\n\n// The meat of our logic. Checks if the specified has already run. If not,\n// records that it's running the job, runs it, and records the output\nSyncedCron._entryWrapper = function(entry) {\n  var self = this;\n\n  return function(intendedAt) {\n    var jobHistory = {\n      intendedAt: intendedAt,\n      name: entry.name,\n      startedAt: new Date()\n    };\n\n    // If we have a dup key error, another instance has already tried to run\n    // this job.\n    try {\n      jobHistory._id = self._collection.insert(jobHistory);\n    } catch(e) {\n      // http://www.mongodb.org/about/contributors/error-codes/\n      // 11000 == duplicate key error\n      if (e.name === 'MongoError' && e.code === 11000) {\n        log.info('SyncedCron: Not running \"' + entry.name + '\" again.');\n        return;\n      }\n\n      throw e;\n    };\n\n    // run and record the job\n    try {\n      log.info('SyncedCron: Starting \"' + entry.name + '\".');\n      var output = entry.job(intendedAt); // <- Run the actual job\n\n      log.info('SyncedCron: Finished \"' + entry.name + '\".');\n      self._collection.update({_id: jobHistory._id}, {\n        $set: {\n          finishedAt: new Date(),\n          result: output\n        }\n      });\n    } catch(e) {\n      log.info('SyncedCron: Exception \"' + entry.name +'\" ' + e.stack);\n      self._collection.update({_id: jobHistory._id}, {\n        $set: {\n          finishedAt: new Date(),\n          error: e.stack\n        }\n      });\n    }\n  };\n}\n\n// for tests\nSyncedCron._reset = function() {\n  this._entries = {};\n  this._collection.remove({});\n  this.running = false;\n}\n\n// ---------------------------------------------------------------------------\n// The following two functions are lifted from the later.js package, however\n// I've made the following changes:\n// - Use Meteor.setTimeout and Meteor.clearTimeout\n// - Added an 'intendedAt' parameter to the callback fn that specifies the precise\n//   time the callback function *should* be run (so we can co-ordinate jobs)\n//   between multiple, potentially laggy and unsynced machines\n\n// From: https://github.com/bunkat/later/blob/master/src/core/setinterval.js\nSyncedCron._laterSetInterval = function(fn, sched) {\n\n  var t = SyncedCron._laterSetTimeout(scheduleTimeout, sched),\n      done = false;\n\n  /**\n  * Executes the specified function and then sets the timeout for the next\n  * interval.\n  */\n  function scheduleTimeout(intendedAt) {\n    if(!done) {\n      fn(intendedAt);\n      t = SyncedCron._laterSetTimeout(scheduleTimeout, sched);\n    }\n  }\n\n  return {\n\n    /**\n    * Clears the timeout.\n    */\n    clear: function() {\n      done = true;\n      t.clear();\n    }\n\n  };\n\n};\n\n// From: https://github.com/bunkat/later/blob/master/src/core/settimeout.js\nSyncedCron._laterSetTimeout = function(fn, sched) {\n\n  var s = Later.schedule(sched), t;\n  scheduleTimeout();\n\n  /**\n  * Schedules the timeout to occur. If the next occurrence is greater than the\n  * max supported delay (2147483647 ms) than we delay for that amount before\n  * attempting to schedule the timeout again.\n  */\n  function scheduleTimeout() {\n    var now = Date.now(),\n        next = s.next(2, now),\n        diff = next[0].getTime() - now,\n        intendedAt = next[0];\n\n    // minimum time to fire is one second, use next occurrence instead\n    if(diff < 1000) {\n      diff = next[1].getTime() - now;\n      intendedAt = next[1];\n    }\n\n    if(diff < 2147483647) {\n      t = Meteor.setTimeout(function() { fn(intendedAt); }, diff);\n    }\n    else {\n      t = Meteor.setTimeout(scheduleTimeout, 2147483647);\n    }\n  }\n\n  return {\n\n    /**\n    * Clears the timeout.\n    */\n    clear: function() {\n      Meteor.clearTimeout(t);\n    }\n\n  };\n\n};\n// ---------------------------------------------------------------------------\n"]}